{"ast":null,"code":"'use client';\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo } from 'react';\nimport clsx from 'clsx';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport invariant from 'tiny-invariant';\nimport warning from 'warning';\nimport OutlineContext from './OutlineContext.js';\nimport OutlineItem from './OutlineItem.js';\nimport useDocumentContext from './shared/hooks/useDocumentContext.js';\nimport useResolver from './shared/hooks/useResolver.js';\nimport { cancelRunningTask } from './shared/utils.js';\n/**\n * Displays an outline (table of contents).\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function.\n */\nexport default function Outline(props) {\n  const documentContext = useDocumentContext();\n  const mergedProps = {\n    ...documentContext,\n    ...props\n  };\n  const {\n    className,\n    inputRef,\n    onItemClick,\n    onLoadError: onLoadErrorProps,\n    onLoadSuccess: onLoadSuccessProps,\n    pdf,\n    ...otherProps\n  } = mergedProps;\n  invariant(pdf, 'Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.');\n  const [outlineState, outlineDispatch] = useResolver();\n  const {\n    value: outline,\n    error: outlineError\n  } = outlineState;\n  /**\n   * Called when an outline is read successfully\n   */\n  function onLoadSuccess() {\n    if (typeof outline === 'undefined' || outline === false) {\n      return;\n    }\n    if (onLoadSuccessProps) {\n      onLoadSuccessProps(outline);\n    }\n  }\n  /**\n   * Called when an outline failed to read successfully\n   */\n  function onLoadError() {\n    if (!outlineError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, outlineError.toString());\n    if (onLoadErrorProps) {\n      onLoadErrorProps(outlineError);\n    }\n  }\n  // biome-ignore lint/correctness/useExhaustiveDependencies: useEffect intentionally triggered on pdf change\n  useEffect(function resetOutline() {\n    outlineDispatch({\n      type: 'RESET'\n    });\n  }, [outlineDispatch, pdf]);\n  useEffect(function loadOutline() {\n    if (!pdf) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    const cancellable = makeCancellable(pdf.getOutline());\n    const runningTask = cancellable;\n    cancellable.promise.then(nextOutline => {\n      outlineDispatch({\n        type: 'RESOLVE',\n        value: nextOutline\n      });\n    }).catch(error => {\n      outlineDispatch({\n        type: 'REJECT',\n        error\n      });\n    });\n    return () => cancelRunningTask(runningTask);\n  }, [outlineDispatch, pdf]);\n  // biome-ignore lint/correctness/useExhaustiveDependencies: Omitted callbacks so they are not called every time they change\n  useEffect(() => {\n    if (outline === undefined) {\n      return;\n    }\n    if (outline === false) {\n      onLoadError();\n      return;\n    }\n    onLoadSuccess();\n  }, [outline]);\n  const childContext = useMemo(() => ({\n    onItemClick\n  }), [onItemClick]);\n  const eventProps = useMemo(() => makeEventProps(otherProps, () => outline),\n  // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME\n  [otherProps, outline]);\n  if (!outline) {\n    return null;\n  }\n  function renderOutline() {\n    if (!outline) {\n      return null;\n    }\n    return _jsx(\"ul\", {\n      children: outline.map((item, itemIndex) => _jsx(OutlineItem, {\n        item: item,\n        pdf: pdf\n      }, typeof item.dest === 'string' ? item.dest : itemIndex))\n    });\n  }\n  return _jsx(\"div\", {\n    className: clsx('react-pdf__Outline', className),\n    ref: inputRef,\n    ...eventProps,\n    children: _jsx(OutlineContext.Provider, {\n      value: childContext,\n      children: renderOutline()\n    })\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}