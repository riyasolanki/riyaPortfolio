{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n/**\n * Loads a PDF document. Passes it to all children.\n */\nimport React, { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport makeEventProps from 'make-event-props';\nimport makeCancellable from 'make-cancellable-promise';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport * as pdfjs from 'pdfjs-dist';\nimport DocumentContext from './DocumentContext';\nimport Message from './Message';\nimport LinkService from './LinkService';\nimport PasswordResponses from './PasswordResponses';\nimport { cancelRunningTask, dataURItoByteString, displayCORSWarning, isArrayBuffer, isBlob, isBrowser, isDataURI, loadFromFile } from './shared/utils';\nimport { useResolver } from './shared/hooks';\nimport { eventProps, isClassName, isFile, isRef } from './shared/propTypes';\nconst {\n  PDFDataRangeTransport\n} = pdfjs;\nconst defaultOnPassword = (callback, reason) => {\n  switch (reason) {\n    case PasswordResponses.NEED_PASSWORD:\n      {\n        // eslint-disable-next-line no-alert\n        const password = prompt('Enter the password to open this PDF file.');\n        callback(password);\n        break;\n      }\n    case PasswordResponses.INCORRECT_PASSWORD:\n      {\n        // eslint-disable-next-line no-alert\n        const password = prompt('Invalid password. Please try again.');\n        callback(password);\n        break;\n      }\n    default:\n  }\n};\nconst Document = forwardRef(function Document(_a, ref) {\n  var {\n      children,\n      className,\n      error = 'Failed to load PDF file.',\n      externalLinkRel,\n      externalLinkTarget,\n      file,\n      inputRef,\n      imageResourcesPath,\n      loading = 'Loading PDFâ€¦',\n      noData = 'No PDF file specified.',\n      onItemClick,\n      onLoadError: onLoadErrorProps,\n      onLoadProgress,\n      onLoadSuccess: onLoadSuccessProps,\n      onPassword = defaultOnPassword,\n      onSourceError: onSourceErrorProps,\n      onSourceSuccess: onSourceSuccessProps,\n      options,\n      renderMode,\n      rotate\n    } = _a,\n    otherProps = __rest(_a, [\"children\", \"className\", \"error\", \"externalLinkRel\", \"externalLinkTarget\", \"file\", \"inputRef\", \"imageResourcesPath\", \"loading\", \"noData\", \"onItemClick\", \"onLoadError\", \"onLoadProgress\", \"onLoadSuccess\", \"onPassword\", \"onSourceError\", \"onSourceSuccess\", \"options\", \"renderMode\", \"rotate\"]);\n  const [sourceState, sourceDispatch] = useResolver();\n  const {\n    value: source,\n    error: sourceError\n  } = sourceState;\n  const [pdfState, pdfDispatch] = useResolver();\n  const {\n    value: pdf,\n    error: pdfError\n  } = pdfState;\n  const linkService = useRef(new LinkService());\n  const pages = useRef([]);\n  const viewer = useRef({\n    // Handling jumping to internal links target\n    scrollPageIntoView: _ref => {\n      let {\n        dest,\n        pageIndex,\n        pageNumber\n      } = _ref;\n      // First, check if custom handling of onItemClick was provided\n      if (onItemClick) {\n        onItemClick({\n          dest,\n          pageIndex,\n          pageNumber\n        });\n        return;\n      }\n      // If not, try to look for target page within the <Document>.\n      const page = pages.current[pageIndex];\n      if (page) {\n        // Scroll to the page automatically\n        page.scrollIntoView();\n        return;\n      }\n      warning(false, `An internal link leading to page ${pageNumber} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`);\n    }\n  });\n  useImperativeHandle(ref, () => {\n    return {\n      linkService,\n      pages,\n      viewer\n    };\n  }, []);\n  /**\n   * Called when a document source is resolved correctly\n   */\n  function onSourceSuccess() {\n    if (onSourceSuccessProps) {\n      onSourceSuccessProps();\n    }\n  }\n  /**\n   * Called when a document source failed to be resolved correctly\n   */\n  function onSourceError() {\n    if (!sourceError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, sourceError.toString());\n    if (onSourceErrorProps) {\n      onSourceErrorProps(sourceError);\n    }\n  }\n  function resetSource() {\n    sourceDispatch({\n      type: 'RESET'\n    });\n  }\n  useEffect(resetSource, [file, sourceDispatch]);\n  const findDocumentSource = useCallback(() => __awaiter(this, void 0, void 0, function* () {\n    if (!file) {\n      return null;\n    }\n    // File is a string\n    if (typeof file === 'string') {\n      if (isDataURI(file)) {\n        const fileByteString = dataURItoByteString(file);\n        return {\n          data: fileByteString\n        };\n      }\n      displayCORSWarning();\n      return {\n        url: file\n      };\n    }\n    // File is PDFDataRangeTransport\n    if (file instanceof PDFDataRangeTransport) {\n      return {\n        range: file\n      };\n    }\n    // File is an ArrayBuffer\n    if (isArrayBuffer(file)) {\n      return {\n        data: file\n      };\n    }\n    /**\n     * The cases below are browser-only.\n     * If you're running on a non-browser environment, these cases will be of no use.\n     */\n    if (isBrowser) {\n      // File is a Blob\n      if (isBlob(file)) {\n        const data = yield loadFromFile(file);\n        return {\n          data\n        };\n      }\n    }\n    // At this point, file must be an object\n    invariant(typeof file === 'object', 'Invalid parameter in file, need either Uint8Array, string or a parameter object');\n    invariant('data' in file || 'range' in file || 'url' in file, 'Invalid parameter object: need either .data, .range or .url');\n    // File .url is a string\n    if ('url' in file && typeof file.url === 'string') {\n      if (isDataURI(file.url)) {\n        const {\n            url\n          } = file,\n          otherParams = __rest(file, [\"url\"]);\n        const fileByteString = dataURItoByteString(url);\n        return Object.assign({\n          data: fileByteString\n        }, otherParams);\n      }\n      displayCORSWarning();\n    }\n    return file;\n  }), [file]);\n  useEffect(() => {\n    const cancellable = makeCancellable(findDocumentSource());\n    cancellable.promise.then(nextSource => {\n      sourceDispatch({\n        type: 'RESOLVE',\n        value: nextSource\n      });\n    }).catch(error => {\n      sourceDispatch({\n        type: 'REJECT',\n        error\n      });\n    });\n    return () => {\n      cancelRunningTask(cancellable);\n    };\n  }, [findDocumentSource, sourceDispatch]);\n  useEffect(() => {\n    if (typeof source === 'undefined') {\n      return;\n    }\n    if (source === false) {\n      onSourceError();\n      return;\n    }\n    onSourceSuccess();\n  },\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [source]);\n  /**\n   * Called when a document is read successfully\n   */\n  function onLoadSuccess() {\n    if (!pdf) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    if (onLoadSuccessProps) {\n      onLoadSuccessProps(pdf);\n    }\n    pages.current = new Array(pdf.numPages);\n    linkService.current.setDocument(pdf);\n  }\n  /**\n   * Called when a document failed to read successfully\n   */\n  function onLoadError() {\n    if (!pdfError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, pdfError.toString());\n    if (onLoadErrorProps) {\n      onLoadErrorProps(pdfError);\n    }\n  }\n  function resetDocument() {\n    pdfDispatch({\n      type: 'RESET'\n    });\n  }\n  useEffect(resetDocument, [pdfDispatch, source]);\n  function loadDocument() {\n    if (!source) {\n      return;\n    }\n    const documentInitParams = options ? Object.assign(Object.assign({}, source), options) : source;\n    const destroyable = pdfjs.getDocument(documentInitParams);\n    if (onLoadProgress) {\n      destroyable.onProgress = onLoadProgress;\n    }\n    if (onPassword) {\n      destroyable.onPassword = onPassword;\n    }\n    const loadingTask = destroyable;\n    loadingTask.promise.then(nextPdf => {\n      pdfDispatch({\n        type: 'RESOLVE',\n        value: nextPdf\n      });\n    }).catch(error => {\n      pdfDispatch({\n        type: 'REJECT',\n        error\n      });\n    });\n    return () => {\n      loadingTask.destroy();\n    };\n  }\n  useEffect(loadDocument,\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [options, pdfDispatch, source]);\n  useEffect(() => {\n    if (typeof pdf === 'undefined') {\n      return;\n    }\n    if (pdf === false) {\n      onLoadError();\n      return;\n    }\n    onLoadSuccess();\n  },\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [pdf]);\n  function setupLinkService() {\n    linkService.current.setViewer(viewer.current);\n    linkService.current.setExternalLinkRel(externalLinkRel);\n    linkService.current.setExternalLinkTarget(externalLinkTarget);\n  }\n  useEffect(setupLinkService, [externalLinkRel, externalLinkTarget]);\n  function registerPage(pageIndex, ref) {\n    pages.current[pageIndex] = ref;\n  }\n  function unregisterPage(pageIndex) {\n    delete pages.current[pageIndex];\n  }\n  const childContext = {\n    imageResourcesPath,\n    linkService: linkService.current,\n    pdf,\n    registerPage,\n    renderMode,\n    rotate,\n    unregisterPage\n  };\n  const eventProps = useMemo(() => makeEventProps(otherProps, () => pdf), [otherProps, pdf]);\n  function renderChildren() {\n    return React.createElement(DocumentContext.Provider, {\n      value: childContext\n    }, children);\n  }\n  function renderContent() {\n    if (!file) {\n      return React.createElement(Message, {\n        type: \"no-data\"\n      }, typeof noData === 'function' ? noData() : noData);\n    }\n    if (pdf === undefined || pdf === null) {\n      return React.createElement(Message, {\n        type: \"loading\"\n      }, typeof loading === 'function' ? loading() : loading);\n    }\n    if (pdf === false) {\n      return React.createElement(Message, {\n        type: \"error\"\n      }, typeof error === 'function' ? error() : error);\n    }\n    return renderChildren();\n  }\n  return React.createElement(\"div\", Object.assign({\n    className: clsx('react-pdf__Document', className),\n    ref: inputRef,\n    style: {\n      ['--scale-factor']: '1'\n    }\n  }, eventProps), renderContent());\n});\nconst isFunctionOrNode = PropTypes.oneOfType([PropTypes.func, PropTypes.node]);\nDocument.propTypes = Object.assign(Object.assign({}, eventProps), {\n  children: PropTypes.node,\n  className: isClassName,\n  error: isFunctionOrNode,\n  externalLinkRel: PropTypes.string,\n  externalLinkTarget: PropTypes.oneOf(['_self', '_blank', '_parent', '_top']),\n  file: isFile,\n  imageResourcesPath: PropTypes.string,\n  inputRef: isRef,\n  loading: isFunctionOrNode,\n  noData: isFunctionOrNode,\n  onItemClick: PropTypes.func,\n  onLoadError: PropTypes.func,\n  onLoadProgress: PropTypes.func,\n  onLoadSuccess: PropTypes.func,\n  onPassword: PropTypes.func,\n  onSourceError: PropTypes.func,\n  onSourceSuccess: PropTypes.func,\n  options: PropTypes.shape({\n    cMapUrl: PropTypes.string,\n    cMapPacked: PropTypes.bool,\n    httpHeaders: PropTypes.object,\n    standardFontDataUrl: PropTypes.string,\n    withCredentials: PropTypes.bool\n  }),\n  rotate: PropTypes.number\n});\nexport default Document;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}