{"ast":null,"code":"import React, { useCallback, useContext, useEffect, useMemo, useRef } from 'react';\nimport mergeRefs from 'merge-refs';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport * as pdfjs from 'pdfjs-dist';\nimport PageContext from '../PageContext';\nimport { cancelRunningTask, getDevicePixelRatio, isCancelException, makePageCallback } from '../shared/utils';\nimport { isRef } from '../shared/propTypes';\nvar ANNOTATION_MODE = pdfjs.AnnotationMode;\nexport default function PageCanvas(props) {\n  var context = useContext(PageContext);\n  invariant(context, 'Unable to find Page context.');\n  var mergedProps = Object.assign(Object.assign({}, context), props);\n  var canvasBackground = mergedProps.canvasBackground,\n    devicePixelRatioProps = mergedProps.devicePixelRatio,\n    onRenderErrorProps = mergedProps.onRenderError,\n    onRenderSuccessProps = mergedProps.onRenderSuccess,\n    page = mergedProps.page,\n    renderForms = mergedProps.renderForms,\n    rotate = mergedProps.rotate,\n    scale = mergedProps.scale;\n  var canvasRef = props.canvasRef;\n  var canvasElement = useRef(null);\n  invariant(page, 'Attempted to render page canvas, but no page was specified.');\n  var devicePixelRatio = devicePixelRatioProps || getDevicePixelRatio();\n  /**\n   * Called when a page is rendered successfully.\n   */\n  function onRenderSuccess() {\n    if (!page) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    if (onRenderSuccessProps) {\n      onRenderSuccessProps(makePageCallback(page, scale));\n    }\n  }\n  /**\n   * Called when a page fails to render.\n   */\n  function onRenderError(error) {\n    if (isCancelException(error)) {\n      return;\n    }\n    warning(false, error.toString());\n    if (onRenderErrorProps) {\n      onRenderErrorProps(error);\n    }\n  }\n  var renderViewport = useMemo(function () {\n    return page.getViewport({\n      scale: scale * devicePixelRatio,\n      rotation: rotate\n    });\n  }, [devicePixelRatio, page, rotate, scale]);\n  var viewport = useMemo(function () {\n    return page.getViewport({\n      scale: scale,\n      rotation: rotate\n    });\n  }, [page, rotate, scale]);\n  function drawPageOnCanvas() {\n    if (!page) {\n      return;\n    }\n    // Ensures the canvas will be re-rendered from scratch. Otherwise all form data will stay.\n    page.cleanup();\n    var canvas = canvasElement.current;\n    if (!canvas) {\n      return;\n    }\n    canvas.width = renderViewport.width;\n    canvas.height = renderViewport.height;\n    canvas.style.width = \"\".concat(Math.floor(viewport.width), \"px\");\n    canvas.style.height = \"\".concat(Math.floor(viewport.height), \"px\");\n    canvas.style.visibility = 'hidden';\n    var renderContext = {\n      annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,\n      canvasContext: canvas.getContext('2d', {\n        alpha: false\n      }),\n      viewport: renderViewport\n    };\n    if (canvasBackground) {\n      renderContext.background = canvasBackground;\n    }\n    var cancellable = page.render(renderContext);\n    var runningTask = cancellable;\n    cancellable.promise.then(function () {\n      canvas.style.visibility = '';\n      onRenderSuccess();\n    }).catch(onRenderError);\n    return function () {\n      return cancelRunningTask(runningTask);\n    };\n  }\n  useEffect(drawPageOnCanvas,\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [canvasBackground, canvasElement, devicePixelRatio, page, renderForms, renderViewport, viewport]);\n  var cleanup = useCallback(function () {\n    var canvas = canvasElement.current;\n    /**\n     * Zeroing the width and height cause most browsers to release graphics\n     * resources immediately, which can greatly reduce memory consumption.\n     */\n    if (canvas) {\n      canvas.width = 0;\n      canvas.height = 0;\n    }\n  }, [canvasElement]);\n  useEffect(function () {\n    return cleanup;\n  }, [cleanup]);\n  return React.createElement(\"canvas\", {\n    className: \"react-pdf__Page__canvas\",\n    dir: \"ltr\",\n    ref: mergeRefs(canvasRef, canvasElement),\n    style: {\n      display: 'block',\n      userSelect: 'none'\n    }\n  });\n}\nPageCanvas.propTypes = {\n  canvasRef: isRef\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}