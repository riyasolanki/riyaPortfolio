{"ast":null,"code":"import _slicedToArray from \"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React, { useContext, useEffect, useMemo } from 'react';\nimport makeCancellable from 'make-cancellable-promise';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport * as pdfjs from 'pdfjs-dist';\nimport PageContext from '../PageContext';\nimport { useResolver } from '../shared/hooks';\nimport { cancelRunningTask, isCancelException, makePageCallback } from '../shared/utils';\nexport default function PageSVG() {\n  var context = useContext(PageContext);\n  invariant(context, 'Unable to find Page context.');\n  var onRenderSuccessProps = context.onRenderSuccess,\n    onRenderErrorProps = context.onRenderError,\n    page = context.page,\n    rotate = context.rotate,\n    scale = context.scale;\n  var _useResolver = useResolver(),\n    _useResolver2 = _slicedToArray(_useResolver, 2),\n    svgState = _useResolver2[0],\n    svgDispatch = _useResolver2[1];\n  var svg = svgState.value,\n    svgError = svgState.error;\n  invariant(page, 'Attempted to render page SVG, but no page was specified.');\n  /**\n   * Called when a page is rendered successfully\n   */\n  function onRenderSuccess() {\n    if (!page) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    if (onRenderSuccessProps) {\n      onRenderSuccessProps(makePageCallback(page, scale));\n    }\n  }\n  /**\n   * Called when a page fails to render\n   */\n  function onRenderError() {\n    if (!svgError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    if (isCancelException(svgError)) {\n      return;\n    }\n    warning(false, svgError.toString());\n    if (onRenderErrorProps) {\n      onRenderErrorProps(svgError);\n    }\n  }\n  var viewport = useMemo(function () {\n    return page.getViewport({\n      scale: scale,\n      rotation: rotate\n    });\n  }, [page, rotate, scale]);\n  function resetSVG() {\n    svgDispatch({\n      type: 'RESET'\n    });\n  }\n  useEffect(resetSVG, [page, svgDispatch, viewport]);\n  function renderSVG() {\n    if (!page) {\n      return;\n    }\n    var cancellable = makeCancellable(page.getOperatorList());\n    cancellable.promise.then(function (operatorList) {\n      var svgGfx = new pdfjs.SVGGraphics(page.commonObjs, page.objs);\n      svgGfx.getSVG(operatorList, viewport).then(function (nextSvg) {\n        svgDispatch({\n          type: 'RESOLVE',\n          value: nextSvg\n        });\n      }).catch(function (error) {\n        svgDispatch({\n          type: 'REJECT',\n          error: error\n        });\n      });\n    }).catch(function (error) {\n      svgDispatch({\n        type: 'REJECT',\n        error: error\n      });\n    });\n    return function () {\n      return cancelRunningTask(cancellable);\n    };\n  }\n  useEffect(renderSVG, [page, svgDispatch, viewport]);\n  useEffect(function () {\n    if (svg === undefined) {\n      return;\n    }\n    if (svg === false) {\n      onRenderError();\n      return;\n    }\n    onRenderSuccess();\n  },\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [svg]);\n  function drawPageOnContainer(element) {\n    if (!element || !svg) {\n      return;\n    }\n    // Append SVG element to the main container, if this hasn't been done already\n    if (!element.firstElementChild) {\n      element.appendChild(svg);\n    }\n    var width = viewport.width,\n      height = viewport.height;\n    svg.setAttribute('width', \"\".concat(width));\n    svg.setAttribute('height', \"\".concat(height));\n  }\n  var width = viewport.width,\n    height = viewport.height;\n  return React.createElement(\"div\", {\n    className: \"react-pdf__Page__svg\",\n    // Note: This cannot be shortened, as we need this function to be called with each render.\n    ref: function ref(_ref) {\n      return drawPageOnContainer(_ref);\n    },\n    style: {\n      display: 'block',\n      backgroundColor: 'white',\n      overflow: 'hidden',\n      width: width,\n      height: height,\n      userSelect: 'none'\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}