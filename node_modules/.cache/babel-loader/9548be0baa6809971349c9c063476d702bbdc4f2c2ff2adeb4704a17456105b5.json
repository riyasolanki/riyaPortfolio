{"ast":null,"code":"import _defineProperty from \"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n/**\n * Loads a PDF document. Passes it to all children.\n */\nimport React, { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport makeEventProps from 'make-event-props';\nimport makeCancellable from 'make-cancellable-promise';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport * as pdfjs from 'pdfjs-dist';\nimport DocumentContext from './DocumentContext';\nimport Message from './Message';\nimport LinkService from './LinkService';\nimport PasswordResponses from './PasswordResponses';\nimport { cancelRunningTask, dataURItoByteString, displayCORSWarning, isArrayBuffer, isBlob, isBrowser, isDataURI, loadFromFile } from './shared/utils';\nimport { useResolver } from './shared/hooks';\nimport { eventProps, isClassName, isFile, isRef } from './shared/propTypes';\nvar PDFDataRangeTransport = pdfjs.PDFDataRangeTransport;\nvar defaultOnPassword = function defaultOnPassword(callback, reason) {\n  switch (reason) {\n    case PasswordResponses.NEED_PASSWORD:\n      {\n        // eslint-disable-next-line no-alert\n        var password = prompt('Enter the password to open this PDF file.');\n        callback(password);\n        break;\n      }\n    case PasswordResponses.INCORRECT_PASSWORD:\n      {\n        // eslint-disable-next-line no-alert\n        var _password = prompt('Invalid password. Please try again.');\n        callback(_password);\n        break;\n      }\n    default:\n  }\n};\nvar Document = forwardRef(function Document(_a, ref) {\n  var _this = this;\n  var children = _a.children,\n    className = _a.className,\n    _a$error = _a.error,\n    error = _a$error === void 0 ? 'Failed to load PDF file.' : _a$error,\n    externalLinkRel = _a.externalLinkRel,\n    externalLinkTarget = _a.externalLinkTarget,\n    file = _a.file,\n    inputRef = _a.inputRef,\n    imageResourcesPath = _a.imageResourcesPath,\n    _a$loading = _a.loading,\n    loading = _a$loading === void 0 ? 'Loading PDFâ€¦' : _a$loading,\n    _a$noData = _a.noData,\n    noData = _a$noData === void 0 ? 'No PDF file specified.' : _a$noData,\n    onItemClick = _a.onItemClick,\n    onLoadErrorProps = _a.onLoadError,\n    onLoadProgress = _a.onLoadProgress,\n    onLoadSuccessProps = _a.onLoadSuccess,\n    _a$onPassword = _a.onPassword,\n    onPassword = _a$onPassword === void 0 ? defaultOnPassword : _a$onPassword,\n    onSourceErrorProps = _a.onSourceError,\n    onSourceSuccessProps = _a.onSourceSuccess,\n    options = _a.options,\n    renderMode = _a.renderMode,\n    rotate = _a.rotate,\n    otherProps = __rest(_a, [\"children\", \"className\", \"error\", \"externalLinkRel\", \"externalLinkTarget\", \"file\", \"inputRef\", \"imageResourcesPath\", \"loading\", \"noData\", \"onItemClick\", \"onLoadError\", \"onLoadProgress\", \"onLoadSuccess\", \"onPassword\", \"onSourceError\", \"onSourceSuccess\", \"options\", \"renderMode\", \"rotate\"]);\n  var _useResolver = useResolver(),\n    _useResolver2 = _slicedToArray(_useResolver, 2),\n    sourceState = _useResolver2[0],\n    sourceDispatch = _useResolver2[1];\n  var source = sourceState.value,\n    sourceError = sourceState.error;\n  var _useResolver3 = useResolver(),\n    _useResolver4 = _slicedToArray(_useResolver3, 2),\n    pdfState = _useResolver4[0],\n    pdfDispatch = _useResolver4[1];\n  var pdf = pdfState.value,\n    pdfError = pdfState.error;\n  var linkService = useRef(new LinkService());\n  var pages = useRef([]);\n  var viewer = useRef({\n    // Handling jumping to internal links target\n    scrollPageIntoView: function scrollPageIntoView(_ref) {\n      var dest = _ref.dest,\n        pageIndex = _ref.pageIndex,\n        pageNumber = _ref.pageNumber;\n      // First, check if custom handling of onItemClick was provided\n      if (onItemClick) {\n        onItemClick({\n          dest: dest,\n          pageIndex: pageIndex,\n          pageNumber: pageNumber\n        });\n        return;\n      }\n      // If not, try to look for target page within the <Document>.\n      var page = pages.current[pageIndex];\n      if (page) {\n        // Scroll to the page automatically\n        page.scrollIntoView();\n        return;\n      }\n      warning(false, \"An internal link leading to page \".concat(pageNumber, \" was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.\"));\n    }\n  });\n  useImperativeHandle(ref, function () {\n    return {\n      linkService: linkService,\n      pages: pages,\n      viewer: viewer\n    };\n  }, []);\n  /**\n   * Called when a document source is resolved correctly\n   */\n  function onSourceSuccess() {\n    if (onSourceSuccessProps) {\n      onSourceSuccessProps();\n    }\n  }\n  /**\n   * Called when a document source failed to be resolved correctly\n   */\n  function onSourceError() {\n    if (!sourceError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, sourceError.toString());\n    if (onSourceErrorProps) {\n      onSourceErrorProps(sourceError);\n    }\n  }\n  function resetSource() {\n    sourceDispatch({\n      type: 'RESET'\n    });\n  }\n  useEffect(resetSource, [file, sourceDispatch]);\n  var findDocumentSource = useCallback(function () {\n    return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var fileByteString, data, url, otherParams, _fileByteString;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (file) {\n              _context.next = 2;\n              break;\n            }\n            return _context.abrupt(\"return\", null);\n          case 2:\n            if (!(typeof file === 'string')) {\n              _context.next = 8;\n              break;\n            }\n            if (!isDataURI(file)) {\n              _context.next = 6;\n              break;\n            }\n            fileByteString = dataURItoByteString(file);\n            return _context.abrupt(\"return\", {\n              data: fileByteString\n            });\n          case 6:\n            displayCORSWarning();\n            return _context.abrupt(\"return\", {\n              url: file\n            });\n          case 8:\n            if (!(file instanceof PDFDataRangeTransport)) {\n              _context.next = 10;\n              break;\n            }\n            return _context.abrupt(\"return\", {\n              range: file\n            });\n          case 10:\n            if (!isArrayBuffer(file)) {\n              _context.next = 12;\n              break;\n            }\n            return _context.abrupt(\"return\", {\n              data: file\n            });\n          case 12:\n            if (!isBrowser) {\n              _context.next = 18;\n              break;\n            }\n            if (!isBlob(file)) {\n              _context.next = 18;\n              break;\n            }\n            _context.next = 16;\n            return loadFromFile(file);\n          case 16:\n            data = _context.sent;\n            return _context.abrupt(\"return\", {\n              data: data\n            });\n          case 18:\n            // At this point, file must be an object\n            invariant(typeof file === 'object', 'Invalid parameter in file, need either Uint8Array, string or a parameter object');\n            invariant('data' in file || 'range' in file || 'url' in file, 'Invalid parameter object: need either .data, .range or .url');\n            // File .url is a string\n            if (!('url' in file && typeof file.url === 'string')) {\n              _context.next = 26;\n              break;\n            }\n            if (!isDataURI(file.url)) {\n              _context.next = 25;\n              break;\n            }\n            url = file.url, otherParams = __rest(file, [\"url\"]);\n            _fileByteString = dataURItoByteString(url);\n            return _context.abrupt(\"return\", Object.assign({\n              data: _fileByteString\n            }, otherParams));\n          case 25:\n            displayCORSWarning();\n          case 26:\n            return _context.abrupt(\"return\", file);\n          case 27:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n  }, [file]);\n  useEffect(function () {\n    var cancellable = makeCancellable(findDocumentSource());\n    cancellable.promise.then(function (nextSource) {\n      sourceDispatch({\n        type: 'RESOLVE',\n        value: nextSource\n      });\n    }).catch(function (error) {\n      sourceDispatch({\n        type: 'REJECT',\n        error: error\n      });\n    });\n    return function () {\n      cancelRunningTask(cancellable);\n    };\n  }, [findDocumentSource, sourceDispatch]);\n  useEffect(function () {\n    if (typeof source === 'undefined') {\n      return;\n    }\n    if (source === false) {\n      onSourceError();\n      return;\n    }\n    onSourceSuccess();\n  },\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [source]);\n  /**\n   * Called when a document is read successfully\n   */\n  function onLoadSuccess() {\n    if (!pdf) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    if (onLoadSuccessProps) {\n      onLoadSuccessProps(pdf);\n    }\n    pages.current = new Array(pdf.numPages);\n    linkService.current.setDocument(pdf);\n  }\n  /**\n   * Called when a document failed to read successfully\n   */\n  function onLoadError() {\n    if (!pdfError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, pdfError.toString());\n    if (onLoadErrorProps) {\n      onLoadErrorProps(pdfError);\n    }\n  }\n  function resetDocument() {\n    pdfDispatch({\n      type: 'RESET'\n    });\n  }\n  useEffect(resetDocument, [pdfDispatch, source]);\n  function loadDocument() {\n    if (!source) {\n      return;\n    }\n    var documentInitParams = options ? Object.assign(Object.assign({}, source), options) : source;\n    var destroyable = pdfjs.getDocument(documentInitParams);\n    if (onLoadProgress) {\n      destroyable.onProgress = onLoadProgress;\n    }\n    if (onPassword) {\n      destroyable.onPassword = onPassword;\n    }\n    var loadingTask = destroyable;\n    loadingTask.promise.then(function (nextPdf) {\n      pdfDispatch({\n        type: 'RESOLVE',\n        value: nextPdf\n      });\n    }).catch(function (error) {\n      pdfDispatch({\n        type: 'REJECT',\n        error: error\n      });\n    });\n    return function () {\n      loadingTask.destroy();\n    };\n  }\n  useEffect(loadDocument,\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [options, pdfDispatch, source]);\n  useEffect(function () {\n    if (typeof pdf === 'undefined') {\n      return;\n    }\n    if (pdf === false) {\n      onLoadError();\n      return;\n    }\n    onLoadSuccess();\n  },\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [pdf]);\n  function setupLinkService() {\n    linkService.current.setViewer(viewer.current);\n    linkService.current.setExternalLinkRel(externalLinkRel);\n    linkService.current.setExternalLinkTarget(externalLinkTarget);\n  }\n  useEffect(setupLinkService, [externalLinkRel, externalLinkTarget]);\n  function registerPage(pageIndex, ref) {\n    pages.current[pageIndex] = ref;\n  }\n  function unregisterPage(pageIndex) {\n    delete pages.current[pageIndex];\n  }\n  var childContext = {\n    imageResourcesPath: imageResourcesPath,\n    linkService: linkService.current,\n    pdf: pdf,\n    registerPage: registerPage,\n    renderMode: renderMode,\n    rotate: rotate,\n    unregisterPage: unregisterPage\n  };\n  var eventProps = useMemo(function () {\n    return makeEventProps(otherProps, function () {\n      return pdf;\n    });\n  }, [otherProps, pdf]);\n  function renderChildren() {\n    return React.createElement(DocumentContext.Provider, {\n      value: childContext\n    }, children);\n  }\n  function renderContent() {\n    if (!file) {\n      return React.createElement(Message, {\n        type: \"no-data\"\n      }, typeof noData === 'function' ? noData() : noData);\n    }\n    if (pdf === undefined || pdf === null) {\n      return React.createElement(Message, {\n        type: \"loading\"\n      }, typeof loading === 'function' ? loading() : loading);\n    }\n    if (pdf === false) {\n      return React.createElement(Message, {\n        type: \"error\"\n      }, typeof error === 'function' ? error() : error);\n    }\n    return renderChildren();\n  }\n  return React.createElement(\"div\", Object.assign({\n    className: clsx('react-pdf__Document', className),\n    ref: inputRef,\n    style: _defineProperty({}, '--scale-factor', '1')\n  }, eventProps), renderContent());\n});\nvar isFunctionOrNode = PropTypes.oneOfType([PropTypes.func, PropTypes.node]);\nDocument.propTypes = Object.assign(Object.assign({}, eventProps), {\n  children: PropTypes.node,\n  className: isClassName,\n  error: isFunctionOrNode,\n  externalLinkRel: PropTypes.string,\n  externalLinkTarget: PropTypes.oneOf(['_self', '_blank', '_parent', '_top']),\n  file: isFile,\n  imageResourcesPath: PropTypes.string,\n  inputRef: isRef,\n  loading: isFunctionOrNode,\n  noData: isFunctionOrNode,\n  onItemClick: PropTypes.func,\n  onLoadError: PropTypes.func,\n  onLoadProgress: PropTypes.func,\n  onLoadSuccess: PropTypes.func,\n  onPassword: PropTypes.func,\n  onSourceError: PropTypes.func,\n  onSourceSuccess: PropTypes.func,\n  options: PropTypes.shape({\n    cMapUrl: PropTypes.string,\n    cMapPacked: PropTypes.bool,\n    httpHeaders: PropTypes.object,\n    standardFontDataUrl: PropTypes.string,\n    withCredentials: PropTypes.bool\n  }),\n  rotate: PropTypes.number\n});\nexport default Document;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}