{"ast":null,"code":"import _defineProperty from \"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React, { useContext, useEffect, useMemo, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport clsx from 'clsx';\nimport mergeRefs from 'merge-refs';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport DocumentContext from './DocumentContext';\nimport PageContext from './PageContext';\nimport Message from './Message';\nimport PageCanvas from './Page/PageCanvas';\nimport PageSVG from './Page/PageSVG';\nimport TextLayer from './Page/TextLayer';\nimport AnnotationLayer from './Page/AnnotationLayer';\nimport { cancelRunningTask, isProvided, makePageCallback } from './shared/utils';\nimport { useResolver } from './shared/hooks';\nimport { eventProps, isClassName, isPageIndex, isPageNumber, isPdf, isRef, isRenderMode, isRotate } from './shared/propTypes';\nvar defaultScale = 1;\nexport default function Page(props) {\n  var _style;\n  var context = useContext(DocumentContext);\n  invariant(context, 'Unable to find Document context. Did you wrap <Page /> in <Document />?');\n  var mergedProps = Object.assign(Object.assign({}, context), props);\n  var canvasBackground = mergedProps.canvasBackground,\n    canvasRef = mergedProps.canvasRef,\n    children = mergedProps.children,\n    className = mergedProps.className,\n    customTextRenderer = mergedProps.customTextRenderer,\n    devicePixelRatio = mergedProps.devicePixelRatio,\n    _mergedProps$error = mergedProps.error,\n    error = _mergedProps$error === void 0 ? 'Failed to load the page.' : _mergedProps$error,\n    height = mergedProps.height,\n    inputRef = mergedProps.inputRef,\n    _mergedProps$loading = mergedProps.loading,\n    loading = _mergedProps$loading === void 0 ? 'Loading pageâ€¦' : _mergedProps$loading,\n    _mergedProps$noData = mergedProps.noData,\n    noData = _mergedProps$noData === void 0 ? 'No page specified.' : _mergedProps$noData,\n    onGetAnnotationsErrorProps = mergedProps.onGetAnnotationsError,\n    onGetAnnotationsSuccessProps = mergedProps.onGetAnnotationsSuccess,\n    onGetTextErrorProps = mergedProps.onGetTextError,\n    onGetTextSuccessProps = mergedProps.onGetTextSuccess,\n    onLoadErrorProps = mergedProps.onLoadError,\n    onLoadSuccessProps = mergedProps.onLoadSuccess,\n    onRenderAnnotationLayerErrorProps = mergedProps.onRenderAnnotationLayerError,\n    onRenderAnnotationLayerSuccessProps = mergedProps.onRenderAnnotationLayerSuccess,\n    onRenderErrorProps = mergedProps.onRenderError,\n    onRenderSuccessProps = mergedProps.onRenderSuccess,\n    onRenderTextLayerErrorProps = mergedProps.onRenderTextLayerError,\n    onRenderTextLayerSuccessProps = mergedProps.onRenderTextLayerSuccess,\n    pageIndexProps = mergedProps.pageIndex,\n    pageNumberProps = mergedProps.pageNumber,\n    pdf = mergedProps.pdf,\n    registerPage = mergedProps.registerPage,\n    _mergedProps$renderAn = mergedProps.renderAnnotationLayer,\n    renderAnnotationLayerProps = _mergedProps$renderAn === void 0 ? true : _mergedProps$renderAn,\n    _mergedProps$renderFo = mergedProps.renderForms,\n    renderForms = _mergedProps$renderFo === void 0 ? false : _mergedProps$renderFo,\n    _mergedProps$renderMo = mergedProps.renderMode,\n    renderMode = _mergedProps$renderMo === void 0 ? 'canvas' : _mergedProps$renderMo,\n    _mergedProps$renderTe = mergedProps.renderTextLayer,\n    renderTextLayerProps = _mergedProps$renderTe === void 0 ? true : _mergedProps$renderTe,\n    rotateProps = mergedProps.rotate,\n    _mergedProps$scale = mergedProps.scale,\n    scaleProps = _mergedProps$scale === void 0 ? defaultScale : _mergedProps$scale,\n    unregisterPage = mergedProps.unregisterPage,\n    width = mergedProps.width,\n    otherProps = __rest(mergedProps, [\"canvasBackground\", \"canvasRef\", \"children\", \"className\", \"customTextRenderer\", \"devicePixelRatio\", \"error\", \"height\", \"inputRef\", \"loading\", \"noData\", \"onGetAnnotationsError\", \"onGetAnnotationsSuccess\", \"onGetTextError\", \"onGetTextSuccess\", \"onLoadError\", \"onLoadSuccess\", \"onRenderAnnotationLayerError\", \"onRenderAnnotationLayerSuccess\", \"onRenderError\", \"onRenderSuccess\", \"onRenderTextLayerError\", \"onRenderTextLayerSuccess\", \"pageIndex\", \"pageNumber\", \"pdf\", \"registerPage\", \"renderAnnotationLayer\", \"renderForms\", \"renderMode\", \"renderTextLayer\", \"rotate\", \"scale\", \"unregisterPage\", \"width\"]);\n  var _useResolver = useResolver(),\n    _useResolver2 = _slicedToArray(_useResolver, 2),\n    pageState = _useResolver2[0],\n    pageDispatch = _useResolver2[1];\n  var page = pageState.value,\n    pageError = pageState.error;\n  var pageElement = useRef(null);\n  invariant(pdf, 'Attempted to load a page, but no document was specified.');\n  var pageIndex = isProvided(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;\n  var pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : isProvided(pageIndexProps) ? pageIndexProps + 1 : null;\n  var rotate = rotateProps !== null && rotateProps !== void 0 ? rotateProps : page ? page.rotate : null;\n  var scale = useMemo(function () {\n    if (!page) {\n      return null;\n    }\n    // Be default, we'll render page at 100% * scale width.\n    var pageScale = 1;\n    // Passing scale explicitly null would cause the page not to render\n    var scaleWithDefault = scaleProps !== null && scaleProps !== void 0 ? scaleProps : defaultScale;\n    // If width/height is defined, calculate the scale of the page so it could be of desired width.\n    if (width || height) {\n      var viewport = page.getViewport({\n        scale: 1,\n        rotation: rotate\n      });\n      if (width) {\n        pageScale = width / viewport.width;\n      } else if (height) {\n        pageScale = height / viewport.height;\n      }\n    }\n    return scaleWithDefault * pageScale;\n  }, [height, page, rotate, scaleProps, width]);\n  function hook() {\n    return function () {\n      if (pageIndex === null) {\n        // Impossible, but TypeScript doesn't know that\n        return;\n      }\n      if (unregisterPage) {\n        unregisterPage(pageIndex);\n      }\n    };\n  }\n  useEffect(hook, [pdf, pageIndex, unregisterPage]);\n  /**\n   * Called when a page is loaded successfully\n   */\n  function onLoadSuccess() {\n    if (onLoadSuccessProps) {\n      if (!page || !scale) {\n        // Impossible, but TypeScript doesn't know that\n        return;\n      }\n      onLoadSuccessProps(makePageCallback(page, scale));\n    }\n    if (registerPage) {\n      if (pageIndex === null || !pageElement.current) {\n        // Impossible, but TypeScript doesn't know that\n        return;\n      }\n      registerPage(pageIndex, pageElement.current);\n    }\n  }\n  /**\n   * Called when a page failed to load\n   */\n  function onLoadError() {\n    if (!pageError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, pageError.toString());\n    if (onLoadErrorProps) {\n      onLoadErrorProps(pageError);\n    }\n  }\n  function resetPage() {\n    pageDispatch({\n      type: 'RESET'\n    });\n  }\n  useEffect(resetPage, [pageDispatch, pdf, pageIndex]);\n  function loadPage() {\n    if (!pdf || !pageNumber) {\n      return;\n    }\n    var cancellable = makeCancellable(pdf.getPage(pageNumber));\n    var runningTask = cancellable;\n    cancellable.promise.then(function (nextPage) {\n      pageDispatch({\n        type: 'RESOLVE',\n        value: nextPage\n      });\n    }).catch(function (error) {\n      pageDispatch({\n        type: 'REJECT',\n        error: error\n      });\n    });\n    return function () {\n      return cancelRunningTask(runningTask);\n    };\n  }\n  useEffect(loadPage, [pageDispatch, pdf, pageIndex, pageNumber, registerPage]);\n  useEffect(function () {\n    if (page === undefined) {\n      return;\n    }\n    if (page === false) {\n      onLoadError();\n      return;\n    }\n    onLoadSuccess();\n  },\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [page, scale]);\n  var childContext =\n  // Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that\n  page && isProvided(pageIndex) && isProvided(pageNumber) && isProvided(rotate) && isProvided(scale) ? {\n    canvasBackground: canvasBackground,\n    customTextRenderer: customTextRenderer,\n    devicePixelRatio: devicePixelRatio,\n    onGetAnnotationsError: onGetAnnotationsErrorProps,\n    onGetAnnotationsSuccess: onGetAnnotationsSuccessProps,\n    onGetTextError: onGetTextErrorProps,\n    onGetTextSuccess: onGetTextSuccessProps,\n    onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps,\n    onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps,\n    onRenderError: onRenderErrorProps,\n    onRenderSuccess: onRenderSuccessProps,\n    onRenderTextLayerError: onRenderTextLayerErrorProps,\n    onRenderTextLayerSuccess: onRenderTextLayerSuccessProps,\n    page: page,\n    pageIndex: pageIndex,\n    pageNumber: pageNumber,\n    renderForms: renderForms,\n    rotate: rotate,\n    scale: scale\n  } : null;\n  var eventProps = useMemo(function () {\n    return makeEventProps(otherProps, function () {\n      return page ? scale ? makePageCallback(page, scale) : undefined : page;\n    });\n  }, [otherProps, page, scale]);\n  var pageKey = \"\".concat(pageIndex, \"@\").concat(scale, \"/\").concat(rotate);\n  var pageKeyNoScale = \"\".concat(pageIndex, \"/\").concat(rotate);\n  function renderMainLayer() {\n    switch (renderMode) {\n      case 'none':\n        return null;\n      case 'svg':\n        return React.createElement(PageSVG, {\n          key: \"\".concat(pageKeyNoScale, \"_svg\")\n        });\n      case 'canvas':\n      default:\n        return React.createElement(PageCanvas, {\n          key: \"\".concat(pageKey, \"_canvas\"),\n          canvasRef: canvasRef\n        });\n    }\n  }\n  function renderTextLayer() {\n    if (!renderTextLayerProps) {\n      return null;\n    }\n    return React.createElement(TextLayer, {\n      key: \"\".concat(pageKey, \"_text\")\n    });\n  }\n  function renderAnnotationLayer() {\n    if (!renderAnnotationLayerProps) {\n      return null;\n    }\n    /**\n     * As of now, PDF.js 2.0.943 returns warnings on unimplemented annotations in SVG mode.\n     * Therefore, as a fallback, we render \"traditional\" AnnotationLayer component.\n     */\n    return React.createElement(AnnotationLayer, {\n      key: \"\".concat(pageKey, \"_annotations\")\n    });\n  }\n  function renderChildren() {\n    return React.createElement(PageContext.Provider, {\n      value: childContext\n    }, renderMainLayer(), renderTextLayer(), renderAnnotationLayer(), children);\n  }\n  function renderContent() {\n    if (!pageNumber) {\n      return React.createElement(Message, {\n        type: \"no-data\"\n      }, typeof noData === 'function' ? noData() : noData);\n    }\n    if (pdf === null || page === undefined || page === null) {\n      return React.createElement(Message, {\n        type: \"loading\"\n      }, typeof loading === 'function' ? loading() : loading);\n    }\n    if (pdf === false || page === false) {\n      return React.createElement(Message, {\n        type: \"error\"\n      }, typeof error === 'function' ? error() : error);\n    }\n    return renderChildren();\n  }\n  return React.createElement(\"div\", Object.assign({\n    className: clsx('react-pdf__Page', className),\n    \"data-page-number\": pageNumber,\n    ref: mergeRefs(inputRef, pageElement),\n    style: (_style = {}, _defineProperty(_style, '--scale-factor', \"\".concat(scale)), _defineProperty(_style, \"backgroundColor\", canvasBackground || 'white'), _defineProperty(_style, \"position\", 'relative'), _defineProperty(_style, \"minWidth\", 'min-content'), _defineProperty(_style, \"minHeight\", 'min-content'), _style)\n  }, eventProps), renderContent());\n}\nvar isFunctionOrNode = PropTypes.oneOfType([PropTypes.func, PropTypes.node]);\nPage.propTypes = Object.assign(Object.assign({}, eventProps), {\n  canvasBackground: PropTypes.string,\n  canvasRef: isRef,\n  children: PropTypes.node,\n  className: isClassName,\n  customTextRenderer: PropTypes.func,\n  devicePixelRatio: PropTypes.number,\n  error: isFunctionOrNode,\n  height: PropTypes.number,\n  imageResourcesPath: PropTypes.string,\n  inputRef: isRef,\n  loading: isFunctionOrNode,\n  noData: isFunctionOrNode,\n  onGetTextError: PropTypes.func,\n  onGetTextSuccess: PropTypes.func,\n  onLoadError: PropTypes.func,\n  onLoadSuccess: PropTypes.func,\n  onRenderError: PropTypes.func,\n  onRenderSuccess: PropTypes.func,\n  onRenderTextLayerError: PropTypes.func,\n  onRenderTextLayerSuccess: PropTypes.func,\n  pageIndex: isPageIndex,\n  pageNumber: isPageNumber,\n  pdf: isPdf,\n  renderAnnotationLayer: PropTypes.bool,\n  renderForms: PropTypes.bool,\n  renderMode: isRenderMode,\n  renderTextLayer: PropTypes.bool,\n  rotate: isRotate,\n  scale: PropTypes.number,\n  width: PropTypes.number\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}