{"ast":null,"code":"import _slicedToArray from \"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React, { useContext, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport DocumentContext from './DocumentContext';\nimport OutlineContext from './OutlineContext';\nimport OutlineItem from './OutlineItem';\nimport { cancelRunningTask } from './shared/utils';\nimport { useResolver } from './shared/hooks';\nimport { eventProps, isClassName, isPdf, isRef } from './shared/propTypes';\nexport default function Outline(props) {\n  var context = useContext(DocumentContext);\n  invariant(context, 'Unable to find Document context. Did you wrap <Outline /> in <Document />?');\n  var mergedProps = Object.assign(Object.assign({}, context), props);\n  var className = mergedProps.className,\n    inputRef = mergedProps.inputRef,\n    onItemClickProps = mergedProps.onItemClick,\n    onLoadErrorProps = mergedProps.onLoadError,\n    onLoadSuccessProps = mergedProps.onLoadSuccess,\n    pdf = mergedProps.pdf,\n    otherProps = __rest(mergedProps, [\"className\", \"inputRef\", \"onItemClick\", \"onLoadError\", \"onLoadSuccess\", \"pdf\"]);\n  invariant(pdf, 'Attempted to load an outline, but no document was specified.');\n  var _useResolver = useResolver(),\n    _useResolver2 = _slicedToArray(_useResolver, 2),\n    outlineState = _useResolver2[0],\n    outlineDispatch = _useResolver2[1];\n  var outline = outlineState.value,\n    outlineError = outlineState.error;\n  /**\n   * Called when an outline is read successfully\n   */\n  function onLoadSuccess() {\n    if (typeof outline === 'undefined' || outline === false) {\n      return;\n    }\n    if (onLoadSuccessProps) {\n      onLoadSuccessProps(outline);\n    }\n  }\n  /**\n   * Called when an outline failed to read successfully\n   */\n  function onLoadError() {\n    if (!outlineError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, outlineError.toString());\n    if (onLoadErrorProps) {\n      onLoadErrorProps(outlineError);\n    }\n  }\n  function onItemClick(_ref) {\n    var dest = _ref.dest,\n      pageIndex = _ref.pageIndex,\n      pageNumber = _ref.pageNumber;\n    if (onItemClickProps) {\n      onItemClickProps({\n        dest: dest,\n        pageIndex: pageIndex,\n        pageNumber: pageNumber\n      });\n    }\n  }\n  function resetOutline() {\n    outlineDispatch({\n      type: 'RESET'\n    });\n  }\n  useEffect(resetOutline, [outlineDispatch, pdf]);\n  function loadOutline() {\n    if (!pdf) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    var cancellable = makeCancellable(pdf.getOutline());\n    var runningTask = cancellable;\n    cancellable.promise.then(function (nextOutline) {\n      outlineDispatch({\n        type: 'RESOLVE',\n        value: nextOutline\n      });\n    }).catch(function (error) {\n      outlineDispatch({\n        type: 'REJECT',\n        error: error\n      });\n    });\n    return function () {\n      return cancelRunningTask(runningTask);\n    };\n  }\n  useEffect(loadOutline, [outlineDispatch, pdf]);\n  useEffect(function () {\n    if (outline === undefined) {\n      return;\n    }\n    if (outline === false) {\n      onLoadError();\n      return;\n    }\n    onLoadSuccess();\n  },\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [outline]);\n  var childContext = {\n    onClick: onItemClick\n  };\n  var eventProps = useMemo(function () {\n    return makeEventProps(otherProps, function () {\n      return outline;\n    });\n  }, [otherProps, outline]);\n  if (!outline) {\n    return null;\n  }\n  function renderOutline() {\n    if (!outline) {\n      return null;\n    }\n    return React.createElement(\"ul\", null, outline.map(function (item, itemIndex) {\n      return React.createElement(OutlineItem, {\n        key: typeof item.dest === 'string' ? item.dest : itemIndex,\n        item: item\n      });\n    }));\n  }\n  return React.createElement(\"div\", Object.assign({\n    className: clsx('react-pdf__Outline', className),\n    ref: inputRef\n  }, eventProps), React.createElement(OutlineContext.Provider, {\n    value: childContext\n  }, renderOutline()));\n}\nOutline.propTypes = Object.assign(Object.assign({}, eventProps), {\n  className: isClassName,\n  inputRef: isRef,\n  onItemClick: PropTypes.func,\n  onLoadError: PropTypes.func,\n  onLoadSuccess: PropTypes.func,\n  pdf: isPdf\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}