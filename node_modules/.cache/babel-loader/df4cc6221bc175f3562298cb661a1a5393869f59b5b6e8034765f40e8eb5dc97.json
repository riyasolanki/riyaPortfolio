{"ast":null,"code":"var _classStaticPrivateMethodGet = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/classStaticPrivateMethodGet.js\").default;\nvar _objectSpread = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _get = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _defineProperty = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _assertThisInitialized = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _classPrivateMethodInitSpec = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _regeneratorRuntime = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classStaticPrivateFieldSpecSet = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/classStaticPrivateFieldSpecSet.js\").default;\nvar _classStaticPrivateFieldSpecGet = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/classStaticPrivateFieldSpecGet.js\").default;\nvar _asyncToGenerator = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classPrivateFieldInitSpec = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldGet = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _toConsumableArray = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _slicedToArray = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _createClass = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"D:/Riya/Website/riyaPortfolio/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"pdfjs-dist/build/pdf\", [], factory);else if (typeof exports === 'object') exports[\"pdfjs-dist/build/pdf\"] = factory();else root[\"pdfjs-dist/build/pdf\"] = root.pdfjsLib = factory();\n})(globalThis, function () {\n  return (/******/function () {\n      // webpackBootstrap\n      /******/\n      \"use strict\";\n\n      /******/\n      var __webpack_modules__ = [\n        /* 0 */\n      , /* 1 */\n      /***/function (__unused_webpack_module, exports) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.RenderingIntentFlag = exports.PromiseCapability = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.MAX_IMAGE_SIZE_TO_CACHE = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.BASELINE_FACTOR = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\n        exports.assert = assert;\n        exports.bytesToString = bytesToString;\n        exports.createValidAbsoluteUrl = createValidAbsoluteUrl;\n        exports.getModificationDate = getModificationDate;\n        exports.getVerbosityLevel = getVerbosityLevel;\n        exports.info = info;\n        exports.isArrayBuffer = isArrayBuffer;\n        exports.isArrayEqual = isArrayEqual;\n        exports.normalizeUnicode = normalizeUnicode;\n        exports.objectFromMap = objectFromMap;\n        exports.objectSize = objectSize;\n        exports.setVerbosityLevel = setVerbosityLevel;\n        exports.shadow = shadow;\n        exports.string32 = string32;\n        exports.stringToBytes = stringToBytes;\n        exports.stringToPDFString = stringToPDFString;\n        exports.stringToUTF8String = stringToUTF8String;\n        exports.unreachable = unreachable;\n        exports.utf8StringToString = utf8StringToString;\n        exports.warn = warn;\n        ;\n        var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\n        exports.IDENTITY_MATRIX = IDENTITY_MATRIX;\n        var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\n        exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\n        var MAX_IMAGE_SIZE_TO_CACHE = 10e6;\n        exports.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;\n        var LINE_FACTOR = 1.35;\n        exports.LINE_FACTOR = LINE_FACTOR;\n        var LINE_DESCENT_FACTOR = 0.35;\n        exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;\n        var BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\n        exports.BASELINE_FACTOR = BASELINE_FACTOR;\n        var RenderingIntentFlag = {\n          ANY: 0x01,\n          DISPLAY: 0x02,\n          PRINT: 0x04,\n          SAVE: 0x08,\n          ANNOTATIONS_FORMS: 0x10,\n          ANNOTATIONS_STORAGE: 0x20,\n          ANNOTATIONS_DISABLE: 0x40,\n          OPLIST: 0x100\n        };\n        exports.RenderingIntentFlag = RenderingIntentFlag;\n        var AnnotationMode = {\n          DISABLE: 0,\n          ENABLE: 1,\n          ENABLE_FORMS: 2,\n          ENABLE_STORAGE: 3\n        };\n        exports.AnnotationMode = AnnotationMode;\n        var AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\n        exports.AnnotationEditorPrefix = AnnotationEditorPrefix;\n        var AnnotationEditorType = {\n          DISABLE: -1,\n          NONE: 0,\n          FREETEXT: 3,\n          INK: 15\n        };\n        exports.AnnotationEditorType = AnnotationEditorType;\n        var AnnotationEditorParamsType = {\n          FREETEXT_SIZE: 1,\n          FREETEXT_COLOR: 2,\n          FREETEXT_OPACITY: 3,\n          INK_COLOR: 11,\n          INK_THICKNESS: 12,\n          INK_OPACITY: 13\n        };\n        exports.AnnotationEditorParamsType = AnnotationEditorParamsType;\n        var PermissionFlag = {\n          PRINT: 0x04,\n          MODIFY_CONTENTS: 0x08,\n          COPY: 0x10,\n          MODIFY_ANNOTATIONS: 0x20,\n          FILL_INTERACTIVE_FORMS: 0x100,\n          COPY_FOR_ACCESSIBILITY: 0x200,\n          ASSEMBLE: 0x400,\n          PRINT_HIGH_QUALITY: 0x800\n        };\n        exports.PermissionFlag = PermissionFlag;\n        var TextRenderingMode = {\n          FILL: 0,\n          STROKE: 1,\n          FILL_STROKE: 2,\n          INVISIBLE: 3,\n          FILL_ADD_TO_PATH: 4,\n          STROKE_ADD_TO_PATH: 5,\n          FILL_STROKE_ADD_TO_PATH: 6,\n          ADD_TO_PATH: 7,\n          FILL_STROKE_MASK: 3,\n          ADD_TO_PATH_FLAG: 4\n        };\n        exports.TextRenderingMode = TextRenderingMode;\n        var ImageKind = {\n          GRAYSCALE_1BPP: 1,\n          RGB_24BPP: 2,\n          RGBA_32BPP: 3\n        };\n        exports.ImageKind = ImageKind;\n        var AnnotationType = {\n          TEXT: 1,\n          LINK: 2,\n          FREETEXT: 3,\n          LINE: 4,\n          SQUARE: 5,\n          CIRCLE: 6,\n          POLYGON: 7,\n          POLYLINE: 8,\n          HIGHLIGHT: 9,\n          UNDERLINE: 10,\n          SQUIGGLY: 11,\n          STRIKEOUT: 12,\n          STAMP: 13,\n          CARET: 14,\n          INK: 15,\n          POPUP: 16,\n          FILEATTACHMENT: 17,\n          SOUND: 18,\n          MOVIE: 19,\n          WIDGET: 20,\n          SCREEN: 21,\n          PRINTERMARK: 22,\n          TRAPNET: 23,\n          WATERMARK: 24,\n          THREED: 25,\n          REDACT: 26\n        };\n        exports.AnnotationType = AnnotationType;\n        var AnnotationStateModelType = {\n          MARKED: \"Marked\",\n          REVIEW: \"Review\"\n        };\n        exports.AnnotationStateModelType = AnnotationStateModelType;\n        var AnnotationMarkedState = {\n          MARKED: \"Marked\",\n          UNMARKED: \"Unmarked\"\n        };\n        exports.AnnotationMarkedState = AnnotationMarkedState;\n        var AnnotationReviewState = {\n          ACCEPTED: \"Accepted\",\n          REJECTED: \"Rejected\",\n          CANCELLED: \"Cancelled\",\n          COMPLETED: \"Completed\",\n          NONE: \"None\"\n        };\n        exports.AnnotationReviewState = AnnotationReviewState;\n        var AnnotationReplyType = {\n          GROUP: \"Group\",\n          REPLY: \"R\"\n        };\n        exports.AnnotationReplyType = AnnotationReplyType;\n        var AnnotationFlag = {\n          INVISIBLE: 0x01,\n          HIDDEN: 0x02,\n          PRINT: 0x04,\n          NOZOOM: 0x08,\n          NOROTATE: 0x10,\n          NOVIEW: 0x20,\n          READONLY: 0x40,\n          LOCKED: 0x80,\n          TOGGLENOVIEW: 0x100,\n          LOCKEDCONTENTS: 0x200\n        };\n        exports.AnnotationFlag = AnnotationFlag;\n        var AnnotationFieldFlag = {\n          READONLY: 0x0000001,\n          REQUIRED: 0x0000002,\n          NOEXPORT: 0x0000004,\n          MULTILINE: 0x0001000,\n          PASSWORD: 0x0002000,\n          NOTOGGLETOOFF: 0x0004000,\n          RADIO: 0x0008000,\n          PUSHBUTTON: 0x0010000,\n          COMBO: 0x0020000,\n          EDIT: 0x0040000,\n          SORT: 0x0080000,\n          FILESELECT: 0x0100000,\n          MULTISELECT: 0x0200000,\n          DONOTSPELLCHECK: 0x0400000,\n          DONOTSCROLL: 0x0800000,\n          COMB: 0x1000000,\n          RICHTEXT: 0x2000000,\n          RADIOSINUNISON: 0x2000000,\n          COMMITONSELCHANGE: 0x4000000\n        };\n        exports.AnnotationFieldFlag = AnnotationFieldFlag;\n        var AnnotationBorderStyleType = {\n          SOLID: 1,\n          DASHED: 2,\n          BEVELED: 3,\n          INSET: 4,\n          UNDERLINE: 5\n        };\n        exports.AnnotationBorderStyleType = AnnotationBorderStyleType;\n        var AnnotationActionEventType = {\n          E: \"Mouse Enter\",\n          X: \"Mouse Exit\",\n          D: \"Mouse Down\",\n          U: \"Mouse Up\",\n          Fo: \"Focus\",\n          Bl: \"Blur\",\n          PO: \"PageOpen\",\n          PC: \"PageClose\",\n          PV: \"PageVisible\",\n          PI: \"PageInvisible\",\n          K: \"Keystroke\",\n          F: \"Format\",\n          V: \"Validate\",\n          C: \"Calculate\"\n        };\n        exports.AnnotationActionEventType = AnnotationActionEventType;\n        var DocumentActionEventType = {\n          WC: \"WillClose\",\n          WS: \"WillSave\",\n          DS: \"DidSave\",\n          WP: \"WillPrint\",\n          DP: \"DidPrint\"\n        };\n        exports.DocumentActionEventType = DocumentActionEventType;\n        var PageActionEventType = {\n          O: \"PageOpen\",\n          C: \"PageClose\"\n        };\n        exports.PageActionEventType = PageActionEventType;\n        var VerbosityLevel = {\n          ERRORS: 0,\n          WARNINGS: 1,\n          INFOS: 5\n        };\n        exports.VerbosityLevel = VerbosityLevel;\n        var CMapCompressionType = {\n          NONE: 0,\n          BINARY: 1\n        };\n        exports.CMapCompressionType = CMapCompressionType;\n        var OPS = {\n          dependency: 1,\n          setLineWidth: 2,\n          setLineCap: 3,\n          setLineJoin: 4,\n          setMiterLimit: 5,\n          setDash: 6,\n          setRenderingIntent: 7,\n          setFlatness: 8,\n          setGState: 9,\n          save: 10,\n          restore: 11,\n          transform: 12,\n          moveTo: 13,\n          lineTo: 14,\n          curveTo: 15,\n          curveTo2: 16,\n          curveTo3: 17,\n          closePath: 18,\n          rectangle: 19,\n          stroke: 20,\n          closeStroke: 21,\n          fill: 22,\n          eoFill: 23,\n          fillStroke: 24,\n          eoFillStroke: 25,\n          closeFillStroke: 26,\n          closeEOFillStroke: 27,\n          endPath: 28,\n          clip: 29,\n          eoClip: 30,\n          beginText: 31,\n          endText: 32,\n          setCharSpacing: 33,\n          setWordSpacing: 34,\n          setHScale: 35,\n          setLeading: 36,\n          setFont: 37,\n          setTextRenderingMode: 38,\n          setTextRise: 39,\n          moveText: 40,\n          setLeadingMoveText: 41,\n          setTextMatrix: 42,\n          nextLine: 43,\n          showText: 44,\n          showSpacedText: 45,\n          nextLineShowText: 46,\n          nextLineSetSpacingShowText: 47,\n          setCharWidth: 48,\n          setCharWidthAndBounds: 49,\n          setStrokeColorSpace: 50,\n          setFillColorSpace: 51,\n          setStrokeColor: 52,\n          setStrokeColorN: 53,\n          setFillColor: 54,\n          setFillColorN: 55,\n          setStrokeGray: 56,\n          setFillGray: 57,\n          setStrokeRGBColor: 58,\n          setFillRGBColor: 59,\n          setStrokeCMYKColor: 60,\n          setFillCMYKColor: 61,\n          shadingFill: 62,\n          beginInlineImage: 63,\n          beginImageData: 64,\n          endInlineImage: 65,\n          paintXObject: 66,\n          markPoint: 67,\n          markPointProps: 68,\n          beginMarkedContent: 69,\n          beginMarkedContentProps: 70,\n          endMarkedContent: 71,\n          beginCompat: 72,\n          endCompat: 73,\n          paintFormXObjectBegin: 74,\n          paintFormXObjectEnd: 75,\n          beginGroup: 76,\n          endGroup: 77,\n          beginAnnotation: 80,\n          endAnnotation: 81,\n          paintImageMaskXObject: 83,\n          paintImageMaskXObjectGroup: 84,\n          paintImageXObject: 85,\n          paintInlineImageXObject: 86,\n          paintInlineImageXObjectGroup: 87,\n          paintImageXObjectRepeat: 88,\n          paintImageMaskXObjectRepeat: 89,\n          paintSolidColorImageMask: 90,\n          constructPath: 91\n        };\n        exports.OPS = OPS;\n        var PasswordResponses = {\n          NEED_PASSWORD: 1,\n          INCORRECT_PASSWORD: 2\n        };\n        exports.PasswordResponses = PasswordResponses;\n        var verbosity = VerbosityLevel.WARNINGS;\n        function setVerbosityLevel(level) {\n          if (Number.isInteger(level)) {\n            verbosity = level;\n          }\n        }\n        function getVerbosityLevel() {\n          return verbosity;\n        }\n        function info(msg) {\n          if (verbosity >= VerbosityLevel.INFOS) {\n            console.log(\"Info: \".concat(msg));\n          }\n        }\n        function warn(msg) {\n          if (verbosity >= VerbosityLevel.WARNINGS) {\n            console.log(\"Warning: \".concat(msg));\n          }\n        }\n        function unreachable(msg) {\n          throw new Error(msg);\n        }\n        function assert(cond, msg) {\n          if (!cond) {\n            unreachable(msg);\n          }\n        }\n        function _isValidProtocol(url) {\n          switch (url === null || url === void 0 ? void 0 : url.protocol) {\n            case \"http:\":\n            case \"https:\":\n            case \"ftp:\":\n            case \"mailto:\":\n            case \"tel:\":\n              return true;\n            default:\n              return false;\n          }\n        }\n        function createValidAbsoluteUrl(url) {\n          var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n          if (!url) {\n            return null;\n          }\n          try {\n            if (options && typeof url === \"string\") {\n              if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n                var dots = url.match(/\\./g);\n                if ((dots === null || dots === void 0 ? void 0 : dots.length) >= 2) {\n                  url = \"http://\".concat(url);\n                }\n              }\n              if (options.tryConvertEncoding) {\n                try {\n                  url = stringToUTF8String(url);\n                } catch (ex) {}\n              }\n            }\n            var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n            if (_isValidProtocol(absoluteUrl)) {\n              return absoluteUrl;\n            }\n          } catch (ex) {}\n          return null;\n        }\n        function shadow(obj, prop, value) {\n          var nonSerializable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n          Object.defineProperty(obj, prop, {\n            value: value,\n            enumerable: !nonSerializable,\n            configurable: true,\n            writable: false\n          });\n          return value;\n        }\n        var BaseException = function BaseExceptionClosure() {\n          function BaseException(message, name) {\n            if (this.constructor === BaseException) {\n              unreachable(\"Cannot initialize BaseException.\");\n            }\n            this.message = message;\n            this.name = name;\n          }\n          BaseException.prototype = new Error();\n          BaseException.constructor = BaseException;\n          return BaseException;\n        }();\n        exports.BaseException = BaseException;\n        var PasswordException = /*#__PURE__*/function (_BaseException) {\n          _inherits(PasswordException, _BaseException);\n          var _super = _createSuper(PasswordException);\n          function PasswordException(msg, code) {\n            var _this;\n            _classCallCheck(this, PasswordException);\n            _this = _super.call(this, msg, \"PasswordException\");\n            _this.code = code;\n            return _this;\n          }\n          return _createClass(PasswordException);\n        }(BaseException);\n        exports.PasswordException = PasswordException;\n        var UnknownErrorException = /*#__PURE__*/function (_BaseException2) {\n          _inherits(UnknownErrorException, _BaseException2);\n          var _super2 = _createSuper(UnknownErrorException);\n          function UnknownErrorException(msg, details) {\n            var _this2;\n            _classCallCheck(this, UnknownErrorException);\n            _this2 = _super2.call(this, msg, \"UnknownErrorException\");\n            _this2.details = details;\n            return _this2;\n          }\n          return _createClass(UnknownErrorException);\n        }(BaseException);\n        exports.UnknownErrorException = UnknownErrorException;\n        var InvalidPDFException = /*#__PURE__*/function (_BaseException3) {\n          _inherits(InvalidPDFException, _BaseException3);\n          var _super3 = _createSuper(InvalidPDFException);\n          function InvalidPDFException(msg) {\n            _classCallCheck(this, InvalidPDFException);\n            return _super3.call(this, msg, \"InvalidPDFException\");\n          }\n          return _createClass(InvalidPDFException);\n        }(BaseException);\n        exports.InvalidPDFException = InvalidPDFException;\n        var MissingPDFException = /*#__PURE__*/function (_BaseException4) {\n          _inherits(MissingPDFException, _BaseException4);\n          var _super4 = _createSuper(MissingPDFException);\n          function MissingPDFException(msg) {\n            _classCallCheck(this, MissingPDFException);\n            return _super4.call(this, msg, \"MissingPDFException\");\n          }\n          return _createClass(MissingPDFException);\n        }(BaseException);\n        exports.MissingPDFException = MissingPDFException;\n        var UnexpectedResponseException = /*#__PURE__*/function (_BaseException5) {\n          _inherits(UnexpectedResponseException, _BaseException5);\n          var _super5 = _createSuper(UnexpectedResponseException);\n          function UnexpectedResponseException(msg, status) {\n            var _this3;\n            _classCallCheck(this, UnexpectedResponseException);\n            _this3 = _super5.call(this, msg, \"UnexpectedResponseException\");\n            _this3.status = status;\n            return _this3;\n          }\n          return _createClass(UnexpectedResponseException);\n        }(BaseException);\n        exports.UnexpectedResponseException = UnexpectedResponseException;\n        var FormatError = /*#__PURE__*/function (_BaseException6) {\n          _inherits(FormatError, _BaseException6);\n          var _super6 = _createSuper(FormatError);\n          function FormatError(msg) {\n            _classCallCheck(this, FormatError);\n            return _super6.call(this, msg, \"FormatError\");\n          }\n          return _createClass(FormatError);\n        }(BaseException);\n        exports.FormatError = FormatError;\n        var AbortException = /*#__PURE__*/function (_BaseException7) {\n          _inherits(AbortException, _BaseException7);\n          var _super7 = _createSuper(AbortException);\n          function AbortException(msg) {\n            _classCallCheck(this, AbortException);\n            return _super7.call(this, msg, \"AbortException\");\n          }\n          return _createClass(AbortException);\n        }(BaseException);\n        exports.AbortException = AbortException;\n        function bytesToString(bytes) {\n          if (typeof bytes !== \"object\" || (bytes === null || bytes === void 0 ? void 0 : bytes.length) === undefined) {\n            unreachable(\"Invalid argument for bytesToString\");\n          }\n          var length = bytes.length;\n          var MAX_ARGUMENT_COUNT = 8192;\n          if (length < MAX_ARGUMENT_COUNT) {\n            return String.fromCharCode.apply(null, bytes);\n          }\n          var strBuf = [];\n          for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n            var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n            var chunk = bytes.subarray(i, chunkEnd);\n            strBuf.push(String.fromCharCode.apply(null, chunk));\n          }\n          return strBuf.join(\"\");\n        }\n        function stringToBytes(str) {\n          if (typeof str !== \"string\") {\n            unreachable(\"Invalid argument for stringToBytes\");\n          }\n          var length = str.length;\n          var bytes = new Uint8Array(length);\n          for (var i = 0; i < length; ++i) {\n            bytes[i] = str.charCodeAt(i) & 0xff;\n          }\n          return bytes;\n        }\n        function string32(value) {\n          return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n        }\n        function objectSize(obj) {\n          return Object.keys(obj).length;\n        }\n        function objectFromMap(map) {\n          var obj = Object.create(null);\n          var _iterator = _createForOfIteratorHelper(map),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                key = _step$value[0],\n                value = _step$value[1];\n              obj[key] = value;\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          return obj;\n        }\n        function isLittleEndian() {\n          var buffer8 = new Uint8Array(4);\n          buffer8[0] = 1;\n          var view32 = new Uint32Array(buffer8.buffer, 0, 1);\n          return view32[0] === 1;\n        }\n        function isEvalSupported() {\n          try {\n            new Function(\"\");\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }\n        var FeatureTest = /*#__PURE__*/function () {\n          function FeatureTest() {\n            _classCallCheck(this, FeatureTest);\n          }\n          _createClass(FeatureTest, null, [{\n            key: \"isLittleEndian\",\n            get: function get() {\n              return shadow(this, \"isLittleEndian\", isLittleEndian());\n            }\n          }, {\n            key: \"isEvalSupported\",\n            get: function get() {\n              return shadow(this, \"isEvalSupported\", isEvalSupported());\n            }\n          }, {\n            key: \"isOffscreenCanvasSupported\",\n            get: function get() {\n              return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n            }\n          }, {\n            key: \"platform\",\n            get: function get() {\n              if (typeof navigator === \"undefined\") {\n                return shadow(this, \"platform\", {\n                  isWin: false,\n                  isMac: false\n                });\n              }\n              return shadow(this, \"platform\", {\n                isWin: navigator.platform.includes(\"Win\"),\n                isMac: navigator.platform.includes(\"Mac\")\n              });\n            }\n          }]);\n          return FeatureTest;\n        }();\n        exports.FeatureTest = FeatureTest;\n        var hexNumbers = _toConsumableArray(Array(256).keys()).map(function (n) {\n          return n.toString(16).padStart(2, \"0\");\n        });\n        var Util = /*#__PURE__*/function () {\n          function Util() {\n            _classCallCheck(this, Util);\n          }\n          _createClass(Util, null, [{\n            key: \"makeHexColor\",\n            value: function makeHexColor(r, g, b) {\n              return \"#\".concat(hexNumbers[r]).concat(hexNumbers[g]).concat(hexNumbers[b]);\n            }\n          }, {\n            key: \"scaleMinMax\",\n            value: function scaleMinMax(transform, minMax) {\n              var temp;\n              if (transform[0]) {\n                if (transform[0] < 0) {\n                  temp = minMax[0];\n                  minMax[0] = minMax[1];\n                  minMax[1] = temp;\n                }\n                minMax[0] *= transform[0];\n                minMax[1] *= transform[0];\n                if (transform[3] < 0) {\n                  temp = minMax[2];\n                  minMax[2] = minMax[3];\n                  minMax[3] = temp;\n                }\n                minMax[2] *= transform[3];\n                minMax[3] *= transform[3];\n              } else {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n                if (transform[1] < 0) {\n                  temp = minMax[2];\n                  minMax[2] = minMax[3];\n                  minMax[3] = temp;\n                }\n                minMax[2] *= transform[1];\n                minMax[3] *= transform[1];\n                if (transform[2] < 0) {\n                  temp = minMax[0];\n                  minMax[0] = minMax[1];\n                  minMax[1] = temp;\n                }\n                minMax[0] *= transform[2];\n                minMax[1] *= transform[2];\n              }\n              minMax[0] += transform[4];\n              minMax[1] += transform[4];\n              minMax[2] += transform[5];\n              minMax[3] += transform[5];\n            }\n          }, {\n            key: \"transform\",\n            value: function transform(m1, m2) {\n              return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n            }\n          }, {\n            key: \"applyTransform\",\n            value: function applyTransform(p, m) {\n              var xt = p[0] * m[0] + p[1] * m[2] + m[4];\n              var yt = p[0] * m[1] + p[1] * m[3] + m[5];\n              return [xt, yt];\n            }\n          }, {\n            key: \"applyInverseTransform\",\n            value: function applyInverseTransform(p, m) {\n              var d = m[0] * m[3] - m[1] * m[2];\n              var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n              var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n              return [xt, yt];\n            }\n          }, {\n            key: \"getAxialAlignedBoundingBox\",\n            value: function getAxialAlignedBoundingBox(r, m) {\n              var p1 = Util.applyTransform(r, m);\n              var p2 = Util.applyTransform(r.slice(2, 4), m);\n              var p3 = Util.applyTransform([r[0], r[3]], m);\n              var p4 = Util.applyTransform([r[2], r[1]], m);\n              return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n            }\n          }, {\n            key: \"inverseTransform\",\n            value: function inverseTransform(m) {\n              var d = m[0] * m[3] - m[1] * m[2];\n              return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n            }\n          }, {\n            key: \"singularValueDecompose2dScale\",\n            value: function singularValueDecompose2dScale(m) {\n              var transpose = [m[0], m[2], m[1], m[3]];\n              var a = m[0] * transpose[0] + m[1] * transpose[2];\n              var b = m[0] * transpose[1] + m[1] * transpose[3];\n              var c = m[2] * transpose[0] + m[3] * transpose[2];\n              var d = m[2] * transpose[1] + m[3] * transpose[3];\n              var first = (a + d) / 2;\n              var second = Math.sqrt(Math.pow(a + d, 2) - 4 * (a * d - c * b)) / 2;\n              var sx = first + second || 1;\n              var sy = first - second || 1;\n              return [Math.sqrt(sx), Math.sqrt(sy)];\n            }\n          }, {\n            key: \"normalizeRect\",\n            value: function normalizeRect(rect) {\n              var r = rect.slice(0);\n              if (rect[0] > rect[2]) {\n                r[0] = rect[2];\n                r[2] = rect[0];\n              }\n              if (rect[1] > rect[3]) {\n                r[1] = rect[3];\n                r[3] = rect[1];\n              }\n              return r;\n            }\n          }, {\n            key: \"intersect\",\n            value: function intersect(rect1, rect2) {\n              var xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n              var xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n              if (xLow > xHigh) {\n                return null;\n              }\n              var yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n              var yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n              if (yLow > yHigh) {\n                return null;\n              }\n              return [xLow, yLow, xHigh, yHigh];\n            }\n          }, {\n            key: \"bezierBoundingBox\",\n            value: function bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n              var tvalues = [],\n                bounds = [[], []];\n              var a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n              for (var i = 0; i < 2; ++i) {\n                if (i === 0) {\n                  b = 6 * x0 - 12 * x1 + 6 * x2;\n                  a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                  c = 3 * x1 - 3 * x0;\n                } else {\n                  b = 6 * y0 - 12 * y1 + 6 * y2;\n                  a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                  c = 3 * y1 - 3 * y0;\n                }\n                if (Math.abs(a) < 1e-12) {\n                  if (Math.abs(b) < 1e-12) {\n                    continue;\n                  }\n                  t = -c / b;\n                  if (0 < t && t < 1) {\n                    tvalues.push(t);\n                  }\n                  continue;\n                }\n                b2ac = b * b - 4 * c * a;\n                sqrtb2ac = Math.sqrt(b2ac);\n                if (b2ac < 0) {\n                  continue;\n                }\n                t1 = (-b + sqrtb2ac) / (2 * a);\n                if (0 < t1 && t1 < 1) {\n                  tvalues.push(t1);\n                }\n                t2 = (-b - sqrtb2ac) / (2 * a);\n                if (0 < t2 && t2 < 1) {\n                  tvalues.push(t2);\n                }\n              }\n              var j = tvalues.length,\n                mt;\n              var jlen = j;\n              while (j--) {\n                t = tvalues[j];\n                mt = 1 - t;\n                bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n                bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n              }\n              bounds[0][jlen] = x0;\n              bounds[1][jlen] = y0;\n              bounds[0][jlen + 1] = x3;\n              bounds[1][jlen + 1] = y3;\n              bounds[0].length = bounds[1].length = jlen + 2;\n              return [Math.min.apply(Math, _toConsumableArray(bounds[0])), Math.min.apply(Math, _toConsumableArray(bounds[1])), Math.max.apply(Math, _toConsumableArray(bounds[0])), Math.max.apply(Math, _toConsumableArray(bounds[1]))];\n            }\n          }]);\n          return Util;\n        }();\n        exports.Util = Util;\n        var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];\n        function stringToPDFString(str) {\n          if (str[0] >= \"\\xEF\") {\n            var encoding;\n            if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n              encoding = \"utf-16be\";\n            } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n              encoding = \"utf-16le\";\n            } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n              encoding = \"utf-8\";\n            }\n            if (encoding) {\n              try {\n                var decoder = new TextDecoder(encoding, {\n                  fatal: true\n                });\n                var buffer = stringToBytes(str);\n                return decoder.decode(buffer);\n              } catch (ex) {\n                warn(\"stringToPDFString: \\\"\".concat(ex, \"\\\".\"));\n              }\n            }\n          }\n          var strBuf = [];\n          for (var i = 0, ii = str.length; i < ii; i++) {\n            var code = PDFStringTranslateTable[str.charCodeAt(i)];\n            strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n          }\n          return strBuf.join(\"\");\n        }\n        function stringToUTF8String(str) {\n          return decodeURIComponent(escape(str));\n        }\n        function utf8StringToString(str) {\n          return unescape(encodeURIComponent(str));\n        }\n        function isArrayBuffer(v) {\n          return typeof v === \"object\" && (v === null || v === void 0 ? void 0 : v.byteLength) !== undefined;\n        }\n        function isArrayEqual(arr1, arr2) {\n          if (arr1.length !== arr2.length) {\n            return false;\n          }\n          for (var i = 0, ii = arr1.length; i < ii; i++) {\n            if (arr1[i] !== arr2[i]) {\n              return false;\n            }\n          }\n          return true;\n        }\n        function getModificationDate() {\n          var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n          var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n          return buffer.join(\"\");\n        }\n        var _settled = /*#__PURE__*/new WeakMap();\n        var PromiseCapability = /*#__PURE__*/function () {\n          function PromiseCapability() {\n            var _this4 = this;\n            _classCallCheck(this, PromiseCapability);\n            _classPrivateFieldInitSpec(this, _settled, {\n              writable: true,\n              value: false\n            });\n            this.promise = new Promise(function (resolve, reject) {\n              _this4.resolve = function (data) {\n                _classPrivateFieldSet(_this4, _settled, true);\n                resolve(data);\n              };\n              _this4.reject = function (reason) {\n                _classPrivateFieldSet(_this4, _settled, true);\n                reject(reason);\n              };\n            });\n          }\n          _createClass(PromiseCapability, [{\n            key: \"settled\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _settled);\n            }\n          }]);\n          return PromiseCapability;\n        }();\n        exports.PromiseCapability = PromiseCapability;\n        var NormalizeRegex = null;\n        var NormalizationMap = null;\n        function normalizeUnicode(str) {\n          if (!NormalizeRegex) {\n            NormalizeRegex = /([\\xA0\\xB5\\u037E\\u0EB3\\u2000-\\u200A\\u202F\\u2126\\uFB00-\\uFB04\\uFB06\\uFB20-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBA1\\uFBA4-\\uFBA9\\uFBAE-\\uFBB1\\uFBD3-\\uFBDC\\uFBDE-\\uFBE7\\uFBEA-\\uFBF8\\uFBFC\\uFBFD\\uFC00-\\uFC5D\\uFC64-\\uFCF1\\uFCF5-\\uFD3D\\uFD88\\uFDF4\\uFDFA\\uFDFB\\uFE71\\uFE77\\uFE79\\uFE7B\\uFE7D]+)|(\\uFB05+)/g;\n            NormalizationMap = new Map([[\"ﬅ\", \"ſt\"]]);\n          }\n          return str.replaceAll(NormalizeRegex, function (_, p1, p2) {\n            return p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2);\n          });\n        }\n\n        /***/\n      }, /* 2 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\n        exports.getDocument = getDocument;\n        exports.version = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _annotation_storage = __w_pdfjs_require__(3);\n        var _display_utils = __w_pdfjs_require__(6);\n        var _font_loader = __w_pdfjs_require__(9);\n        var _canvas = __w_pdfjs_require__(11);\n        var _worker_options = __w_pdfjs_require__(14);\n        var _is_node = __w_pdfjs_require__(10);\n        var _message_handler = __w_pdfjs_require__(15);\n        var _metadata = __w_pdfjs_require__(16);\n        var _optional_content_config = __w_pdfjs_require__(17);\n        var _transport_stream = __w_pdfjs_require__(18);\n        var _xfa_text = __w_pdfjs_require__(19);\n        var DEFAULT_RANGE_CHUNK_SIZE = 65536;\n        var RENDERING_CANCELLED_TIMEOUT = 100;\n        var DELAYED_CLEANUP_TIMEOUT = 5000;\n        var DefaultCanvasFactory = _display_utils.DOMCanvasFactory;\n        exports.DefaultCanvasFactory = DefaultCanvasFactory;\n        var DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;\n        exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\n        var DefaultFilterFactory = _display_utils.DOMFilterFactory;\n        exports.DefaultFilterFactory = DefaultFilterFactory;\n        var DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;\n        exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\n        if (_is_node.isNodeJS) {\n          var _w_pdfjs_require__ = __w_pdfjs_require__(20),\n            NodeCanvasFactory = _w_pdfjs_require__.NodeCanvasFactory,\n            NodeCMapReaderFactory = _w_pdfjs_require__.NodeCMapReaderFactory,\n            NodeFilterFactory = _w_pdfjs_require__.NodeFilterFactory,\n            NodeStandardFontDataFactory = _w_pdfjs_require__.NodeStandardFontDataFactory;\n          exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;\n          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;\n          exports.DefaultFilterFactory = DefaultFilterFactory = NodeFilterFactory;\n          exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;\n        }\n        var createPDFNetworkStream;\n        {\n          if (_is_node.isNodeJS) {\n            var _w_pdfjs_require__2 = __w_pdfjs_require__(21),\n              PDFNodeStream = _w_pdfjs_require__2.PDFNodeStream;\n            createPDFNetworkStream = function createPDFNetworkStream(params) {\n              return new PDFNodeStream(params);\n            };\n          } else {\n            var _w_pdfjs_require__3 = __w_pdfjs_require__(24),\n              PDFNetworkStream = _w_pdfjs_require__3.PDFNetworkStream;\n            var _w_pdfjs_require__4 = __w_pdfjs_require__(25),\n              PDFFetchStream = _w_pdfjs_require__4.PDFFetchStream;\n            createPDFNetworkStream = function createPDFNetworkStream(params) {\n              return (0, _display_utils.isValidFetchUrl)(params.url) ? new PDFFetchStream(params) : new PDFNetworkStream(params);\n            };\n          }\n        }\n        function getDocument(src) {\n          var _src$password, _src$length;\n          if (typeof src === \"string\" || src instanceof URL) {\n            src = {\n              url: src\n            };\n          } else if ((0, _util.isArrayBuffer)(src)) {\n            src = {\n              data: src\n            };\n          }\n          if (typeof src !== \"object\") {\n            throw new Error(\"Invalid parameter in getDocument, need parameter object.\");\n          }\n          if (!src.url && !src.data && !src.range) {\n            throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n          }\n          var task = new PDFDocumentLoadingTask();\n          var docId = task.docId;\n          var url = src.url ? getUrlProp(src.url) : null;\n          var data = src.data ? getDataProp(src.data) : null;\n          var httpHeaders = src.httpHeaders || null;\n          var withCredentials = src.withCredentials === true;\n          var password = (_src$password = src.password) !== null && _src$password !== void 0 ? _src$password : null;\n          var rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n          var rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n          var worker = src.worker instanceof PDFWorker ? src.worker : null;\n          var verbosity = src.verbosity;\n          var docBaseUrl = typeof src.docBaseUrl === \"string\" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;\n          var cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n          var cMapPacked = src.cMapPacked !== false;\n          var CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n          var standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n          var StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n          var ignoreErrors = src.stopAtErrors !== true;\n          var maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n          var isEvalSupported = src.isEvalSupported !== false;\n          var isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !_is_node.isNodeJS;\n          var canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n          var disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : _is_node.isNodeJS;\n          var fontExtraProperties = src.fontExtraProperties === true;\n          var enableXfa = src.enableXfa === true;\n          var ownerDocument = src.ownerDocument || globalThis.document;\n          var disableRange = src.disableRange === true;\n          var disableStream = src.disableStream === true;\n          var disableAutoFetch = src.disableAutoFetch === true;\n          var pdfBug = src.pdfBug === true;\n          var length = rangeTransport ? rangeTransport.length : (_src$length = src.length) !== null && _src$length !== void 0 ? _src$length : NaN;\n          var useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !_is_node.isNodeJS && !disableFontFace;\n          var useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);\n          var canvasFactory = src.canvasFactory || new DefaultCanvasFactory({\n            ownerDocument: ownerDocument\n          });\n          var filterFactory = src.filterFactory || new DefaultFilterFactory({\n            docId: docId,\n            ownerDocument: ownerDocument\n          });\n          var styleElement = null;\n          (0, _util.setVerbosityLevel)(verbosity);\n          var transportFactory = {\n            canvasFactory: canvasFactory,\n            filterFactory: filterFactory\n          };\n          if (!useWorkerFetch) {\n            transportFactory.cMapReaderFactory = new CMapReaderFactory({\n              baseUrl: cMapUrl,\n              isCompressed: cMapPacked\n            });\n            transportFactory.standardFontDataFactory = new StandardFontDataFactory({\n              baseUrl: standardFontDataUrl\n            });\n          }\n          if (!worker) {\n            var workerParams = {\n              verbosity: verbosity,\n              port: _worker_options.GlobalWorkerOptions.workerPort\n            };\n            worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n            task._worker = worker;\n          }\n          var fetchDocParams = {\n            docId: docId,\n            apiVersion: '3.6.172',\n            data: data,\n            password: password,\n            disableAutoFetch: disableAutoFetch,\n            rangeChunkSize: rangeChunkSize,\n            length: length,\n            docBaseUrl: docBaseUrl,\n            enableXfa: enableXfa,\n            evaluatorOptions: {\n              maxImageSize: maxImageSize,\n              disableFontFace: disableFontFace,\n              ignoreErrors: ignoreErrors,\n              isEvalSupported: isEvalSupported,\n              isOffscreenCanvasSupported: isOffscreenCanvasSupported,\n              canvasMaxAreaInBytes: canvasMaxAreaInBytes,\n              fontExtraProperties: fontExtraProperties,\n              useSystemFonts: useSystemFonts,\n              cMapUrl: useWorkerFetch ? cMapUrl : null,\n              standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n            }\n          };\n          var transportParams = {\n            ignoreErrors: ignoreErrors,\n            isEvalSupported: isEvalSupported,\n            disableFontFace: disableFontFace,\n            fontExtraProperties: fontExtraProperties,\n            enableXfa: enableXfa,\n            ownerDocument: ownerDocument,\n            disableAutoFetch: disableAutoFetch,\n            pdfBug: pdfBug,\n            styleElement: styleElement\n          };\n          worker.promise.then(function () {\n            if (task.destroyed) {\n              throw new Error(\"Loading aborted\");\n            }\n            var workerIdPromise = _fetchDocument(worker, fetchDocParams);\n            var networkStreamPromise = new Promise(function (resolve) {\n              var networkStream;\n              if (rangeTransport) {\n                networkStream = new _transport_stream.PDFDataTransportStream({\n                  length: length,\n                  initialData: rangeTransport.initialData,\n                  progressiveDone: rangeTransport.progressiveDone,\n                  contentDispositionFilename: rangeTransport.contentDispositionFilename,\n                  disableRange: disableRange,\n                  disableStream: disableStream\n                }, rangeTransport);\n              } else if (!data) {\n                networkStream = createPDFNetworkStream({\n                  url: url,\n                  length: length,\n                  httpHeaders: httpHeaders,\n                  withCredentials: withCredentials,\n                  rangeChunkSize: rangeChunkSize,\n                  disableRange: disableRange,\n                  disableStream: disableStream\n                });\n              }\n              resolve(networkStream);\n            });\n            return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                workerId = _ref2[0],\n                networkStream = _ref2[1];\n              if (task.destroyed) {\n                throw new Error(\"Loading aborted\");\n              }\n              var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n              var transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n              task._transport = transport;\n              messageHandler.send(\"Ready\", null);\n            });\n          }).catch(task._capability.reject);\n          return task;\n        }\n        function _fetchDocument(_x, _x2) {\n          return _fetchDocument2.apply(this, arguments);\n        }\n        function _fetchDocument2() {\n          _fetchDocument2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(worker, source) {\n            var workerId;\n            return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n              while (1) switch (_context6.prev = _context6.next) {\n                case 0:\n                  if (!worker.destroyed) {\n                    _context6.next = 2;\n                    break;\n                  }\n                  throw new Error(\"Worker was destroyed\");\n                case 2:\n                  _context6.next = 4;\n                  return worker.messageHandler.sendWithPromise(\"GetDocRequest\", source, source.data ? [source.data.buffer] : null);\n                case 4:\n                  workerId = _context6.sent;\n                  if (!worker.destroyed) {\n                    _context6.next = 7;\n                    break;\n                  }\n                  throw new Error(\"Worker was destroyed\");\n                case 7:\n                  return _context6.abrupt(\"return\", workerId);\n                case 8:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }, _callee6);\n          }));\n          return _fetchDocument2.apply(this, arguments);\n        }\n        function getUrlProp(val) {\n          if (val instanceof URL) {\n            return val.href;\n          }\n          try {\n            return new URL(val, window.location).href;\n          } catch (ex) {\n            if (_is_node.isNodeJS && typeof val === \"string\") {\n              return val;\n            }\n          }\n          throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n        }\n        function getDataProp(val) {\n          if (_is_node.isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n            (0, _display_utils.deprecated)(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n            return new Uint8Array(val);\n          }\n          if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n            return val;\n          }\n          if (typeof val === \"string\") {\n            return (0, _util.stringToBytes)(val);\n          }\n          if (typeof val === \"object\" && !isNaN(val === null || val === void 0 ? void 0 : val.length) || (0, _util.isArrayBuffer)(val)) {\n            return new Uint8Array(val);\n          }\n          throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n        }\n        var PDFDocumentLoadingTask = /*#__PURE__*/function () {\n          function PDFDocumentLoadingTask() {\n            var _PDFDocumentLoadingTa, _PDFDocumentLoadingTa2;\n            _classCallCheck(this, PDFDocumentLoadingTask);\n            this._capability = new _util.PromiseCapability();\n            this._transport = null;\n            this._worker = null;\n            this.docId = \"d\".concat((_classStaticPrivateFieldSpecSet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId, (_PDFDocumentLoadingTa = _classStaticPrivateFieldSpecGet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId), _PDFDocumentLoadingTa2 = _PDFDocumentLoadingTa++, _PDFDocumentLoadingTa)), _PDFDocumentLoadingTa2));\n            this.destroyed = false;\n            this.onPassword = null;\n            this.onProgress = null;\n          }\n          _createClass(PDFDocumentLoadingTask, [{\n            key: \"promise\",\n            get: function get() {\n              return this._capability.promise;\n            }\n          }, {\n            key: \"destroy\",\n            value: function () {\n              var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _this$_transport;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      this.destroyed = true;\n                      _context.next = 3;\n                      return (_this$_transport = this._transport) === null || _this$_transport === void 0 ? void 0 : _this$_transport.destroy();\n                    case 3:\n                      this._transport = null;\n                      if (this._worker) {\n                        this._worker.destroy();\n                        this._worker = null;\n                      }\n                    case 5:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _callee, this);\n              }));\n              function destroy() {\n                return _destroy.apply(this, arguments);\n              }\n              return destroy;\n            }()\n          }]);\n          return PDFDocumentLoadingTask;\n        }();\n        var _docId = {\n          writable: true,\n          value: 0\n        };\n        exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\n        var PDFDataRangeTransport = /*#__PURE__*/function () {\n          function PDFDataRangeTransport(length, initialData) {\n            var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n            _classCallCheck(this, PDFDataRangeTransport);\n            this.length = length;\n            this.initialData = initialData;\n            this.progressiveDone = progressiveDone;\n            this.contentDispositionFilename = contentDispositionFilename;\n            this._rangeListeners = [];\n            this._progressListeners = [];\n            this._progressiveReadListeners = [];\n            this._progressiveDoneListeners = [];\n            this._readyCapability = new _util.PromiseCapability();\n          }\n          _createClass(PDFDataRangeTransport, [{\n            key: \"addRangeListener\",\n            value: function addRangeListener(listener) {\n              this._rangeListeners.push(listener);\n            }\n          }, {\n            key: \"addProgressListener\",\n            value: function addProgressListener(listener) {\n              this._progressListeners.push(listener);\n            }\n          }, {\n            key: \"addProgressiveReadListener\",\n            value: function addProgressiveReadListener(listener) {\n              this._progressiveReadListeners.push(listener);\n            }\n          }, {\n            key: \"addProgressiveDoneListener\",\n            value: function addProgressiveDoneListener(listener) {\n              this._progressiveDoneListeners.push(listener);\n            }\n          }, {\n            key: \"onDataRange\",\n            value: function onDataRange(begin, chunk) {\n              var _iterator2 = _createForOfIteratorHelper(this._rangeListeners),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var listener = _step2.value;\n                  listener(begin, chunk);\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n          }, {\n            key: \"onDataProgress\",\n            value: function onDataProgress(loaded, total) {\n              var _this5 = this;\n              this._readyCapability.promise.then(function () {\n                var _iterator3 = _createForOfIteratorHelper(_this5._progressListeners),\n                  _step3;\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    var listener = _step3.value;\n                    listener(loaded, total);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n              });\n            }\n          }, {\n            key: \"onDataProgressiveRead\",\n            value: function onDataProgressiveRead(chunk) {\n              var _this6 = this;\n              this._readyCapability.promise.then(function () {\n                var _iterator4 = _createForOfIteratorHelper(_this6._progressiveReadListeners),\n                  _step4;\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    var listener = _step4.value;\n                    listener(chunk);\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n              });\n            }\n          }, {\n            key: \"onDataProgressiveDone\",\n            value: function onDataProgressiveDone() {\n              var _this7 = this;\n              this._readyCapability.promise.then(function () {\n                var _iterator5 = _createForOfIteratorHelper(_this7._progressiveDoneListeners),\n                  _step5;\n                try {\n                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                    var listener = _step5.value;\n                    listener();\n                  }\n                } catch (err) {\n                  _iterator5.e(err);\n                } finally {\n                  _iterator5.f();\n                }\n              });\n            }\n          }, {\n            key: \"transportReady\",\n            value: function transportReady() {\n              this._readyCapability.resolve();\n            }\n          }, {\n            key: \"requestDataRange\",\n            value: function requestDataRange(begin, end) {\n              (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n            }\n          }, {\n            key: \"abort\",\n            value: function abort() {}\n          }]);\n          return PDFDataRangeTransport;\n        }();\n        exports.PDFDataRangeTransport = PDFDataRangeTransport;\n        var PDFDocumentProxy = /*#__PURE__*/function () {\n          function PDFDocumentProxy(pdfInfo, transport) {\n            _classCallCheck(this, PDFDocumentProxy);\n            this._pdfInfo = pdfInfo;\n            this._transport = transport;\n          }\n          _createClass(PDFDocumentProxy, [{\n            key: \"annotationStorage\",\n            get: function get() {\n              return this._transport.annotationStorage;\n            }\n          }, {\n            key: \"filterFactory\",\n            get: function get() {\n              return this._transport.filterFactory;\n            }\n          }, {\n            key: \"numPages\",\n            get: function get() {\n              return this._pdfInfo.numPages;\n            }\n          }, {\n            key: \"fingerprints\",\n            get: function get() {\n              return this._pdfInfo.fingerprints;\n            }\n          }, {\n            key: \"isPureXfa\",\n            get: function get() {\n              return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n            }\n          }, {\n            key: \"allXfaHtml\",\n            get: function get() {\n              return this._transport._htmlForXfa;\n            }\n          }, {\n            key: \"getPage\",\n            value: function getPage(pageNumber) {\n              return this._transport.getPage(pageNumber);\n            }\n          }, {\n            key: \"getPageIndex\",\n            value: function getPageIndex(ref) {\n              return this._transport.getPageIndex(ref);\n            }\n          }, {\n            key: \"getDestinations\",\n            value: function getDestinations() {\n              return this._transport.getDestinations();\n            }\n          }, {\n            key: \"getDestination\",\n            value: function getDestination(id) {\n              return this._transport.getDestination(id);\n            }\n          }, {\n            key: \"getPageLabels\",\n            value: function getPageLabels() {\n              return this._transport.getPageLabels();\n            }\n          }, {\n            key: \"getPageLayout\",\n            value: function getPageLayout() {\n              return this._transport.getPageLayout();\n            }\n          }, {\n            key: \"getPageMode\",\n            value: function getPageMode() {\n              return this._transport.getPageMode();\n            }\n          }, {\n            key: \"getViewerPreferences\",\n            value: function getViewerPreferences() {\n              return this._transport.getViewerPreferences();\n            }\n          }, {\n            key: \"getOpenAction\",\n            value: function getOpenAction() {\n              return this._transport.getOpenAction();\n            }\n          }, {\n            key: \"getAttachments\",\n            value: function getAttachments() {\n              return this._transport.getAttachments();\n            }\n          }, {\n            key: \"getJavaScript\",\n            value: function getJavaScript() {\n              return this._transport.getJavaScript();\n            }\n          }, {\n            key: \"getJSActions\",\n            value: function getJSActions() {\n              return this._transport.getDocJSActions();\n            }\n          }, {\n            key: \"getOutline\",\n            value: function getOutline() {\n              return this._transport.getOutline();\n            }\n          }, {\n            key: \"getOptionalContentConfig\",\n            value: function getOptionalContentConfig() {\n              return this._transport.getOptionalContentConfig();\n            }\n          }, {\n            key: \"getPermissions\",\n            value: function getPermissions() {\n              return this._transport.getPermissions();\n            }\n          }, {\n            key: \"getMetadata\",\n            value: function getMetadata() {\n              return this._transport.getMetadata();\n            }\n          }, {\n            key: \"getMarkInfo\",\n            value: function getMarkInfo() {\n              return this._transport.getMarkInfo();\n            }\n          }, {\n            key: \"getData\",\n            value: function getData() {\n              return this._transport.getData();\n            }\n          }, {\n            key: \"saveDocument\",\n            value: function saveDocument() {\n              return this._transport.saveDocument();\n            }\n          }, {\n            key: \"getDownloadInfo\",\n            value: function getDownloadInfo() {\n              return this._transport.downloadInfoCapability.promise;\n            }\n          }, {\n            key: \"cleanup\",\n            value: function cleanup() {\n              var keepLoadedFonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n              return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n            }\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              return this.loadingTask.destroy();\n            }\n          }, {\n            key: \"loadingParams\",\n            get: function get() {\n              return this._transport.loadingParams;\n            }\n          }, {\n            key: \"loadingTask\",\n            get: function get() {\n              return this._transport.loadingTask;\n            }\n          }, {\n            key: \"getFieldObjects\",\n            value: function getFieldObjects() {\n              return this._transport.getFieldObjects();\n            }\n          }, {\n            key: \"hasJSActions\",\n            value: function hasJSActions() {\n              return this._transport.hasJSActions();\n            }\n          }, {\n            key: \"getCalculationOrderIds\",\n            value: function getCalculationOrderIds() {\n              return this._transport.getCalculationOrderIds();\n            }\n          }]);\n          return PDFDocumentProxy;\n        }();\n        exports.PDFDocumentProxy = PDFDocumentProxy;\n        var _delayedCleanupTimeout = /*#__PURE__*/new WeakMap();\n        var _pendingCleanup = /*#__PURE__*/new WeakMap();\n        var _tryCleanup = /*#__PURE__*/new WeakSet();\n        var _abortDelayedCleanup = /*#__PURE__*/new WeakSet();\n        var PDFPageProxy = /*#__PURE__*/function () {\n          function PDFPageProxy(pageIndex, pageInfo, transport) {\n            var pdfBug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n            _classCallCheck(this, PDFPageProxy);\n            _classPrivateMethodInitSpec(this, _abortDelayedCleanup);\n            _classPrivateMethodInitSpec(this, _tryCleanup);\n            _classPrivateFieldInitSpec(this, _delayedCleanupTimeout, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldInitSpec(this, _pendingCleanup, {\n              writable: true,\n              value: false\n            });\n            this._pageIndex = pageIndex;\n            this._pageInfo = pageInfo;\n            this._transport = transport;\n            this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n            this._pdfBug = pdfBug;\n            this.commonObjs = transport.commonObjs;\n            this.objs = new PDFObjects();\n            this._maybeCleanupAfterRender = false;\n            this._intentStates = new Map();\n            this.destroyed = false;\n          }\n          _createClass(PDFPageProxy, [{\n            key: \"pageNumber\",\n            get: function get() {\n              return this._pageIndex + 1;\n            }\n          }, {\n            key: \"rotate\",\n            get: function get() {\n              return this._pageInfo.rotate;\n            }\n          }, {\n            key: \"ref\",\n            get: function get() {\n              return this._pageInfo.ref;\n            }\n          }, {\n            key: \"userUnit\",\n            get: function get() {\n              return this._pageInfo.userUnit;\n            }\n          }, {\n            key: \"view\",\n            get: function get() {\n              return this._pageInfo.view;\n            }\n          }, {\n            key: \"getViewport\",\n            value: function getViewport() {\n              var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                scale = _ref3.scale,\n                _ref3$rotation = _ref3.rotation,\n                rotation = _ref3$rotation === void 0 ? this.rotate : _ref3$rotation,\n                _ref3$offsetX = _ref3.offsetX,\n                offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX,\n                _ref3$offsetY = _ref3.offsetY,\n                offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY,\n                _ref3$dontFlip = _ref3.dontFlip,\n                dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;\n              return new _display_utils.PageViewport({\n                viewBox: this.view,\n                scale: scale,\n                rotation: rotation,\n                offsetX: offsetX,\n                offsetY: offsetY,\n                dontFlip: dontFlip\n              });\n            }\n          }, {\n            key: \"getAnnotations\",\n            value: function getAnnotations() {\n              var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref4$intent = _ref4.intent,\n                intent = _ref4$intent === void 0 ? \"display\" : _ref4$intent;\n              var intentArgs = this._transport.getRenderingIntent(intent);\n              return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n            }\n          }, {\n            key: \"getJSActions\",\n            value: function getJSActions() {\n              return this._transport.getPageJSActions(this._pageIndex);\n            }\n          }, {\n            key: \"isPureXfa\",\n            get: function get() {\n              return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n            }\n          }, {\n            key: \"getXfa\",\n            value: function () {\n              var _getXfa = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                var _this$_transport$_htm;\n                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) switch (_context2.prev = _context2.next) {\n                    case 0:\n                      return _context2.abrupt(\"return\", ((_this$_transport$_htm = this._transport._htmlForXfa) === null || _this$_transport$_htm === void 0 ? void 0 : _this$_transport$_htm.children[this._pageIndex]) || null);\n                    case 1:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }, _callee2, this);\n              }));\n              function getXfa() {\n                return _getXfa.apply(this, arguments);\n              }\n              return getXfa;\n            }()\n          }, {\n            key: \"render\",\n            value: function render(_ref5) {\n              var _arguments$,\n                _this$_stats,\n                _this8 = this,\n                _intentState;\n              var canvasContext = _ref5.canvasContext,\n                viewport = _ref5.viewport,\n                _ref5$intent = _ref5.intent,\n                intent = _ref5$intent === void 0 ? \"display\" : _ref5$intent,\n                _ref5$annotationMode = _ref5.annotationMode,\n                annotationMode = _ref5$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref5$annotationMode,\n                _ref5$transform = _ref5.transform,\n                transform = _ref5$transform === void 0 ? null : _ref5$transform,\n                _ref5$background = _ref5.background,\n                background = _ref5$background === void 0 ? null : _ref5$background,\n                _ref5$optionalContent = _ref5.optionalContentConfigPromise,\n                optionalContentConfigPromise = _ref5$optionalContent === void 0 ? null : _ref5$optionalContent,\n                _ref5$annotationCanva = _ref5.annotationCanvasMap,\n                annotationCanvasMap = _ref5$annotationCanva === void 0 ? null : _ref5$annotationCanva,\n                _ref5$pageColors = _ref5.pageColors,\n                pageColors = _ref5$pageColors === void 0 ? null : _ref5$pageColors,\n                _ref5$printAnnotation = _ref5.printAnnotationStorage,\n                printAnnotationStorage = _ref5$printAnnotation === void 0 ? null : _ref5$printAnnotation;\n              if ((_arguments$ = arguments[0]) !== null && _arguments$ !== void 0 && _arguments$.canvasFactory) {\n                throw new Error(\"render no longer accepts the `canvasFactory`-option, \" + \"please pass it to the `getDocument`-function instead.\");\n              }\n              (_this$_stats = this._stats) === null || _this$_stats === void 0 ? void 0 : _this$_stats.time(\"Overall\");\n              var intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);\n              _classPrivateFieldSet(this, _pendingCleanup, false);\n              _classPrivateMethodGet(this, _abortDelayedCleanup, _abortDelayedCleanup2).call(this);\n              if (!optionalContentConfigPromise) {\n                optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n              }\n              var intentState = this._intentStates.get(intentArgs.cacheKey);\n              if (!intentState) {\n                intentState = Object.create(null);\n                this._intentStates.set(intentArgs.cacheKey, intentState);\n              }\n              if (intentState.streamReaderCancelTimeout) {\n                clearTimeout(intentState.streamReaderCancelTimeout);\n                intentState.streamReaderCancelTimeout = null;\n              }\n              var intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n              if (!intentState.displayReadyCapability) {\n                var _this$_stats2;\n                intentState.displayReadyCapability = new _util.PromiseCapability();\n                intentState.operatorList = {\n                  fnArray: [],\n                  argsArray: [],\n                  lastChunk: false,\n                  separateAnnots: null\n                };\n                (_this$_stats2 = this._stats) === null || _this$_stats2 === void 0 ? void 0 : _this$_stats2.time(\"Page Request\");\n                this._pumpOperatorList(intentArgs);\n              }\n              var complete = function complete(error) {\n                var _this8$_stats, _this8$_stats2;\n                intentState.renderTasks.delete(internalRenderTask);\n                if (_this8._maybeCleanupAfterRender || intentPrint) {\n                  _classPrivateFieldSet(_this8, _pendingCleanup, true);\n                }\n                _classPrivateMethodGet(_this8, _tryCleanup, _tryCleanup2).call(_this8, !intentPrint);\n                if (error) {\n                  internalRenderTask.capability.reject(error);\n                  _this8._abortOperatorList({\n                    intentState: intentState,\n                    reason: error instanceof Error ? error : new Error(error)\n                  });\n                } else {\n                  internalRenderTask.capability.resolve();\n                }\n                (_this8$_stats = _this8._stats) === null || _this8$_stats === void 0 ? void 0 : _this8$_stats.timeEnd(\"Rendering\");\n                (_this8$_stats2 = _this8._stats) === null || _this8$_stats2 === void 0 ? void 0 : _this8$_stats2.timeEnd(\"Overall\");\n              };\n              var internalRenderTask = new InternalRenderTask({\n                callback: complete,\n                params: {\n                  canvasContext: canvasContext,\n                  viewport: viewport,\n                  transform: transform,\n                  background: background\n                },\n                objs: this.objs,\n                commonObjs: this.commonObjs,\n                annotationCanvasMap: annotationCanvasMap,\n                operatorList: intentState.operatorList,\n                pageIndex: this._pageIndex,\n                canvasFactory: this._transport.canvasFactory,\n                filterFactory: this._transport.filterFactory,\n                useRequestAnimationFrame: !intentPrint,\n                pdfBug: this._pdfBug,\n                pageColors: pageColors\n              });\n              ((_intentState = intentState).renderTasks || (_intentState.renderTasks = new Set())).add(internalRenderTask);\n              var renderTask = internalRenderTask.task;\n              Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(function (_ref6) {\n                var _this8$_stats3;\n                var _ref7 = _slicedToArray(_ref6, 2),\n                  transparency = _ref7[0],\n                  optionalContentConfig = _ref7[1];\n                if (_classPrivateFieldGet(_this8, _pendingCleanup)) {\n                  complete();\n                  return;\n                }\n                (_this8$_stats3 = _this8._stats) === null || _this8$_stats3 === void 0 ? void 0 : _this8$_stats3.time(\"Rendering\");\n                internalRenderTask.initializeGraphics({\n                  transparency: transparency,\n                  optionalContentConfig: optionalContentConfig\n                });\n                internalRenderTask.operatorListChanged();\n              }).catch(complete);\n              return renderTask;\n            }\n          }, {\n            key: \"getOperatorList\",\n            value: function getOperatorList() {\n              var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref8$intent = _ref8.intent,\n                intent = _ref8$intent === void 0 ? \"display\" : _ref8$intent,\n                _ref8$annotationMode = _ref8.annotationMode,\n                annotationMode = _ref8$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref8$annotationMode,\n                _ref8$printAnnotation = _ref8.printAnnotationStorage,\n                printAnnotationStorage = _ref8$printAnnotation === void 0 ? null : _ref8$printAnnotation;\n              function operatorListChanged() {\n                if (intentState.operatorList.lastChunk) {\n                  intentState.opListReadCapability.resolve(intentState.operatorList);\n                  intentState.renderTasks.delete(opListTask);\n                }\n              }\n              var intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);\n              var intentState = this._intentStates.get(intentArgs.cacheKey);\n              if (!intentState) {\n                intentState = Object.create(null);\n                this._intentStates.set(intentArgs.cacheKey, intentState);\n              }\n              var opListTask;\n              if (!intentState.opListReadCapability) {\n                var _intentState2, _this$_stats3;\n                opListTask = Object.create(null);\n                opListTask.operatorListChanged = operatorListChanged;\n                intentState.opListReadCapability = new _util.PromiseCapability();\n                ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = new Set())).add(opListTask);\n                intentState.operatorList = {\n                  fnArray: [],\n                  argsArray: [],\n                  lastChunk: false,\n                  separateAnnots: null\n                };\n                (_this$_stats3 = this._stats) === null || _this$_stats3 === void 0 ? void 0 : _this$_stats3.time(\"Page Request\");\n                this._pumpOperatorList(intentArgs);\n              }\n              return intentState.opListReadCapability.promise;\n            }\n          }, {\n            key: \"streamTextContent\",\n            value: function streamTextContent() {\n              var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref9$includeMarkedCo = _ref9.includeMarkedContent,\n                includeMarkedContent = _ref9$includeMarkedCo === void 0 ? false : _ref9$includeMarkedCo,\n                _ref9$disableNormaliz = _ref9.disableNormalization,\n                disableNormalization = _ref9$disableNormaliz === void 0 ? false : _ref9$disableNormaliz;\n              var TEXT_CONTENT_CHUNK_SIZE = 100;\n              return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n                pageIndex: this._pageIndex,\n                includeMarkedContent: includeMarkedContent === true,\n                disableNormalization: disableNormalization === true\n              }, {\n                highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n                size: function size(textContent) {\n                  return textContent.items.length;\n                }\n              });\n            }\n          }, {\n            key: \"getTextContent\",\n            value: function getTextContent() {\n              var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              if (this._transport._htmlForXfa) {\n                return this.getXfa().then(function (xfa) {\n                  return _xfa_text.XfaText.textContent(xfa);\n                });\n              }\n              var readableStream = this.streamTextContent(params);\n              return new Promise(function (resolve, reject) {\n                function pump() {\n                  reader.read().then(function (_ref10) {\n                    var _textContent$items;\n                    var value = _ref10.value,\n                      done = _ref10.done;\n                    if (done) {\n                      resolve(textContent);\n                      return;\n                    }\n                    Object.assign(textContent.styles, value.styles);\n                    (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));\n                    pump();\n                  }, reject);\n                }\n                var reader = readableStream.getReader();\n                var textContent = {\n                  items: [],\n                  styles: Object.create(null)\n                };\n                pump();\n              });\n            }\n          }, {\n            key: \"getStructTree\",\n            value: function getStructTree() {\n              return this._transport.getStructTree(this._pageIndex);\n            }\n          }, {\n            key: \"_destroy\",\n            value: function _destroy() {\n              this.destroyed = true;\n              var waitOn = [];\n              var _iterator6 = _createForOfIteratorHelper(this._intentStates.values()),\n                _step6;\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var intentState = _step6.value;\n                  this._abortOperatorList({\n                    intentState: intentState,\n                    reason: new Error(\"Page was destroyed.\"),\n                    force: true\n                  });\n                  if (intentState.opListReadCapability) {\n                    continue;\n                  }\n                  var _iterator7 = _createForOfIteratorHelper(intentState.renderTasks),\n                    _step7;\n                  try {\n                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                      var internalRenderTask = _step7.value;\n                      waitOn.push(internalRenderTask.completed);\n                      internalRenderTask.cancel();\n                    }\n                  } catch (err) {\n                    _iterator7.e(err);\n                  } finally {\n                    _iterator7.f();\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n              this.objs.clear();\n              _classPrivateFieldSet(this, _pendingCleanup, false);\n              _classPrivateMethodGet(this, _abortDelayedCleanup, _abortDelayedCleanup2).call(this);\n              return Promise.all(waitOn);\n            }\n          }, {\n            key: \"cleanup\",\n            value: function cleanup() {\n              var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n              _classPrivateFieldSet(this, _pendingCleanup, true);\n              var success = _classPrivateMethodGet(this, _tryCleanup, _tryCleanup2).call(this, false);\n              if (resetStats && success) {\n                this._stats && (this._stats = new _display_utils.StatTimer());\n              }\n              return success;\n            }\n          }, {\n            key: \"_startRenderPage\",\n            value: function _startRenderPage(transparency, cacheKey) {\n              var _this$_stats4, _intentState$displayR;\n              var intentState = this._intentStates.get(cacheKey);\n              if (!intentState) {\n                return;\n              }\n              (_this$_stats4 = this._stats) === null || _this$_stats4 === void 0 ? void 0 : _this$_stats4.timeEnd(\"Page Request\");\n              (_intentState$displayR = intentState.displayReadyCapability) === null || _intentState$displayR === void 0 ? void 0 : _intentState$displayR.resolve(transparency);\n            }\n          }, {\n            key: \"_renderPageChunk\",\n            value: function _renderPageChunk(operatorListChunk, intentState) {\n              for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {\n                intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n                intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n              }\n              intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n              intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n              var _iterator8 = _createForOfIteratorHelper(intentState.renderTasks),\n                _step8;\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var internalRenderTask = _step8.value;\n                  internalRenderTask.operatorListChanged();\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n              if (operatorListChunk.lastChunk) {\n                _classPrivateMethodGet(this, _tryCleanup, _tryCleanup2).call(this, true);\n              }\n            }\n          }, {\n            key: \"_pumpOperatorList\",\n            value: function _pumpOperatorList(_ref11) {\n              var _this9 = this;\n              var renderingIntent = _ref11.renderingIntent,\n                cacheKey = _ref11.cacheKey,\n                annotationStorageMap = _ref11.annotationStorageMap;\n              var readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n                pageIndex: this._pageIndex,\n                intent: renderingIntent,\n                cacheKey: cacheKey,\n                annotationStorage: annotationStorageMap\n              });\n              var reader = readableStream.getReader();\n              var intentState = this._intentStates.get(cacheKey);\n              intentState.streamReader = reader;\n              var pump = function pump() {\n                reader.read().then(function (_ref12) {\n                  var value = _ref12.value,\n                    done = _ref12.done;\n                  if (done) {\n                    intentState.streamReader = null;\n                    return;\n                  }\n                  if (_this9._transport.destroyed) {\n                    return;\n                  }\n                  _this9._renderPageChunk(value, intentState);\n                  pump();\n                }, function (reason) {\n                  intentState.streamReader = null;\n                  if (_this9._transport.destroyed) {\n                    return;\n                  }\n                  if (intentState.operatorList) {\n                    intentState.operatorList.lastChunk = true;\n                    var _iterator9 = _createForOfIteratorHelper(intentState.renderTasks),\n                      _step9;\n                    try {\n                      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                        var internalRenderTask = _step9.value;\n                        internalRenderTask.operatorListChanged();\n                      }\n                    } catch (err) {\n                      _iterator9.e(err);\n                    } finally {\n                      _iterator9.f();\n                    }\n                    _classPrivateMethodGet(_this9, _tryCleanup, _tryCleanup2).call(_this9, true);\n                  }\n                  if (intentState.displayReadyCapability) {\n                    intentState.displayReadyCapability.reject(reason);\n                  } else if (intentState.opListReadCapability) {\n                    intentState.opListReadCapability.reject(reason);\n                  } else {\n                    throw reason;\n                  }\n                });\n              };\n              pump();\n            }\n          }, {\n            key: \"_abortOperatorList\",\n            value: function _abortOperatorList(_ref13) {\n              var _this10 = this;\n              var intentState = _ref13.intentState,\n                reason = _ref13.reason,\n                _ref13$force = _ref13.force,\n                force = _ref13$force === void 0 ? false : _ref13$force;\n              if (!intentState.streamReader) {\n                return;\n              }\n              if (intentState.streamReaderCancelTimeout) {\n                clearTimeout(intentState.streamReaderCancelTimeout);\n                intentState.streamReaderCancelTimeout = null;\n              }\n              if (!force) {\n                if (intentState.renderTasks.size > 0) {\n                  return;\n                }\n                if (reason instanceof _display_utils.RenderingCancelledException) {\n                  var delay = RENDERING_CANCELLED_TIMEOUT;\n                  if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                    delay += reason.extraDelay;\n                  }\n                  intentState.streamReaderCancelTimeout = setTimeout(function () {\n                    intentState.streamReaderCancelTimeout = null;\n                    _this10._abortOperatorList({\n                      intentState: intentState,\n                      reason: reason,\n                      force: true\n                    });\n                  }, delay);\n                  return;\n                }\n              }\n              intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(function () {});\n              intentState.streamReader = null;\n              if (this._transport.destroyed) {\n                return;\n              }\n              var _iterator10 = _createForOfIteratorHelper(this._intentStates),\n                _step10;\n              try {\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  var _step10$value = _slicedToArray(_step10.value, 2),\n                    curCacheKey = _step10$value[0],\n                    curIntentState = _step10$value[1];\n                  if (curIntentState === intentState) {\n                    this._intentStates.delete(curCacheKey);\n                    break;\n                  }\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n              this.cleanup();\n            }\n          }, {\n            key: \"stats\",\n            get: function get() {\n              return this._stats;\n            }\n          }]);\n          return PDFPageProxy;\n        }();\n        function _tryCleanup2() {\n          var _this21 = this;\n          var delayed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n          _classPrivateMethodGet(this, _abortDelayedCleanup, _abortDelayedCleanup2).call(this);\n          if (!_classPrivateFieldGet(this, _pendingCleanup)) {\n            return false;\n          }\n          if (delayed) {\n            _classPrivateFieldSet(this, _delayedCleanupTimeout, setTimeout(function () {\n              _classPrivateFieldSet(_this21, _delayedCleanupTimeout, null);\n              _classPrivateMethodGet(_this21, _tryCleanup, _tryCleanup2).call(_this21, false);\n            }, DELAYED_CLEANUP_TIMEOUT));\n            return false;\n          }\n          var _iterator14 = _createForOfIteratorHelper(this._intentStates.values()),\n            _step14;\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var _step14$value = _step14.value,\n                renderTasks = _step14$value.renderTasks,\n                operatorList = _step14$value.operatorList;\n              if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                return false;\n              }\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n          this._intentStates.clear();\n          this.objs.clear();\n          _classPrivateFieldSet(this, _pendingCleanup, false);\n          return true;\n        }\n        function _abortDelayedCleanup2() {\n          if (_classPrivateFieldGet(this, _delayedCleanupTimeout)) {\n            clearTimeout(_classPrivateFieldGet(this, _delayedCleanupTimeout));\n            _classPrivateFieldSet(this, _delayedCleanupTimeout, null);\n          }\n        }\n        exports.PDFPageProxy = PDFPageProxy;\n        var _listeners = /*#__PURE__*/new WeakMap();\n        var _deferred = /*#__PURE__*/new WeakMap();\n        var LoopbackPort = /*#__PURE__*/function () {\n          function LoopbackPort() {\n            _classCallCheck(this, LoopbackPort);\n            _classPrivateFieldInitSpec(this, _listeners, {\n              writable: true,\n              value: new Set()\n            });\n            _classPrivateFieldInitSpec(this, _deferred, {\n              writable: true,\n              value: Promise.resolve()\n            });\n          }\n          _createClass(LoopbackPort, [{\n            key: \"postMessage\",\n            value: function postMessage(obj, transfer) {\n              var _this11 = this;\n              var event = {\n                data: structuredClone(obj, transfer ? {\n                  transfer: transfer\n                } : null)\n              };\n              _classPrivateFieldGet(this, _deferred).then(function () {\n                var _iterator11 = _createForOfIteratorHelper(_classPrivateFieldGet(_this11, _listeners)),\n                  _step11;\n                try {\n                  for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                    var listener = _step11.value;\n                    listener.call(_this11, event);\n                  }\n                } catch (err) {\n                  _iterator11.e(err);\n                } finally {\n                  _iterator11.f();\n                }\n              });\n            }\n          }, {\n            key: \"addEventListener\",\n            value: function addEventListener(name, listener) {\n              _classPrivateFieldGet(this, _listeners).add(listener);\n            }\n          }, {\n            key: \"removeEventListener\",\n            value: function removeEventListener(name, listener) {\n              _classPrivateFieldGet(this, _listeners).delete(listener);\n            }\n          }, {\n            key: \"terminate\",\n            value: function terminate() {\n              _classPrivateFieldGet(this, _listeners).clear();\n            }\n          }]);\n          return LoopbackPort;\n        }();\n        exports.LoopbackPort = LoopbackPort;\n        var PDFWorkerUtil = {\n          isWorkerDisabled: false,\n          fallbackWorkerSrc: null,\n          fakeWorkerId: 0\n        };\n        exports.PDFWorkerUtil = PDFWorkerUtil;\n        {\n          if (_is_node.isNodeJS && typeof require === \"function\") {\n            PDFWorkerUtil.isWorkerDisabled = true;\n            PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n          } else if (typeof document === \"object\") {\n            var _document, _document$currentScri;\n            var pdfjsFilePath = (_document = document) === null || _document === void 0 ? void 0 : (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;\n            if (pdfjsFilePath) {\n              PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n            }\n          }\n          PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {\n            var base;\n            try {\n              base = new URL(baseUrl);\n              if (!base.origin || base.origin === \"null\") {\n                return false;\n              }\n            } catch (e) {\n              return false;\n            }\n            var other = new URL(otherUrl, base);\n            return base.origin === other.origin;\n          };\n          PDFWorkerUtil.createCDNWrapper = function (url) {\n            var wrapper = \"importScripts(\\\"\".concat(url, \"\\\");\");\n            return URL.createObjectURL(new Blob([wrapper]));\n          };\n        }\n        var PDFWorker = /*#__PURE__*/function () {\n          function PDFWorker() {\n            var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n              _ref14$name = _ref14.name,\n              name = _ref14$name === void 0 ? null : _ref14$name,\n              _ref14$port = _ref14.port,\n              port = _ref14$port === void 0 ? null : _ref14$port,\n              _ref14$verbosity = _ref14.verbosity,\n              verbosity = _ref14$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref14$verbosity;\n            _classCallCheck(this, PDFWorker);\n            if (port && _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).has(port)) {\n              throw new Error(\"Cannot use more than one PDFWorker per port.\");\n            }\n            this.name = name;\n            this.destroyed = false;\n            this.verbosity = verbosity;\n            this._readyCapability = new _util.PromiseCapability();\n            this._port = null;\n            this._webWorker = null;\n            this._messageHandler = null;\n            if (port) {\n              _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).set(port, this);\n              this._initializeFromPort(port);\n              return;\n            }\n            this._initialize();\n          }\n          _createClass(PDFWorker, [{\n            key: \"promise\",\n            get: function get() {\n              return this._readyCapability.promise;\n            }\n          }, {\n            key: \"port\",\n            get: function get() {\n              return this._port;\n            }\n          }, {\n            key: \"messageHandler\",\n            get: function get() {\n              return this._messageHandler;\n            }\n          }, {\n            key: \"_initializeFromPort\",\n            value: function _initializeFromPort(port) {\n              this._port = port;\n              this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n              this._messageHandler.on(\"ready\", function () {});\n              this._readyCapability.resolve();\n              this._messageHandler.send(\"configure\", {\n                verbosity: this.verbosity\n              });\n            }\n          }, {\n            key: \"_initialize\",\n            value: function _initialize() {\n              var _this12 = this;\n              if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n                var workerSrc = PDFWorker.workerSrc;\n                try {\n                  if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {\n                    workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n                  }\n                  var worker = new Worker(workerSrc);\n                  var messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n                  var terminateEarly = function terminateEarly() {\n                    worker.removeEventListener(\"error\", onWorkerError);\n                    messageHandler.destroy();\n                    worker.terminate();\n                    if (_this12.destroyed) {\n                      _this12._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                    } else {\n                      _this12._setupFakeWorker();\n                    }\n                  };\n                  var onWorkerError = function onWorkerError() {\n                    if (!_this12._webWorker) {\n                      terminateEarly();\n                    }\n                  };\n                  worker.addEventListener(\"error\", onWorkerError);\n                  messageHandler.on(\"test\", function (data) {\n                    worker.removeEventListener(\"error\", onWorkerError);\n                    if (_this12.destroyed) {\n                      terminateEarly();\n                      return;\n                    }\n                    if (data) {\n                      _this12._messageHandler = messageHandler;\n                      _this12._port = worker;\n                      _this12._webWorker = worker;\n                      _this12._readyCapability.resolve();\n                      messageHandler.send(\"configure\", {\n                        verbosity: _this12.verbosity\n                      });\n                    } else {\n                      _this12._setupFakeWorker();\n                      messageHandler.destroy();\n                      worker.terminate();\n                    }\n                  });\n                  messageHandler.on(\"ready\", function (data) {\n                    worker.removeEventListener(\"error\", onWorkerError);\n                    if (_this12.destroyed) {\n                      terminateEarly();\n                      return;\n                    }\n                    try {\n                      sendTest();\n                    } catch (e) {\n                      _this12._setupFakeWorker();\n                    }\n                  });\n                  var sendTest = function sendTest() {\n                    var testObj = new Uint8Array();\n                    messageHandler.send(\"test\", testObj, [testObj.buffer]);\n                  };\n                  sendTest();\n                  return;\n                } catch (e) {\n                  (0, _util.info)(\"The worker has been disabled.\");\n                }\n              }\n              this._setupFakeWorker();\n            }\n          }, {\n            key: \"_setupFakeWorker\",\n            value: function _setupFakeWorker() {\n              var _this13 = this;\n              if (!PDFWorkerUtil.isWorkerDisabled) {\n                (0, _util.warn)(\"Setting up fake worker.\");\n                PDFWorkerUtil.isWorkerDisabled = true;\n              }\n              PDFWorker._setupFakeWorkerGlobal.then(function (WorkerMessageHandler) {\n                if (_this13.destroyed) {\n                  _this13._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                  return;\n                }\n                var port = new LoopbackPort();\n                _this13._port = port;\n                var id = \"fake\".concat(PDFWorkerUtil.fakeWorkerId++);\n                var workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n                WorkerMessageHandler.setup(workerHandler, port);\n                var messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n                _this13._messageHandler = messageHandler;\n                _this13._readyCapability.resolve();\n                messageHandler.send(\"configure\", {\n                  verbosity: _this13.verbosity\n                });\n              }).catch(function (reason) {\n                _this13._readyCapability.reject(new Error(\"Setting up fake worker failed: \\\"\".concat(reason.message, \"\\\".\")));\n              });\n            }\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              this.destroyed = true;\n              if (this._webWorker) {\n                this._webWorker.terminate();\n                this._webWorker = null;\n              }\n              _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).delete(this._port);\n              this._port = null;\n              if (this._messageHandler) {\n                this._messageHandler.destroy();\n                this._messageHandler = null;\n              }\n            }\n          }], [{\n            key: \"fromPort\",\n            value: function fromPort(params) {\n              if (!(params !== null && params !== void 0 && params.port)) {\n                throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n              }\n              if (_classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).has(params.port)) {\n                return _classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).get(params.port);\n              }\n              return new PDFWorker(params);\n            }\n          }, {\n            key: \"workerSrc\",\n            get: function get() {\n              if (_worker_options.GlobalWorkerOptions.workerSrc) {\n                return _worker_options.GlobalWorkerOptions.workerSrc;\n              }\n              if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n                if (!_is_node.isNodeJS) {\n                  (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n                }\n                return PDFWorkerUtil.fallbackWorkerSrc;\n              }\n              throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n            }\n          }, {\n            key: \"_mainThreadWorkerMessageHandler\",\n            get: function get() {\n              try {\n                var _globalThis$pdfjsWork;\n                return ((_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler) || null;\n              } catch (ex) {\n                return null;\n              }\n            }\n          }, {\n            key: \"_setupFakeWorkerGlobal\",\n            get: function get() {\n              var _this14 = this;\n              var loader = /*#__PURE__*/function () {\n                var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  var mainWorkerMessageHandler, worker;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        mainWorkerMessageHandler = _this14._mainThreadWorkerMessageHandler;\n                        if (!mainWorkerMessageHandler) {\n                          _context3.next = 3;\n                          break;\n                        }\n                        return _context3.abrupt(\"return\", mainWorkerMessageHandler);\n                      case 3:\n                        if (!(_is_node.isNodeJS && typeof require === \"function\")) {\n                          _context3.next = 6;\n                          break;\n                        }\n                        worker = eval(\"require\")(_this14.workerSrc);\n                        return _context3.abrupt(\"return\", worker.WorkerMessageHandler);\n                      case 6:\n                        _context3.next = 8;\n                        return (0, _display_utils.loadScript)(_this14.workerSrc);\n                      case 8:\n                        return _context3.abrupt(\"return\", window.pdfjsWorker.WorkerMessageHandler);\n                      case 9:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3);\n                }));\n                return function loader() {\n                  return _ref15.apply(this, arguments);\n                };\n              }();\n              return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n            }\n          }]);\n          return PDFWorker;\n        }();\n        var _workerPorts = {\n          writable: true,\n          value: new WeakMap()\n        };\n        exports.PDFWorker = PDFWorker;\n        var _methodPromises = /*#__PURE__*/new WeakMap();\n        var _pageCache = /*#__PURE__*/new WeakMap();\n        var _pagePromises = /*#__PURE__*/new WeakMap();\n        var _cacheSimpleMethod = /*#__PURE__*/new WeakSet();\n        var WorkerTransport = /*#__PURE__*/function () {\n          function WorkerTransport(messageHandler, loadingTask, networkStream, params, factory) {\n            _classCallCheck(this, WorkerTransport);\n            _classPrivateMethodInitSpec(this, _cacheSimpleMethod);\n            _classPrivateFieldInitSpec(this, _methodPromises, {\n              writable: true,\n              value: new Map()\n            });\n            _classPrivateFieldInitSpec(this, _pageCache, {\n              writable: true,\n              value: new Map()\n            });\n            _classPrivateFieldInitSpec(this, _pagePromises, {\n              writable: true,\n              value: new Map()\n            });\n            this.messageHandler = messageHandler;\n            this.loadingTask = loadingTask;\n            this.commonObjs = new PDFObjects();\n            this.fontLoader = new _font_loader.FontLoader({\n              ownerDocument: params.ownerDocument,\n              styleElement: params.styleElement\n            });\n            this._params = params;\n            this.canvasFactory = factory.canvasFactory;\n            this.filterFactory = factory.filterFactory;\n            this.cMapReaderFactory = factory.cMapReaderFactory;\n            this.standardFontDataFactory = factory.standardFontDataFactory;\n            this.destroyed = false;\n            this.destroyCapability = null;\n            this._passwordCapability = null;\n            this._networkStream = networkStream;\n            this._fullReader = null;\n            this._lastProgress = null;\n            this.downloadInfoCapability = new _util.PromiseCapability();\n            this.setupMessageHandler();\n          }\n          _createClass(WorkerTransport, [{\n            key: \"annotationStorage\",\n            get: function get() {\n              return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n            }\n          }, {\n            key: \"getRenderingIntent\",\n            value: function getRenderingIntent(intent) {\n              var annotationMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _util.AnnotationMode.ENABLE;\n              var printAnnotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n              var isOpList = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n              var renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n              var annotationMap = null;\n              switch (intent) {\n                case \"any\":\n                  renderingIntent = _util.RenderingIntentFlag.ANY;\n                  break;\n                case \"display\":\n                  break;\n                case \"print\":\n                  renderingIntent = _util.RenderingIntentFlag.PRINT;\n                  break;\n                default:\n                  (0, _util.warn)(\"getRenderingIntent - invalid intent: \".concat(intent));\n              }\n              switch (annotationMode) {\n                case _util.AnnotationMode.DISABLE:\n                  renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                  break;\n                case _util.AnnotationMode.ENABLE:\n                  break;\n                case _util.AnnotationMode.ENABLE_FORMS:\n                  renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n                  break;\n                case _util.AnnotationMode.ENABLE_STORAGE:\n                  renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                  var annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n                  annotationMap = annotationStorage.serializable;\n                  break;\n                default:\n                  (0, _util.warn)(\"getRenderingIntent - invalid annotationMode: \".concat(annotationMode));\n              }\n              if (isOpList) {\n                renderingIntent += _util.RenderingIntentFlag.OPLIST;\n              }\n              return {\n                renderingIntent: renderingIntent,\n                cacheKey: \"\".concat(renderingIntent, \"_\").concat(_annotation_storage.AnnotationStorage.getHash(annotationMap)),\n                annotationStorageMap: annotationMap\n              };\n            }\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              var _this15 = this;\n              if (this.destroyCapability) {\n                return this.destroyCapability.promise;\n              }\n              this.destroyed = true;\n              this.destroyCapability = new _util.PromiseCapability();\n              if (this._passwordCapability) {\n                this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n              }\n              var waitOn = [];\n              var _iterator12 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _pageCache).values()),\n                _step12;\n              try {\n                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                  var page = _step12.value;\n                  waitOn.push(page._destroy());\n                }\n              } catch (err) {\n                _iterator12.e(err);\n              } finally {\n                _iterator12.f();\n              }\n              _classPrivateFieldGet(this, _pageCache).clear();\n              _classPrivateFieldGet(this, _pagePromises).clear();\n              if (this.hasOwnProperty(\"annotationStorage\")) {\n                this.annotationStorage.resetModified();\n              }\n              var terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n              waitOn.push(terminated);\n              Promise.all(waitOn).then(function () {\n                _this15.commonObjs.clear();\n                _this15.fontLoader.clear();\n                _classPrivateFieldGet(_this15, _methodPromises).clear();\n                _this15.filterFactory.destroy();\n                if (_this15._networkStream) {\n                  _this15._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n                }\n                if (_this15.messageHandler) {\n                  _this15.messageHandler.destroy();\n                  _this15.messageHandler = null;\n                }\n                _this15.destroyCapability.resolve();\n              }, this.destroyCapability.reject);\n              return this.destroyCapability.promise;\n            }\n          }, {\n            key: \"setupMessageHandler\",\n            value: function setupMessageHandler() {\n              var _this16 = this;\n              var messageHandler = this.messageHandler,\n                loadingTask = this.loadingTask;\n              messageHandler.on(\"GetReader\", function (data, sink) {\n                (0, _util.assert)(_this16._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n                _this16._fullReader = _this16._networkStream.getFullReader();\n                _this16._fullReader.onProgress = function (evt) {\n                  _this16._lastProgress = {\n                    loaded: evt.loaded,\n                    total: evt.total\n                  };\n                };\n                sink.onPull = function () {\n                  _this16._fullReader.read().then(function (_ref16) {\n                    var value = _ref16.value,\n                      done = _ref16.done;\n                    if (done) {\n                      sink.close();\n                      return;\n                    }\n                    (0, _util.assert)(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [value]);\n                  }).catch(function (reason) {\n                    sink.error(reason);\n                  });\n                };\n                sink.onCancel = function (reason) {\n                  _this16._fullReader.cancel(reason);\n                  sink.ready.catch(function (readyReason) {\n                    if (_this16.destroyed) {\n                      return;\n                    }\n                    throw readyReason;\n                  });\n                };\n              });\n              messageHandler.on(\"ReaderHeadersReady\", function (data) {\n                var headersCapability = new _util.PromiseCapability();\n                var fullReader = _this16._fullReader;\n                fullReader.headersReady.then(function () {\n                  if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n                    if (_this16._lastProgress) {\n                      var _loadingTask$onProgre;\n                      (_loadingTask$onProgre = loadingTask.onProgress) === null || _loadingTask$onProgre === void 0 ? void 0 : _loadingTask$onProgre.call(loadingTask, _this16._lastProgress);\n                    }\n                    fullReader.onProgress = function (evt) {\n                      var _loadingTask$onProgre2;\n                      (_loadingTask$onProgre2 = loadingTask.onProgress) === null || _loadingTask$onProgre2 === void 0 ? void 0 : _loadingTask$onProgre2.call(loadingTask, {\n                        loaded: evt.loaded,\n                        total: evt.total\n                      });\n                    };\n                  }\n                  headersCapability.resolve({\n                    isStreamingSupported: fullReader.isStreamingSupported,\n                    isRangeSupported: fullReader.isRangeSupported,\n                    contentLength: fullReader.contentLength\n                  });\n                }, headersCapability.reject);\n                return headersCapability.promise;\n              });\n              messageHandler.on(\"GetRangeReader\", function (data, sink) {\n                (0, _util.assert)(_this16._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n                var rangeReader = _this16._networkStream.getRangeReader(data.begin, data.end);\n                if (!rangeReader) {\n                  sink.close();\n                  return;\n                }\n                sink.onPull = function () {\n                  rangeReader.read().then(function (_ref17) {\n                    var value = _ref17.value,\n                      done = _ref17.done;\n                    if (done) {\n                      sink.close();\n                      return;\n                    }\n                    (0, _util.assert)(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [value]);\n                  }).catch(function (reason) {\n                    sink.error(reason);\n                  });\n                };\n                sink.onCancel = function (reason) {\n                  rangeReader.cancel(reason);\n                  sink.ready.catch(function (readyReason) {\n                    if (_this16.destroyed) {\n                      return;\n                    }\n                    throw readyReason;\n                  });\n                };\n              });\n              messageHandler.on(\"GetDoc\", function (_ref18) {\n                var pdfInfo = _ref18.pdfInfo;\n                _this16._numPages = pdfInfo.numPages;\n                _this16._htmlForXfa = pdfInfo.htmlForXfa;\n                delete pdfInfo.htmlForXfa;\n                loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this16));\n              });\n              messageHandler.on(\"DocException\", function (ex) {\n                var reason;\n                switch (ex.name) {\n                  case \"PasswordException\":\n                    reason = new _util.PasswordException(ex.message, ex.code);\n                    break;\n                  case \"InvalidPDFException\":\n                    reason = new _util.InvalidPDFException(ex.message);\n                    break;\n                  case \"MissingPDFException\":\n                    reason = new _util.MissingPDFException(ex.message);\n                    break;\n                  case \"UnexpectedResponseException\":\n                    reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n                    break;\n                  case \"UnknownErrorException\":\n                    reason = new _util.UnknownErrorException(ex.message, ex.details);\n                    break;\n                  default:\n                    (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n                }\n                loadingTask._capability.reject(reason);\n              });\n              messageHandler.on(\"PasswordRequest\", function (exception) {\n                _this16._passwordCapability = new _util.PromiseCapability();\n                if (loadingTask.onPassword) {\n                  var updatePassword = function updatePassword(password) {\n                    if (password instanceof Error) {\n                      _this16._passwordCapability.reject(password);\n                    } else {\n                      _this16._passwordCapability.resolve({\n                        password: password\n                      });\n                    }\n                  };\n                  try {\n                    loadingTask.onPassword(updatePassword, exception.code);\n                  } catch (ex) {\n                    _this16._passwordCapability.reject(ex);\n                  }\n                } else {\n                  _this16._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n                }\n                return _this16._passwordCapability.promise;\n              });\n              messageHandler.on(\"DataLoaded\", function (data) {\n                var _loadingTask$onProgre3;\n                (_loadingTask$onProgre3 = loadingTask.onProgress) === null || _loadingTask$onProgre3 === void 0 ? void 0 : _loadingTask$onProgre3.call(loadingTask, {\n                  loaded: data.length,\n                  total: data.length\n                });\n                _this16.downloadInfoCapability.resolve(data);\n              });\n              messageHandler.on(\"StartRenderPage\", function (data) {\n                if (_this16.destroyed) {\n                  return;\n                }\n                var page = _classPrivateFieldGet(_this16, _pageCache).get(data.pageIndex);\n                page._startRenderPage(data.transparency, data.cacheKey);\n              });\n              messageHandler.on(\"commonobj\", function (_ref19) {\n                var _globalThis$FontInspe;\n                var _ref20 = _slicedToArray(_ref19, 3),\n                  id = _ref20[0],\n                  type = _ref20[1],\n                  exportedData = _ref20[2];\n                if (_this16.destroyed) {\n                  return;\n                }\n                if (_this16.commonObjs.has(id)) {\n                  return;\n                }\n                switch (type) {\n                  case \"Font\":\n                    var params = _this16._params;\n                    if (\"error\" in exportedData) {\n                      var exportedError = exportedData.error;\n                      (0, _util.warn)(\"Error during font loading: \".concat(exportedError));\n                      _this16.commonObjs.resolve(id, exportedError);\n                      break;\n                    }\n                    var inspectFont = params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled ? function (font, url) {\n                      return globalThis.FontInspector.fontAdded(font, url);\n                    } : null;\n                    var font = new _font_loader.FontFaceObject(exportedData, {\n                      isEvalSupported: params.isEvalSupported,\n                      disableFontFace: params.disableFontFace,\n                      ignoreErrors: params.ignoreErrors,\n                      inspectFont: inspectFont\n                    });\n                    _this16.fontLoader.bind(font).catch(function (reason) {\n                      return messageHandler.sendWithPromise(\"FontFallback\", {\n                        id: id\n                      });\n                    }).finally(function () {\n                      if (!params.fontExtraProperties && font.data) {\n                        font.data = null;\n                      }\n                      _this16.commonObjs.resolve(id, font);\n                    });\n                    break;\n                  case \"FontPath\":\n                  case \"Image\":\n                  case \"Pattern\":\n                    _this16.commonObjs.resolve(id, exportedData);\n                    break;\n                  default:\n                    throw new Error(\"Got unknown common object type \".concat(type));\n                }\n              });\n              messageHandler.on(\"obj\", function (_ref21) {\n                var _ref22 = _slicedToArray(_ref21, 4),\n                  id = _ref22[0],\n                  pageIndex = _ref22[1],\n                  type = _ref22[2],\n                  imageData = _ref22[3];\n                if (_this16.destroyed) {\n                  return;\n                }\n                var pageProxy = _classPrivateFieldGet(_this16, _pageCache).get(pageIndex);\n                if (pageProxy.objs.has(id)) {\n                  return;\n                }\n                switch (type) {\n                  case \"Image\":\n                    pageProxy.objs.resolve(id, imageData);\n                    if (imageData) {\n                      var length;\n                      if (imageData.bitmap) {\n                        var width = imageData.width,\n                          height = imageData.height;\n                        length = width * height * 4;\n                      } else {\n                        var _imageData$data;\n                        length = ((_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) || 0;\n                      }\n                      if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {\n                        pageProxy._maybeCleanupAfterRender = true;\n                      }\n                    }\n                    break;\n                  case \"Pattern\":\n                    pageProxy.objs.resolve(id, imageData);\n                    break;\n                  default:\n                    throw new Error(\"Got unknown object type \".concat(type));\n                }\n              });\n              messageHandler.on(\"DocProgress\", function (data) {\n                var _loadingTask$onProgre4;\n                if (_this16.destroyed) {\n                  return;\n                }\n                (_loadingTask$onProgre4 = loadingTask.onProgress) === null || _loadingTask$onProgre4 === void 0 ? void 0 : _loadingTask$onProgre4.call(loadingTask, {\n                  loaded: data.loaded,\n                  total: data.total\n                });\n              });\n              messageHandler.on(\"FetchBuiltInCMap\", function (data) {\n                if (_this16.destroyed) {\n                  return Promise.reject(new Error(\"Worker was destroyed.\"));\n                }\n                if (!_this16.cMapReaderFactory) {\n                  return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                }\n                return _this16.cMapReaderFactory.fetch(data);\n              });\n              messageHandler.on(\"FetchStandardFontData\", function (data) {\n                if (_this16.destroyed) {\n                  return Promise.reject(new Error(\"Worker was destroyed.\"));\n                }\n                if (!_this16.standardFontDataFactory) {\n                  return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                }\n                return _this16.standardFontDataFactory.fetch(data);\n              });\n            }\n          }, {\n            key: \"getData\",\n            value: function getData() {\n              return this.messageHandler.sendWithPromise(\"GetData\", null);\n            }\n          }, {\n            key: \"saveDocument\",\n            value: function saveDocument() {\n              var _this$_fullReader$fil,\n                _this$_fullReader,\n                _this17 = this;\n              if (this.annotationStorage.size <= 0) {\n                (0, _util.warn)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n              }\n              return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n                isPureXfa: !!this._htmlForXfa,\n                numPages: this._numPages,\n                annotationStorage: this.annotationStorage.serializable,\n                filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null\n              }).finally(function () {\n                _this17.annotationStorage.resetModified();\n              });\n            }\n          }, {\n            key: \"getPage\",\n            value: function getPage(pageNumber) {\n              var _this18 = this;\n              if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n                return Promise.reject(new Error(\"Invalid page request.\"));\n              }\n              var pageIndex = pageNumber - 1,\n                cachedPromise = _classPrivateFieldGet(this, _pagePromises).get(pageIndex);\n              if (cachedPromise) {\n                return cachedPromise;\n              }\n              var promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n                pageIndex: pageIndex\n              }).then(function (pageInfo) {\n                if (_this18.destroyed) {\n                  throw new Error(\"Transport destroyed\");\n                }\n                var page = new PDFPageProxy(pageIndex, pageInfo, _this18, _this18._params.pdfBug);\n                _classPrivateFieldGet(_this18, _pageCache).set(pageIndex, page);\n                return page;\n              });\n              _classPrivateFieldGet(this, _pagePromises).set(pageIndex, promise);\n              return promise;\n            }\n          }, {\n            key: \"getPageIndex\",\n            value: function getPageIndex(ref) {\n              if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {\n                return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n              }\n              return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n                num: ref.num,\n                gen: ref.gen\n              });\n            }\n          }, {\n            key: \"getAnnotations\",\n            value: function getAnnotations(pageIndex, intent) {\n              return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n                pageIndex: pageIndex,\n                intent: intent\n              });\n            }\n          }, {\n            key: \"getFieldObjects\",\n            value: function getFieldObjects() {\n              return _classPrivateMethodGet(this, _cacheSimpleMethod, _cacheSimpleMethod2).call(this, \"GetFieldObjects\");\n            }\n          }, {\n            key: \"hasJSActions\",\n            value: function hasJSActions() {\n              return _classPrivateMethodGet(this, _cacheSimpleMethod, _cacheSimpleMethod2).call(this, \"HasJSActions\");\n            }\n          }, {\n            key: \"getCalculationOrderIds\",\n            value: function getCalculationOrderIds() {\n              return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n            }\n          }, {\n            key: \"getDestinations\",\n            value: function getDestinations() {\n              return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n            }\n          }, {\n            key: \"getDestination\",\n            value: function getDestination(id) {\n              if (typeof id !== \"string\") {\n                return Promise.reject(new Error(\"Invalid destination request.\"));\n              }\n              return this.messageHandler.sendWithPromise(\"GetDestination\", {\n                id: id\n              });\n            }\n          }, {\n            key: \"getPageLabels\",\n            value: function getPageLabels() {\n              return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n            }\n          }, {\n            key: \"getPageLayout\",\n            value: function getPageLayout() {\n              return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n            }\n          }, {\n            key: \"getPageMode\",\n            value: function getPageMode() {\n              return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n            }\n          }, {\n            key: \"getViewerPreferences\",\n            value: function getViewerPreferences() {\n              return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n            }\n          }, {\n            key: \"getOpenAction\",\n            value: function getOpenAction() {\n              return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n            }\n          }, {\n            key: \"getAttachments\",\n            value: function getAttachments() {\n              return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n            }\n          }, {\n            key: \"getJavaScript\",\n            value: function getJavaScript() {\n              return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n            }\n          }, {\n            key: \"getDocJSActions\",\n            value: function getDocJSActions() {\n              return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\n            }\n          }, {\n            key: \"getPageJSActions\",\n            value: function getPageJSActions(pageIndex) {\n              return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n                pageIndex: pageIndex\n              });\n            }\n          }, {\n            key: \"getStructTree\",\n            value: function getStructTree(pageIndex) {\n              return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n                pageIndex: pageIndex\n              });\n            }\n          }, {\n            key: \"getOutline\",\n            value: function getOutline() {\n              return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n            }\n          }, {\n            key: \"getOptionalContentConfig\",\n            value: function getOptionalContentConfig() {\n              return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(function (results) {\n                return new _optional_content_config.OptionalContentConfig(results);\n              });\n            }\n          }, {\n            key: \"getPermissions\",\n            value: function getPermissions() {\n              return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n            }\n          }, {\n            key: \"getMetadata\",\n            value: function getMetadata() {\n              var _this19 = this;\n              var name = \"GetMetadata\",\n                cachedPromise = _classPrivateFieldGet(this, _methodPromises).get(name);\n              if (cachedPromise) {\n                return cachedPromise;\n              }\n              var promise = this.messageHandler.sendWithPromise(name, null).then(function (results) {\n                var _this19$_fullReader$f, _this19$_fullReader, _this19$_fullReader$c, _this19$_fullReader2;\n                return {\n                  info: results[0],\n                  metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n                  contentDispositionFilename: (_this19$_fullReader$f = (_this19$_fullReader = _this19._fullReader) === null || _this19$_fullReader === void 0 ? void 0 : _this19$_fullReader.filename) !== null && _this19$_fullReader$f !== void 0 ? _this19$_fullReader$f : null,\n                  contentLength: (_this19$_fullReader$c = (_this19$_fullReader2 = _this19._fullReader) === null || _this19$_fullReader2 === void 0 ? void 0 : _this19$_fullReader2.contentLength) !== null && _this19$_fullReader$c !== void 0 ? _this19$_fullReader$c : null\n                };\n              });\n              _classPrivateFieldGet(this, _methodPromises).set(name, promise);\n              return promise;\n            }\n          }, {\n            key: \"getMarkInfo\",\n            value: function getMarkInfo() {\n              return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n            }\n          }, {\n            key: \"startCleanup\",\n            value: function () {\n              var _startCleanup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                var keepLoadedFonts,\n                  _iterator13,\n                  _step13,\n                  page,\n                  cleanupSuccessful,\n                  _args4 = arguments;\n                return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      keepLoadedFonts = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : false;\n                      if (!this.destroyed) {\n                        _context4.next = 3;\n                        break;\n                      }\n                      return _context4.abrupt(\"return\");\n                    case 3:\n                      _context4.next = 5;\n                      return this.messageHandler.sendWithPromise(\"Cleanup\", null);\n                    case 5:\n                      _iterator13 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _pageCache).values());\n                      _context4.prev = 6;\n                      _iterator13.s();\n                    case 8:\n                      if ((_step13 = _iterator13.n()).done) {\n                        _context4.next = 15;\n                        break;\n                      }\n                      page = _step13.value;\n                      cleanupSuccessful = page.cleanup();\n                      if (cleanupSuccessful) {\n                        _context4.next = 13;\n                        break;\n                      }\n                      throw new Error(\"startCleanup: Page \".concat(page.pageNumber, \" is currently rendering.\"));\n                    case 13:\n                      _context4.next = 8;\n                      break;\n                    case 15:\n                      _context4.next = 20;\n                      break;\n                    case 17:\n                      _context4.prev = 17;\n                      _context4.t0 = _context4[\"catch\"](6);\n                      _iterator13.e(_context4.t0);\n                    case 20:\n                      _context4.prev = 20;\n                      _iterator13.f();\n                      return _context4.finish(20);\n                    case 23:\n                      this.commonObjs.clear();\n                      if (!keepLoadedFonts) {\n                        this.fontLoader.clear();\n                      }\n                      _classPrivateFieldGet(this, _methodPromises).clear();\n                      this.filterFactory.destroy(true);\n                    case 27:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _callee4, this, [[6, 17, 20, 23]]);\n              }));\n              function startCleanup() {\n                return _startCleanup.apply(this, arguments);\n              }\n              return startCleanup;\n            }()\n          }, {\n            key: \"loadingParams\",\n            get: function get() {\n              var _this$_params = this._params,\n                disableAutoFetch = _this$_params.disableAutoFetch,\n                enableXfa = _this$_params.enableXfa;\n              return (0, _util.shadow)(this, \"loadingParams\", {\n                disableAutoFetch: disableAutoFetch,\n                enableXfa: enableXfa\n              });\n            }\n          }]);\n          return WorkerTransport;\n        }();\n        function _cacheSimpleMethod2(name) {\n          var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          var cachedPromise = _classPrivateFieldGet(this, _methodPromises).get(name);\n          if (cachedPromise) {\n            return cachedPromise;\n          }\n          var promise = this.messageHandler.sendWithPromise(name, data);\n          _classPrivateFieldGet(this, _methodPromises).set(name, promise);\n          return promise;\n        }\n        var _objs = /*#__PURE__*/new WeakMap();\n        var _ensureObj = /*#__PURE__*/new WeakSet();\n        var PDFObjects = /*#__PURE__*/function () {\n          function PDFObjects() {\n            _classCallCheck(this, PDFObjects);\n            _classPrivateMethodInitSpec(this, _ensureObj);\n            _classPrivateFieldInitSpec(this, _objs, {\n              writable: true,\n              value: Object.create(null)\n            });\n          }\n          _createClass(PDFObjects, [{\n            key: \"get\",\n            value: function get(objId) {\n              var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n              if (callback) {\n                var _obj = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);\n                _obj.capability.promise.then(function () {\n                  return callback(_obj.data);\n                });\n                return null;\n              }\n              var obj = _classPrivateFieldGet(this, _objs)[objId];\n              if (!(obj !== null && obj !== void 0 && obj.capability.settled)) {\n                throw new Error(\"Requesting object that isn't resolved yet \".concat(objId, \".\"));\n              }\n              return obj.data;\n            }\n          }, {\n            key: \"has\",\n            value: function has(objId) {\n              var obj = _classPrivateFieldGet(this, _objs)[objId];\n              return (obj === null || obj === void 0 ? void 0 : obj.capability.settled) || false;\n            }\n          }, {\n            key: \"resolve\",\n            value: function resolve(objId) {\n              var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n              var obj = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);\n              obj.data = data;\n              obj.capability.resolve();\n            }\n          }, {\n            key: \"clear\",\n            value: function clear() {\n              for (var objId in _classPrivateFieldGet(this, _objs)) {\n                var _data$bitmap;\n                var data = _classPrivateFieldGet(this, _objs)[objId].data;\n                data === null || data === void 0 ? void 0 : (_data$bitmap = data.bitmap) === null || _data$bitmap === void 0 ? void 0 : _data$bitmap.close();\n              }\n              _classPrivateFieldSet(this, _objs, Object.create(null));\n            }\n          }]);\n          return PDFObjects;\n        }();\n        function _ensureObj2(objId) {\n          var obj = _classPrivateFieldGet(this, _objs)[objId];\n          if (obj) {\n            return obj;\n          }\n          return _classPrivateFieldGet(this, _objs)[objId] = {\n            capability: new _util.PromiseCapability(),\n            data: null\n          };\n        }\n        var _internalRenderTask = /*#__PURE__*/new WeakMap();\n        var RenderTask = /*#__PURE__*/function () {\n          function RenderTask(internalRenderTask) {\n            _classCallCheck(this, RenderTask);\n            _classPrivateFieldInitSpec(this, _internalRenderTask, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldSet(this, _internalRenderTask, internalRenderTask);\n            this.onContinue = null;\n          }\n          _createClass(RenderTask, [{\n            key: \"promise\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _internalRenderTask).capability.promise;\n            }\n          }, {\n            key: \"cancel\",\n            value: function cancel() {\n              var extraDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n              _classPrivateFieldGet(this, _internalRenderTask).cancel(null, extraDelay);\n            }\n          }, {\n            key: \"separateAnnots\",\n            get: function get() {\n              var separateAnnots = _classPrivateFieldGet(this, _internalRenderTask).operatorList.separateAnnots;\n              if (!separateAnnots) {\n                return false;\n              }\n              var _classPrivateFieldGet2 = _classPrivateFieldGet(this, _internalRenderTask),\n                annotationCanvasMap = _classPrivateFieldGet2.annotationCanvasMap;\n              return separateAnnots.form || separateAnnots.canvas && (annotationCanvasMap === null || annotationCanvasMap === void 0 ? void 0 : annotationCanvasMap.size) > 0;\n            }\n          }]);\n          return RenderTask;\n        }();\n        exports.RenderTask = RenderTask;\n        var InternalRenderTask = /*#__PURE__*/function () {\n          function InternalRenderTask(_ref23) {\n            var callback = _ref23.callback,\n              params = _ref23.params,\n              objs = _ref23.objs,\n              commonObjs = _ref23.commonObjs,\n              annotationCanvasMap = _ref23.annotationCanvasMap,\n              operatorList = _ref23.operatorList,\n              pageIndex = _ref23.pageIndex,\n              canvasFactory = _ref23.canvasFactory,\n              filterFactory = _ref23.filterFactory,\n              _ref23$useRequestAnim = _ref23.useRequestAnimationFrame,\n              useRequestAnimationFrame = _ref23$useRequestAnim === void 0 ? false : _ref23$useRequestAnim,\n              _ref23$pdfBug = _ref23.pdfBug,\n              pdfBug = _ref23$pdfBug === void 0 ? false : _ref23$pdfBug,\n              _ref23$pageColors = _ref23.pageColors,\n              pageColors = _ref23$pageColors === void 0 ? null : _ref23$pageColors;\n            _classCallCheck(this, InternalRenderTask);\n            this.callback = callback;\n            this.params = params;\n            this.objs = objs;\n            this.commonObjs = commonObjs;\n            this.annotationCanvasMap = annotationCanvasMap;\n            this.operatorListIdx = null;\n            this.operatorList = operatorList;\n            this._pageIndex = pageIndex;\n            this.canvasFactory = canvasFactory;\n            this.filterFactory = filterFactory;\n            this._pdfBug = pdfBug;\n            this.pageColors = pageColors;\n            this.running = false;\n            this.graphicsReadyCallback = null;\n            this.graphicsReady = false;\n            this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n            this.cancelled = false;\n            this.capability = new _util.PromiseCapability();\n            this.task = new RenderTask(this);\n            this._cancelBound = this.cancel.bind(this);\n            this._continueBound = this._continue.bind(this);\n            this._scheduleNextBound = this._scheduleNext.bind(this);\n            this._nextBound = this._next.bind(this);\n            this._canvas = params.canvasContext.canvas;\n          }\n          _createClass(InternalRenderTask, [{\n            key: \"completed\",\n            get: function get() {\n              return this.capability.promise.catch(function () {});\n            }\n          }, {\n            key: \"initializeGraphics\",\n            value: function initializeGraphics(_ref24) {\n              var _globalThis$StepperMa, _this$graphicsReadyCa;\n              var _ref24$transparency = _ref24.transparency,\n                transparency = _ref24$transparency === void 0 ? false : _ref24$transparency,\n                optionalContentConfig = _ref24.optionalContentConfig;\n              if (this.cancelled) {\n                return;\n              }\n              if (this._canvas) {\n                if (_classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).has(this._canvas)) {\n                  throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n                }\n                _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).add(this._canvas);\n              }\n              if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {\n                this.stepper = globalThis.StepperManager.create(this._pageIndex);\n                this.stepper.init(this.operatorList);\n                this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n              }\n              var _this$params = this.params,\n                canvasContext = _this$params.canvasContext,\n                viewport = _this$params.viewport,\n                transform = _this$params.transform,\n                background = _this$params.background;\n              this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                optionalContentConfig: optionalContentConfig\n              }, this.annotationCanvasMap, this.pageColors);\n              this.gfx.beginDrawing({\n                transform: transform,\n                viewport: viewport,\n                transparency: transparency,\n                background: background\n              });\n              this.operatorListIdx = 0;\n              this.graphicsReady = true;\n              (_this$graphicsReadyCa = this.graphicsReadyCallback) === null || _this$graphicsReadyCa === void 0 ? void 0 : _this$graphicsReadyCa.call(this);\n            }\n          }, {\n            key: \"cancel\",\n            value: function cancel() {\n              var _this$gfx;\n              var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n              var extraDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n              this.running = false;\n              this.cancelled = true;\n              (_this$gfx = this.gfx) === null || _this$gfx === void 0 ? void 0 : _this$gfx.endDrawing();\n              if (this._canvas) {\n                _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(this._canvas);\n              }\n              this.callback(error || new _display_utils.RenderingCancelledException(\"Rendering cancelled, page \".concat(this._pageIndex + 1), \"canvas\", extraDelay));\n            }\n          }, {\n            key: \"operatorListChanged\",\n            value: function operatorListChanged() {\n              var _this$stepper;\n              if (!this.graphicsReady) {\n                this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);\n                return;\n              }\n              (_this$stepper = this.stepper) === null || _this$stepper === void 0 ? void 0 : _this$stepper.updateOperatorList(this.operatorList);\n              if (this.running) {\n                return;\n              }\n              this._continue();\n            }\n          }, {\n            key: \"_continue\",\n            value: function _continue() {\n              this.running = true;\n              if (this.cancelled) {\n                return;\n              }\n              if (this.task.onContinue) {\n                this.task.onContinue(this._scheduleNextBound);\n              } else {\n                this._scheduleNext();\n              }\n            }\n          }, {\n            key: \"_scheduleNext\",\n            value: function _scheduleNext() {\n              var _this20 = this;\n              if (this._useRequestAnimationFrame) {\n                window.requestAnimationFrame(function () {\n                  _this20._nextBound().catch(_this20._cancelBound);\n                });\n              } else {\n                Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n              }\n            }\n          }, {\n            key: \"_next\",\n            value: function () {\n              var _next2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                  while (1) switch (_context5.prev = _context5.next) {\n                    case 0:\n                      if (!this.cancelled) {\n                        _context5.next = 2;\n                        break;\n                      }\n                      return _context5.abrupt(\"return\");\n                    case 2:\n                      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n                      if (this.operatorListIdx === this.operatorList.argsArray.length) {\n                        this.running = false;\n                        if (this.operatorList.lastChunk) {\n                          this.gfx.endDrawing(this.pageColors);\n                          if (this._canvas) {\n                            _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(this._canvas);\n                          }\n                          this.callback();\n                        }\n                      }\n                    case 4:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }, _callee5, this);\n              }));\n              function _next() {\n                return _next2.apply(this, arguments);\n              }\n              return _next;\n            }()\n          }]);\n          return InternalRenderTask;\n        }();\n        var _canvasInUse = {\n          writable: true,\n          value: new WeakSet()\n        };\n        var version = '3.6.172';\n        exports.version = version;\n        var build = '4d3dfe254';\n        exports.build = build;\n\n        /***/\n      }, /* 3 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.PrintAnnotationStorage = exports.AnnotationStorage = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _editor = __w_pdfjs_require__(4);\n        var _murmurhash = __w_pdfjs_require__(8);\n        var _modified = /*#__PURE__*/new WeakMap();\n        var _storage = /*#__PURE__*/new WeakMap();\n        var _setModified = /*#__PURE__*/new WeakSet();\n        var AnnotationStorage = /*#__PURE__*/function () {\n          function AnnotationStorage() {\n            _classCallCheck(this, AnnotationStorage);\n            _classPrivateMethodInitSpec(this, _setModified);\n            _classPrivateFieldInitSpec(this, _modified, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(this, _storage, {\n              writable: true,\n              value: new Map()\n            });\n            this.onSetModified = null;\n            this.onResetModified = null;\n            this.onAnnotationEditor = null;\n          }\n          _createClass(AnnotationStorage, [{\n            key: \"getValue\",\n            value: function getValue(key, defaultValue) {\n              var value = _classPrivateFieldGet(this, _storage).get(key);\n              if (value === undefined) {\n                return defaultValue;\n              }\n              return Object.assign(defaultValue, value);\n            }\n          }, {\n            key: \"getRawValue\",\n            value: function getRawValue(key) {\n              return _classPrivateFieldGet(this, _storage).get(key);\n            }\n          }, {\n            key: \"remove\",\n            value: function remove(key) {\n              _classPrivateFieldGet(this, _storage).delete(key);\n              if (_classPrivateFieldGet(this, _storage).size === 0) {\n                this.resetModified();\n              }\n              if (typeof this.onAnnotationEditor === \"function\") {\n                var _iterator15 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _storage).values()),\n                  _step15;\n                try {\n                  for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                    var value = _step15.value;\n                    if (value instanceof _editor.AnnotationEditor) {\n                      return;\n                    }\n                  }\n                } catch (err) {\n                  _iterator15.e(err);\n                } finally {\n                  _iterator15.f();\n                }\n                this.onAnnotationEditor(null);\n              }\n            }\n          }, {\n            key: \"setValue\",\n            value: function setValue(key, value) {\n              var obj = _classPrivateFieldGet(this, _storage).get(key);\n              var modified = false;\n              if (obj !== undefined) {\n                for (var _i = 0, _Object$entries = Object.entries(value); _i < _Object$entries.length; _i++) {\n                  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                    entry = _Object$entries$_i[0],\n                    val = _Object$entries$_i[1];\n                  if (obj[entry] !== val) {\n                    modified = true;\n                    obj[entry] = val;\n                  }\n                }\n              } else {\n                modified = true;\n                _classPrivateFieldGet(this, _storage).set(key, value);\n              }\n              if (modified) {\n                _classPrivateMethodGet(this, _setModified, _setModified2).call(this);\n              }\n              if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n                this.onAnnotationEditor(value.constructor._type);\n              }\n            }\n          }, {\n            key: \"has\",\n            value: function has(key) {\n              return _classPrivateFieldGet(this, _storage).has(key);\n            }\n          }, {\n            key: \"getAll\",\n            value: function getAll() {\n              return _classPrivateFieldGet(this, _storage).size > 0 ? (0, _util.objectFromMap)(_classPrivateFieldGet(this, _storage)) : null;\n            }\n          }, {\n            key: \"setAll\",\n            value: function setAll(obj) {\n              for (var _i2 = 0, _Object$entries2 = Object.entries(obj); _i2 < _Object$entries2.length; _i2++) {\n                var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n                  key = _Object$entries2$_i[0],\n                  val = _Object$entries2$_i[1];\n                this.setValue(key, val);\n              }\n            }\n          }, {\n            key: \"size\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _storage).size;\n            }\n          }, {\n            key: \"resetModified\",\n            value: function resetModified() {\n              if (_classPrivateFieldGet(this, _modified)) {\n                _classPrivateFieldSet(this, _modified, false);\n                if (typeof this.onResetModified === \"function\") {\n                  this.onResetModified();\n                }\n              }\n            }\n          }, {\n            key: \"print\",\n            get: function get() {\n              return new PrintAnnotationStorage(this);\n            }\n          }, {\n            key: \"serializable\",\n            get: function get() {\n              if (_classPrivateFieldGet(this, _storage).size === 0) {\n                return null;\n              }\n              var clone = new Map();\n              var _iterator16 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _storage)),\n                _step16;\n              try {\n                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                  var _step16$value = _slicedToArray(_step16.value, 2),\n                    key = _step16$value[0],\n                    val = _step16$value[1];\n                  var serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;\n                  if (serialized) {\n                    clone.set(key, serialized);\n                  }\n                }\n              } catch (err) {\n                _iterator16.e(err);\n              } finally {\n                _iterator16.f();\n              }\n              return clone;\n            }\n          }], [{\n            key: \"getHash\",\n            value: function getHash(map) {\n              if (!map) {\n                return \"\";\n              }\n              var hash = new _murmurhash.MurmurHash3_64();\n              var _iterator17 = _createForOfIteratorHelper(map),\n                _step17;\n              try {\n                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                  var _step17$value = _slicedToArray(_step17.value, 2),\n                    key = _step17$value[0],\n                    val = _step17$value[1];\n                  hash.update(\"\".concat(key, \":\").concat(JSON.stringify(val)));\n                }\n              } catch (err) {\n                _iterator17.e(err);\n              } finally {\n                _iterator17.f();\n              }\n              return hash.hexdigest();\n            }\n          }]);\n          return AnnotationStorage;\n        }();\n        function _setModified2() {\n          if (!_classPrivateFieldGet(this, _modified)) {\n            _classPrivateFieldSet(this, _modified, true);\n            if (typeof this.onSetModified === \"function\") {\n              this.onSetModified();\n            }\n          }\n        }\n        exports.AnnotationStorage = AnnotationStorage;\n        var _serializable = /*#__PURE__*/new WeakMap();\n        var PrintAnnotationStorage = /*#__PURE__*/function (_AnnotationStorage) {\n          _inherits(PrintAnnotationStorage, _AnnotationStorage);\n          var _super8 = _createSuper(PrintAnnotationStorage);\n          function PrintAnnotationStorage(parent) {\n            var _this22;\n            _classCallCheck(this, PrintAnnotationStorage);\n            _this22 = _super8.call(this);\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this22), _serializable, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldSet(_assertThisInitialized(_this22), _serializable, structuredClone(parent.serializable));\n            return _this22;\n          }\n          _createClass(PrintAnnotationStorage, [{\n            key: \"print\",\n            get: function get() {\n              (0, _util.unreachable)(\"Should not call PrintAnnotationStorage.print\");\n            }\n          }, {\n            key: \"serializable\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _serializable);\n            }\n          }]);\n          return PrintAnnotationStorage;\n        }(AnnotationStorage);\n        exports.PrintAnnotationStorage = PrintAnnotationStorage;\n\n        /***/\n      }, /* 4 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.AnnotationEditor = void 0;\n        var _tools = __w_pdfjs_require__(5);\n        var _util = __w_pdfjs_require__(1);\n        var _boundFocusin = /*#__PURE__*/new WeakMap();\n        var _boundFocusout = /*#__PURE__*/new WeakMap();\n        var _hasBeenSelected = /*#__PURE__*/new WeakMap();\n        var _isEditing = /*#__PURE__*/new WeakMap();\n        var _isInEditMode = /*#__PURE__*/new WeakMap();\n        var _zIndex = /*#__PURE__*/new WeakMap();\n        var AnnotationEditor = /*#__PURE__*/function () {\n          function AnnotationEditor(parameters) {\n            _classCallCheck(this, AnnotationEditor);\n            _classPrivateFieldInitSpec(this, _boundFocusin, {\n              writable: true,\n              value: this.focusin.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _boundFocusout, {\n              writable: true,\n              value: this.focusout.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _hasBeenSelected, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(this, _isEditing, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(this, _isInEditMode, {\n              writable: true,\n              value: false\n            });\n            _defineProperty(this, \"_uiManager\", null);\n            _classPrivateFieldInitSpec(this, _zIndex, {\n              writable: true,\n              value: AnnotationEditor._zIndex++\n            });\n            if (this.constructor === AnnotationEditor) {\n              (0, _util.unreachable)(\"Cannot initialize AnnotationEditor.\");\n            }\n            this.parent = parameters.parent;\n            this.id = parameters.id;\n            this.width = this.height = null;\n            this.pageIndex = parameters.parent.pageIndex;\n            this.name = parameters.name;\n            this.div = null;\n            this._uiManager = parameters.uiManager;\n            var _this$parent$viewport = this.parent.viewport,\n              rotation = _this$parent$viewport.rotation,\n              _this$parent$viewport2 = _this$parent$viewport.rawDims,\n              pageWidth = _this$parent$viewport2.pageWidth,\n              pageHeight = _this$parent$viewport2.pageHeight,\n              pageX = _this$parent$viewport2.pageX,\n              pageY = _this$parent$viewport2.pageY;\n            this.rotation = rotation;\n            this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n            this.pageDimensions = [pageWidth, pageHeight];\n            this.pageTranslation = [pageX, pageY];\n            var _this$parentDimension = _slicedToArray(this.parentDimensions, 2),\n              width = _this$parentDimension[0],\n              height = _this$parentDimension[1];\n            this.x = parameters.x / width;\n            this.y = parameters.y / height;\n            this.isAttachedToDOM = false;\n          }\n          _createClass(AnnotationEditor, [{\n            key: \"addCommands\",\n            value: function addCommands(params) {\n              this._uiManager.addCommands(params);\n            }\n          }, {\n            key: \"currentLayer\",\n            get: function get() {\n              return this._uiManager.currentLayer;\n            }\n          }, {\n            key: \"setInBackground\",\n            value: function setInBackground() {\n              this.div.style.zIndex = 0;\n            }\n          }, {\n            key: \"setInForeground\",\n            value: function setInForeground() {\n              this.div.style.zIndex = _classPrivateFieldGet(this, _zIndex);\n            }\n          }, {\n            key: \"setParent\",\n            value: function setParent(parent) {\n              if (parent !== null) {\n                this.pageIndex = parent.pageIndex;\n                this.pageDimensions = parent.pageDimensions;\n              }\n              this.parent = parent;\n            }\n          }, {\n            key: \"focusin\",\n            value: function focusin(event) {\n              if (!_classPrivateFieldGet(this, _hasBeenSelected)) {\n                this.parent.setSelected(this);\n              } else {\n                _classPrivateFieldSet(this, _hasBeenSelected, false);\n              }\n            }\n          }, {\n            key: \"focusout\",\n            value: function focusout(event) {\n              var _this$parent;\n              if (!this.isAttachedToDOM) {\n                return;\n              }\n              var target = event.relatedTarget;\n              if (target !== null && target !== void 0 && target.closest(\"#\".concat(this.id))) {\n                return;\n              }\n              event.preventDefault();\n              if (!((_this$parent = this.parent) !== null && _this$parent !== void 0 && _this$parent.isMultipleSelection)) {\n                this.commitOrRemove();\n              }\n            }\n          }, {\n            key: \"commitOrRemove\",\n            value: function commitOrRemove() {\n              if (this.isEmpty()) {\n                this.remove();\n              } else {\n                this.commit();\n              }\n            }\n          }, {\n            key: \"commit\",\n            value: function commit() {\n              this.addToAnnotationStorage();\n            }\n          }, {\n            key: \"addToAnnotationStorage\",\n            value: function addToAnnotationStorage() {\n              this._uiManager.addToAnnotationStorage(this);\n            }\n          }, {\n            key: \"dragstart\",\n            value: function dragstart(event) {\n              var rect = this.parent.div.getBoundingClientRect();\n              this.startX = event.clientX - rect.x;\n              this.startY = event.clientY - rect.y;\n              event.dataTransfer.setData(\"text/plain\", this.id);\n              event.dataTransfer.effectAllowed = \"move\";\n            }\n          }, {\n            key: \"setAt\",\n            value: function setAt(x, y, tx, ty) {\n              var _this$parentDimension2 = _slicedToArray(this.parentDimensions, 2),\n                width = _this$parentDimension2[0],\n                height = _this$parentDimension2[1];\n              var _this$screenToPageTra = this.screenToPageTranslation(tx, ty);\n              var _this$screenToPageTra2 = _slicedToArray(_this$screenToPageTra, 2);\n              tx = _this$screenToPageTra2[0];\n              ty = _this$screenToPageTra2[1];\n              this.x = (x + tx) / width;\n              this.y = (y + ty) / height;\n              this.div.style.left = \"\".concat(100 * this.x, \"%\");\n              this.div.style.top = \"\".concat(100 * this.y, \"%\");\n            }\n          }, {\n            key: \"translate\",\n            value: function translate(x, y) {\n              var _this$parentDimension3 = _slicedToArray(this.parentDimensions, 2),\n                width = _this$parentDimension3[0],\n                height = _this$parentDimension3[1];\n              var _this$screenToPageTra3 = this.screenToPageTranslation(x, y);\n              var _this$screenToPageTra4 = _slicedToArray(_this$screenToPageTra3, 2);\n              x = _this$screenToPageTra4[0];\n              y = _this$screenToPageTra4[1];\n              this.x += x / width;\n              this.y += y / height;\n              this.div.style.left = \"\".concat(100 * this.x, \"%\");\n              this.div.style.top = \"\".concat(100 * this.y, \"%\");\n            }\n          }, {\n            key: \"screenToPageTranslation\",\n            value: function screenToPageTranslation(x, y) {\n              switch (this.parentRotation) {\n                case 90:\n                  return [y, -x];\n                case 180:\n                  return [-x, -y];\n                case 270:\n                  return [-y, x];\n                default:\n                  return [x, y];\n              }\n            }\n          }, {\n            key: \"parentScale\",\n            get: function get() {\n              return this._uiManager.viewParameters.realScale;\n            }\n          }, {\n            key: \"parentRotation\",\n            get: function get() {\n              return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n            }\n          }, {\n            key: \"parentDimensions\",\n            get: function get() {\n              var realScale = this._uiManager.viewParameters.realScale;\n              var _this$pageDimensions = _slicedToArray(this.pageDimensions, 2),\n                pageWidth = _this$pageDimensions[0],\n                pageHeight = _this$pageDimensions[1];\n              return [pageWidth * realScale, pageHeight * realScale];\n            }\n          }, {\n            key: \"setDims\",\n            value: function setDims(width, height) {\n              var _this$parentDimension4 = _slicedToArray(this.parentDimensions, 2),\n                parentWidth = _this$parentDimension4[0],\n                parentHeight = _this$parentDimension4[1];\n              this.div.style.width = \"\".concat(100 * width / parentWidth, \"%\");\n              this.div.style.height = \"\".concat(100 * height / parentHeight, \"%\");\n            }\n          }, {\n            key: \"fixDims\",\n            value: function fixDims() {\n              var style = this.div.style;\n              var height = style.height,\n                width = style.width;\n              var widthPercent = width.endsWith(\"%\");\n              var heightPercent = height.endsWith(\"%\");\n              if (widthPercent && heightPercent) {\n                return;\n              }\n              var _this$parentDimension5 = _slicedToArray(this.parentDimensions, 2),\n                parentWidth = _this$parentDimension5[0],\n                parentHeight = _this$parentDimension5[1];\n              if (!widthPercent) {\n                style.width = \"\".concat(100 * parseFloat(width) / parentWidth, \"%\");\n              }\n              if (!heightPercent) {\n                style.height = \"\".concat(100 * parseFloat(height) / parentHeight, \"%\");\n              }\n            }\n          }, {\n            key: \"getInitialTranslation\",\n            value: function getInitialTranslation() {\n              return [0, 0];\n            }\n          }, {\n            key: \"render\",\n            value: function render() {\n              this.div = document.createElement(\"div\");\n              this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n              this.div.className = this.name;\n              this.div.setAttribute(\"id\", this.id);\n              this.div.setAttribute(\"tabIndex\", 0);\n              this.setInForeground();\n              this.div.addEventListener(\"focusin\", _classPrivateFieldGet(this, _boundFocusin));\n              this.div.addEventListener(\"focusout\", _classPrivateFieldGet(this, _boundFocusout));\n              var _this$getInitialTrans = this.getInitialTranslation(),\n                _this$getInitialTrans2 = _slicedToArray(_this$getInitialTrans, 2),\n                tx = _this$getInitialTrans2[0],\n                ty = _this$getInitialTrans2[1];\n              this.translate(tx, ty);\n              (0, _tools.bindEvents)(this, this.div, [\"dragstart\", \"pointerdown\"]);\n              return this.div;\n            }\n          }, {\n            key: \"pointerdown\",\n            value: function pointerdown(event) {\n              var isMac = _util.FeatureTest.platform.isMac;\n              if (event.button !== 0 || event.ctrlKey && isMac) {\n                event.preventDefault();\n                return;\n              }\n              if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n                this.parent.toggleSelected(this);\n              } else {\n                this.parent.setSelected(this);\n              }\n              _classPrivateFieldSet(this, _hasBeenSelected, true);\n            }\n          }, {\n            key: \"getRect\",\n            value: function getRect(tx, ty) {\n              var scale = this.parentScale;\n              var _this$pageDimensions2 = _slicedToArray(this.pageDimensions, 2),\n                pageWidth = _this$pageDimensions2[0],\n                pageHeight = _this$pageDimensions2[1];\n              var _this$pageTranslation = _slicedToArray(this.pageTranslation, 2),\n                pageX = _this$pageTranslation[0],\n                pageY = _this$pageTranslation[1];\n              var shiftX = tx / scale;\n              var shiftY = ty / scale;\n              var x = this.x * pageWidth;\n              var y = this.y * pageHeight;\n              var width = this.width * pageWidth;\n              var height = this.height * pageHeight;\n              switch (this.rotation) {\n                case 0:\n                  return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];\n                case 90:\n                  return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];\n                case 180:\n                  return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];\n                case 270:\n                  return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];\n                default:\n                  throw new Error(\"Invalid rotation\");\n              }\n            }\n          }, {\n            key: \"getRectInCurrentCoords\",\n            value: function getRectInCurrentCoords(rect, pageHeight) {\n              var _rect = _slicedToArray(rect, 4),\n                x1 = _rect[0],\n                y1 = _rect[1],\n                x2 = _rect[2],\n                y2 = _rect[3];\n              var width = x2 - x1;\n              var height = y2 - y1;\n              switch (this.rotation) {\n                case 0:\n                  return [x1, pageHeight - y2, width, height];\n                case 90:\n                  return [x1, pageHeight - y1, height, width];\n                case 180:\n                  return [x2, pageHeight - y1, width, height];\n                case 270:\n                  return [x2, pageHeight - y2, height, width];\n                default:\n                  throw new Error(\"Invalid rotation\");\n              }\n            }\n          }, {\n            key: \"onceAdded\",\n            value: function onceAdded() {}\n          }, {\n            key: \"isEmpty\",\n            value: function isEmpty() {\n              return false;\n            }\n          }, {\n            key: \"enableEditMode\",\n            value: function enableEditMode() {\n              _classPrivateFieldSet(this, _isInEditMode, true);\n            }\n          }, {\n            key: \"disableEditMode\",\n            value: function disableEditMode() {\n              _classPrivateFieldSet(this, _isInEditMode, false);\n            }\n          }, {\n            key: \"isInEditMode\",\n            value: function isInEditMode() {\n              return _classPrivateFieldGet(this, _isInEditMode);\n            }\n          }, {\n            key: \"shouldGetKeyboardEvents\",\n            value: function shouldGetKeyboardEvents() {\n              return false;\n            }\n          }, {\n            key: \"needsToBeRebuilt\",\n            value: function needsToBeRebuilt() {\n              return this.div && !this.isAttachedToDOM;\n            }\n          }, {\n            key: \"rebuild\",\n            value: function rebuild() {\n              var _this$div;\n              (_this$div = this.div) === null || _this$div === void 0 ? void 0 : _this$div.addEventListener(\"focusin\", _classPrivateFieldGet(this, _boundFocusin));\n            }\n          }, {\n            key: \"serialize\",\n            value: function serialize() {\n              (0, _util.unreachable)(\"An editor must be serializable\");\n            }\n          }, {\n            key: \"remove\",\n            value: function remove() {\n              this.div.removeEventListener(\"focusin\", _classPrivateFieldGet(this, _boundFocusin));\n              this.div.removeEventListener(\"focusout\", _classPrivateFieldGet(this, _boundFocusout));\n              if (!this.isEmpty()) {\n                this.commit();\n              }\n              this.parent.remove(this);\n            }\n          }, {\n            key: \"select\",\n            value: function select() {\n              var _this$div2;\n              (_this$div2 = this.div) === null || _this$div2 === void 0 ? void 0 : _this$div2.classList.add(\"selectedEditor\");\n            }\n          }, {\n            key: \"unselect\",\n            value: function unselect() {\n              var _this$div3;\n              (_this$div3 = this.div) === null || _this$div3 === void 0 ? void 0 : _this$div3.classList.remove(\"selectedEditor\");\n            }\n          }, {\n            key: \"updateParams\",\n            value: function updateParams(type, value) {}\n          }, {\n            key: \"disableEditing\",\n            value: function disableEditing() {}\n          }, {\n            key: \"enableEditing\",\n            value: function enableEditing() {}\n          }, {\n            key: \"propertiesToUpdate\",\n            get: function get() {\n              return {};\n            }\n          }, {\n            key: \"contentDiv\",\n            get: function get() {\n              return this.div;\n            }\n          }, {\n            key: \"isEditing\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _isEditing);\n            },\n            set: function set(value) {\n              _classPrivateFieldSet(this, _isEditing, value);\n              if (value) {\n                this.parent.setSelected(this);\n                this.parent.setActiveEditor(this);\n              } else {\n                this.parent.setActiveEditor(null);\n              }\n            }\n          }], [{\n            key: \"_defaultLineColor\",\n            get: function get() {\n              return (0, _util.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n            }\n          }, {\n            key: \"deserialize\",\n            value: function deserialize(data, parent, uiManager) {\n              var editor = new this.prototype.constructor({\n                parent: parent,\n                id: parent.getNextId(),\n                uiManager: uiManager\n              });\n              editor.rotation = data.rotation;\n              var _editor$pageDimension = _slicedToArray(editor.pageDimensions, 2),\n                pageWidth = _editor$pageDimension[0],\n                pageHeight = _editor$pageDimension[1];\n              var _editor$getRectInCurr = editor.getRectInCurrentCoords(data.rect, pageHeight),\n                _editor$getRectInCurr2 = _slicedToArray(_editor$getRectInCurr, 4),\n                x = _editor$getRectInCurr2[0],\n                y = _editor$getRectInCurr2[1],\n                width = _editor$getRectInCurr2[2],\n                height = _editor$getRectInCurr2[3];\n              editor.x = x / pageWidth;\n              editor.y = y / pageHeight;\n              editor.width = width / pageWidth;\n              editor.height = height / pageHeight;\n              return editor;\n            }\n          }]);\n          return AnnotationEditor;\n        }();\n        _defineProperty(AnnotationEditor, \"_colorManager\", new _tools.ColorManager());\n        _defineProperty(AnnotationEditor, \"_zIndex\", 1);\n        exports.AnnotationEditor = AnnotationEditor;\n\n        /***/\n      }, /* 5 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0;\n        exports.bindEvents = bindEvents;\n        exports.opacityToHex = opacityToHex;\n        var _util = __w_pdfjs_require__(1);\n        var _display_utils = __w_pdfjs_require__(6);\n        function bindEvents(obj, element, names) {\n          var _iterator18 = _createForOfIteratorHelper(names),\n            _step18;\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var name = _step18.value;\n              element.addEventListener(name, obj[name].bind(obj));\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n        }\n        function opacityToHex(opacity) {\n          return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n        }\n        var _id = /*#__PURE__*/new WeakMap();\n        var IdManager = /*#__PURE__*/function () {\n          function IdManager() {\n            _classCallCheck(this, IdManager);\n            _classPrivateFieldInitSpec(this, _id, {\n              writable: true,\n              value: 0\n            });\n          }\n          _createClass(IdManager, [{\n            key: \"getId\",\n            value: function getId() {\n              var _this$id, _this$id2;\n              return \"\".concat(_util.AnnotationEditorPrefix).concat((_classPrivateFieldSet(this, _id, (_this$id = _classPrivateFieldGet(this, _id), _this$id2 = _this$id++, _this$id)), _this$id2));\n            }\n          }]);\n          return IdManager;\n        }();\n        var _commands = /*#__PURE__*/new WeakMap();\n        var _locked = /*#__PURE__*/new WeakMap();\n        var _maxSize = /*#__PURE__*/new WeakMap();\n        var _position = /*#__PURE__*/new WeakMap();\n        var CommandManager = /*#__PURE__*/function () {\n          function CommandManager() {\n            var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;\n            _classCallCheck(this, CommandManager);\n            _classPrivateFieldInitSpec(this, _commands, {\n              writable: true,\n              value: []\n            });\n            _classPrivateFieldInitSpec(this, _locked, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(this, _maxSize, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(this, _position, {\n              writable: true,\n              value: -1\n            });\n            _classPrivateFieldSet(this, _maxSize, maxSize);\n          }\n          _createClass(CommandManager, [{\n            key: \"add\",\n            value: function add(_ref25) {\n              var cmd = _ref25.cmd,\n                undo = _ref25.undo,\n                mustExec = _ref25.mustExec,\n                _ref25$type = _ref25.type,\n                type = _ref25$type === void 0 ? NaN : _ref25$type,\n                _ref25$overwriteIfSam = _ref25.overwriteIfSameType,\n                overwriteIfSameType = _ref25$overwriteIfSam === void 0 ? false : _ref25$overwriteIfSam,\n                _ref25$keepUndo = _ref25.keepUndo,\n                keepUndo = _ref25$keepUndo === void 0 ? false : _ref25$keepUndo;\n              if (mustExec) {\n                cmd();\n              }\n              if (_classPrivateFieldGet(this, _locked)) {\n                return;\n              }\n              var save = {\n                cmd: cmd,\n                undo: undo,\n                type: type\n              };\n              if (_classPrivateFieldGet(this, _position) === -1) {\n                if (_classPrivateFieldGet(this, _commands).length > 0) {\n                  _classPrivateFieldGet(this, _commands).length = 0;\n                }\n                _classPrivateFieldSet(this, _position, 0);\n                _classPrivateFieldGet(this, _commands).push(save);\n                return;\n              }\n              if (overwriteIfSameType && _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)].type === type) {\n                if (keepUndo) {\n                  save.undo = _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)].undo;\n                }\n                _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)] = save;\n                return;\n              }\n              var next = _classPrivateFieldGet(this, _position) + 1;\n              if (next === _classPrivateFieldGet(this, _maxSize)) {\n                _classPrivateFieldGet(this, _commands).splice(0, 1);\n              } else {\n                _classPrivateFieldSet(this, _position, next);\n                if (next < _classPrivateFieldGet(this, _commands).length) {\n                  _classPrivateFieldGet(this, _commands).splice(next);\n                }\n              }\n              _classPrivateFieldGet(this, _commands).push(save);\n            }\n          }, {\n            key: \"undo\",\n            value: function undo() {\n              if (_classPrivateFieldGet(this, _position) === -1) {\n                return;\n              }\n              _classPrivateFieldSet(this, _locked, true);\n              _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)].undo();\n              _classPrivateFieldSet(this, _locked, false);\n              _classPrivateFieldSet(this, _position, _classPrivateFieldGet(this, _position) - 1);\n            }\n          }, {\n            key: \"redo\",\n            value: function redo() {\n              if (_classPrivateFieldGet(this, _position) < _classPrivateFieldGet(this, _commands).length - 1) {\n                _classPrivateFieldSet(this, _position, _classPrivateFieldGet(this, _position) + 1);\n                _classPrivateFieldSet(this, _locked, true);\n                _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)].cmd();\n                _classPrivateFieldSet(this, _locked, false);\n              }\n            }\n          }, {\n            key: \"hasSomethingToUndo\",\n            value: function hasSomethingToUndo() {\n              return _classPrivateFieldGet(this, _position) !== -1;\n            }\n          }, {\n            key: \"hasSomethingToRedo\",\n            value: function hasSomethingToRedo() {\n              return _classPrivateFieldGet(this, _position) < _classPrivateFieldGet(this, _commands).length - 1;\n            }\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              _classPrivateFieldSet(this, _commands, null);\n            }\n          }]);\n          return CommandManager;\n        }();\n        exports.CommandManager = CommandManager;\n        var _serialize = /*#__PURE__*/new WeakSet();\n        var KeyboardManager = /*#__PURE__*/function () {\n          function KeyboardManager(callbacks) {\n            _classCallCheck(this, KeyboardManager);\n            _classPrivateMethodInitSpec(this, _serialize);\n            this.buffer = [];\n            this.callbacks = new Map();\n            this.allKeys = new Set();\n            var isMac = _util.FeatureTest.platform.isMac;\n            var _iterator19 = _createForOfIteratorHelper(callbacks),\n              _step19;\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var _step19$value = _slicedToArray(_step19.value, 2),\n                  keys = _step19$value[0],\n                  callback = _step19$value[1];\n                var _iterator20 = _createForOfIteratorHelper(keys),\n                  _step20;\n                try {\n                  for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                    var key = _step20.value;\n                    var isMacKey = key.startsWith(\"mac+\");\n                    if (isMac && isMacKey) {\n                      this.callbacks.set(key.slice(4), callback);\n                      this.allKeys.add(key.split(\"+\").at(-1));\n                    } else if (!isMac && !isMacKey) {\n                      this.callbacks.set(key, callback);\n                      this.allKeys.add(key.split(\"+\").at(-1));\n                    }\n                  }\n                } catch (err) {\n                  _iterator20.e(err);\n                } finally {\n                  _iterator20.f();\n                }\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n          }\n          _createClass(KeyboardManager, [{\n            key: \"exec\",\n            value: function exec(self, event) {\n              if (!this.allKeys.has(event.key)) {\n                return;\n              }\n              var callback = this.callbacks.get(_classPrivateMethodGet(this, _serialize, _serialize2).call(this, event));\n              if (!callback) {\n                return;\n              }\n              callback.bind(self)();\n              event.stopPropagation();\n              event.preventDefault();\n            }\n          }]);\n          return KeyboardManager;\n        }();\n        function _serialize2(event) {\n          if (event.altKey) {\n            this.buffer.push(\"alt\");\n          }\n          if (event.ctrlKey) {\n            this.buffer.push(\"ctrl\");\n          }\n          if (event.metaKey) {\n            this.buffer.push(\"meta\");\n          }\n          if (event.shiftKey) {\n            this.buffer.push(\"shift\");\n          }\n          this.buffer.push(event.key);\n          var str = this.buffer.join(\"+\");\n          this.buffer.length = 0;\n          return str;\n        }\n        exports.KeyboardManager = KeyboardManager;\n        var ColorManager = /*#__PURE__*/function () {\n          function ColorManager() {\n            _classCallCheck(this, ColorManager);\n          }\n          _createClass(ColorManager, [{\n            key: \"_colors\",\n            get: function get() {\n              var colors = new Map([[\"CanvasText\", null], [\"Canvas\", null]]);\n              (0, _display_utils.getColorValues)(colors);\n              return (0, _util.shadow)(this, \"_colors\", colors);\n            }\n          }, {\n            key: \"convert\",\n            value: function convert(color) {\n              var rgb = (0, _display_utils.getRGB)(color);\n              if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n                return rgb;\n              }\n              var _iterator21 = _createForOfIteratorHelper(this._colors),\n                _step21;\n              try {\n                for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                  var _step21$value = _slicedToArray(_step21.value, 2),\n                    name = _step21$value[0],\n                    RGB = _step21$value[1];\n                  if (RGB.every(function (x, i) {\n                    return x === rgb[i];\n                  })) {\n                    return ColorManager._colorsMapping.get(name);\n                  }\n                }\n              } catch (err) {\n                _iterator21.e(err);\n              } finally {\n                _iterator21.f();\n              }\n              return rgb;\n            }\n          }, {\n            key: \"getHexCode\",\n            value: function getHexCode(name) {\n              var _util$Util;\n              var rgb = this._colors.get(name);\n              if (!rgb) {\n                return name;\n              }\n              return (_util$Util = _util.Util).makeHexColor.apply(_util$Util, _toConsumableArray(rgb));\n            }\n          }]);\n          return ColorManager;\n        }();\n        _defineProperty(ColorManager, \"_colorsMapping\", new Map([[\"CanvasText\", [0, 0, 0]], [\"Canvas\", [255, 255, 255]]]));\n        exports.ColorManager = ColorManager;\n        var _activeEditor = /*#__PURE__*/new WeakMap();\n        var _allEditors = /*#__PURE__*/new WeakMap();\n        var _allLayers = /*#__PURE__*/new WeakMap();\n        var _annotationStorage = /*#__PURE__*/new WeakMap();\n        var _commandManager = /*#__PURE__*/new WeakMap();\n        var _currentPageIndex = /*#__PURE__*/new WeakMap();\n        var _editorTypes = /*#__PURE__*/new WeakMap();\n        var _editorsToRescale = /*#__PURE__*/new WeakMap();\n        var _eventBus = /*#__PURE__*/new WeakMap();\n        var _idManager = /*#__PURE__*/new WeakMap();\n        var _isEnabled = /*#__PURE__*/new WeakMap();\n        var _mode = /*#__PURE__*/new WeakMap();\n        var _selectedEditors = /*#__PURE__*/new WeakMap();\n        var _boundCopy = /*#__PURE__*/new WeakMap();\n        var _boundCut = /*#__PURE__*/new WeakMap();\n        var _boundPaste = /*#__PURE__*/new WeakMap();\n        var _boundKeydown = /*#__PURE__*/new WeakMap();\n        var _boundOnEditingAction = /*#__PURE__*/new WeakMap();\n        var _boundOnPageChanging = /*#__PURE__*/new WeakMap();\n        var _boundOnScaleChanging = /*#__PURE__*/new WeakMap();\n        var _boundOnRotationChanging = /*#__PURE__*/new WeakMap();\n        var _previousStates = /*#__PURE__*/new WeakMap();\n        var _container = /*#__PURE__*/new WeakMap();\n        var _addKeyboardManager = /*#__PURE__*/new WeakSet();\n        var _removeKeyboardManager = /*#__PURE__*/new WeakSet();\n        var _addCopyPasteListeners = /*#__PURE__*/new WeakSet();\n        var _removeCopyPasteListeners = /*#__PURE__*/new WeakSet();\n        var _dispatchUpdateStates = /*#__PURE__*/new WeakSet();\n        var _dispatchUpdateUI = /*#__PURE__*/new WeakSet();\n        var _enableAll = /*#__PURE__*/new WeakSet();\n        var _disableAll = /*#__PURE__*/new WeakSet();\n        var _addEditorToLayer = /*#__PURE__*/new WeakSet();\n        var _isEmpty = /*#__PURE__*/new WeakSet();\n        var _selectEditors = /*#__PURE__*/new WeakSet();\n        var AnnotationEditorUIManager = /*#__PURE__*/function () {\n          function AnnotationEditorUIManager(container, eventBus, annotationStorage) {\n            _classCallCheck(this, AnnotationEditorUIManager);\n            _classPrivateMethodInitSpec(this, _selectEditors);\n            _classPrivateMethodInitSpec(this, _isEmpty);\n            _classPrivateMethodInitSpec(this, _addEditorToLayer);\n            _classPrivateMethodInitSpec(this, _disableAll);\n            _classPrivateMethodInitSpec(this, _enableAll);\n            _classPrivateMethodInitSpec(this, _dispatchUpdateUI);\n            _classPrivateMethodInitSpec(this, _dispatchUpdateStates);\n            _classPrivateMethodInitSpec(this, _removeCopyPasteListeners);\n            _classPrivateMethodInitSpec(this, _addCopyPasteListeners);\n            _classPrivateMethodInitSpec(this, _removeKeyboardManager);\n            _classPrivateMethodInitSpec(this, _addKeyboardManager);\n            _classPrivateFieldInitSpec(this, _activeEditor, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldInitSpec(this, _allEditors, {\n              writable: true,\n              value: new Map()\n            });\n            _classPrivateFieldInitSpec(this, _allLayers, {\n              writable: true,\n              value: new Map()\n            });\n            _classPrivateFieldInitSpec(this, _annotationStorage, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldInitSpec(this, _commandManager, {\n              writable: true,\n              value: new CommandManager()\n            });\n            _classPrivateFieldInitSpec(this, _currentPageIndex, {\n              writable: true,\n              value: 0\n            });\n            _classPrivateFieldInitSpec(this, _editorTypes, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldInitSpec(this, _editorsToRescale, {\n              writable: true,\n              value: new Set()\n            });\n            _classPrivateFieldInitSpec(this, _eventBus, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldInitSpec(this, _idManager, {\n              writable: true,\n              value: new IdManager()\n            });\n            _classPrivateFieldInitSpec(this, _isEnabled, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(this, _mode, {\n              writable: true,\n              value: _util.AnnotationEditorType.NONE\n            });\n            _classPrivateFieldInitSpec(this, _selectedEditors, {\n              writable: true,\n              value: new Set()\n            });\n            _classPrivateFieldInitSpec(this, _boundCopy, {\n              writable: true,\n              value: this.copy.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _boundCut, {\n              writable: true,\n              value: this.cut.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _boundPaste, {\n              writable: true,\n              value: this.paste.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _boundKeydown, {\n              writable: true,\n              value: this.keydown.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _boundOnEditingAction, {\n              writable: true,\n              value: this.onEditingAction.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _boundOnPageChanging, {\n              writable: true,\n              value: this.onPageChanging.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _boundOnScaleChanging, {\n              writable: true,\n              value: this.onScaleChanging.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _boundOnRotationChanging, {\n              writable: true,\n              value: this.onRotationChanging.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _previousStates, {\n              writable: true,\n              value: {\n                isEditing: false,\n                isEmpty: true,\n                hasSomethingToUndo: false,\n                hasSomethingToRedo: false,\n                hasSelectedEditor: false\n              }\n            });\n            _classPrivateFieldInitSpec(this, _container, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldSet(this, _container, container);\n            _classPrivateFieldSet(this, _eventBus, eventBus);\n            _classPrivateFieldGet(this, _eventBus)._on(\"editingaction\", _classPrivateFieldGet(this, _boundOnEditingAction));\n            _classPrivateFieldGet(this, _eventBus)._on(\"pagechanging\", _classPrivateFieldGet(this, _boundOnPageChanging));\n            _classPrivateFieldGet(this, _eventBus)._on(\"scalechanging\", _classPrivateFieldGet(this, _boundOnScaleChanging));\n            _classPrivateFieldGet(this, _eventBus)._on(\"rotationchanging\", _classPrivateFieldGet(this, _boundOnRotationChanging));\n            _classPrivateFieldSet(this, _annotationStorage, annotationStorage);\n            this.viewParameters = {\n              realScale: _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS,\n              rotation: 0\n            };\n          }\n          _createClass(AnnotationEditorUIManager, [{\n            key: \"destroy\",\n            value: function destroy() {\n              _classPrivateMethodGet(this, _removeKeyboardManager, _removeKeyboardManager2).call(this);\n              _classPrivateFieldGet(this, _eventBus)._off(\"editingaction\", _classPrivateFieldGet(this, _boundOnEditingAction));\n              _classPrivateFieldGet(this, _eventBus)._off(\"pagechanging\", _classPrivateFieldGet(this, _boundOnPageChanging));\n              _classPrivateFieldGet(this, _eventBus)._off(\"scalechanging\", _classPrivateFieldGet(this, _boundOnScaleChanging));\n              _classPrivateFieldGet(this, _eventBus)._off(\"rotationchanging\", _classPrivateFieldGet(this, _boundOnRotationChanging));\n              var _iterator22 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _allLayers).values()),\n                _step22;\n              try {\n                for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                  var layer = _step22.value;\n                  layer.destroy();\n                }\n              } catch (err) {\n                _iterator22.e(err);\n              } finally {\n                _iterator22.f();\n              }\n              _classPrivateFieldGet(this, _allLayers).clear();\n              _classPrivateFieldGet(this, _allEditors).clear();\n              _classPrivateFieldGet(this, _editorsToRescale).clear();\n              _classPrivateFieldSet(this, _activeEditor, null);\n              _classPrivateFieldGet(this, _selectedEditors).clear();\n              _classPrivateFieldGet(this, _commandManager).destroy();\n            }\n          }, {\n            key: \"onPageChanging\",\n            value: function onPageChanging(_ref26) {\n              var pageNumber = _ref26.pageNumber;\n              _classPrivateFieldSet(this, _currentPageIndex, pageNumber - 1);\n            }\n          }, {\n            key: \"focusMainContainer\",\n            value: function focusMainContainer() {\n              _classPrivateFieldGet(this, _container).focus();\n            }\n          }, {\n            key: \"addShouldRescale\",\n            value: function addShouldRescale(editor) {\n              _classPrivateFieldGet(this, _editorsToRescale).add(editor);\n            }\n          }, {\n            key: \"removeShouldRescale\",\n            value: function removeShouldRescale(editor) {\n              _classPrivateFieldGet(this, _editorsToRescale).delete(editor);\n            }\n          }, {\n            key: \"onScaleChanging\",\n            value: function onScaleChanging(_ref27) {\n              var scale = _ref27.scale;\n              this.commitOrRemove();\n              this.viewParameters.realScale = scale * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS;\n              var _iterator23 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _editorsToRescale)),\n                _step23;\n              try {\n                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                  var editor = _step23.value;\n                  editor.onScaleChanging();\n                }\n              } catch (err) {\n                _iterator23.e(err);\n              } finally {\n                _iterator23.f();\n              }\n            }\n          }, {\n            key: \"onRotationChanging\",\n            value: function onRotationChanging(_ref28) {\n              var pagesRotation = _ref28.pagesRotation;\n              this.commitOrRemove();\n              this.viewParameters.rotation = pagesRotation;\n            }\n          }, {\n            key: \"addToAnnotationStorage\",\n            value: function addToAnnotationStorage(editor) {\n              if (!editor.isEmpty() && _classPrivateFieldGet(this, _annotationStorage) && !_classPrivateFieldGet(this, _annotationStorage).has(editor.id)) {\n                _classPrivateFieldGet(this, _annotationStorage).setValue(editor.id, editor);\n              }\n            }\n          }, {\n            key: \"copy\",\n            value: function copy(event) {\n              event.preventDefault();\n              if (_classPrivateFieldGet(this, _activeEditor)) {\n                _classPrivateFieldGet(this, _activeEditor).commitOrRemove();\n              }\n              if (!this.hasSelection) {\n                return;\n              }\n              var editors = [];\n              var _iterator24 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _selectedEditors)),\n                _step24;\n              try {\n                for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                  var editor = _step24.value;\n                  if (!editor.isEmpty()) {\n                    editors.push(editor.serialize());\n                  }\n                }\n              } catch (err) {\n                _iterator24.e(err);\n              } finally {\n                _iterator24.f();\n              }\n              if (editors.length === 0) {\n                return;\n              }\n              event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n            }\n          }, {\n            key: \"cut\",\n            value: function cut(event) {\n              this.copy(event);\n              this.delete();\n            }\n          }, {\n            key: \"paste\",\n            value: function paste(event) {\n              var _this23 = this;\n              event.preventDefault();\n              var data = event.clipboardData.getData(\"application/pdfjs\");\n              if (!data) {\n                return;\n              }\n              try {\n                data = JSON.parse(data);\n              } catch (ex) {\n                (0, _util.warn)(\"paste: \\\"\".concat(ex.message, \"\\\".\"));\n                return;\n              }\n              if (!Array.isArray(data)) {\n                return;\n              }\n              this.unselectAll();\n              var layer = _classPrivateFieldGet(this, _allLayers).get(_classPrivateFieldGet(this, _currentPageIndex));\n              try {\n                var newEditors = [];\n                var _iterator25 = _createForOfIteratorHelper(data),\n                  _step25;\n                try {\n                  for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                    var editor = _step25.value;\n                    var deserializedEditor = layer.deserialize(editor);\n                    if (!deserializedEditor) {\n                      return;\n                    }\n                    newEditors.push(deserializedEditor);\n                  }\n                } catch (err) {\n                  _iterator25.e(err);\n                } finally {\n                  _iterator25.f();\n                }\n                var cmd = function cmd() {\n                  for (var _i3 = 0, _newEditors = newEditors; _i3 < _newEditors.length; _i3++) {\n                    var editor = _newEditors[_i3];\n                    _classPrivateMethodGet(_this23, _addEditorToLayer, _addEditorToLayer2).call(_this23, editor);\n                  }\n                  _classPrivateMethodGet(_this23, _selectEditors, _selectEditors2).call(_this23, newEditors);\n                };\n                var undo = function undo() {\n                  for (var _i4 = 0, _newEditors2 = newEditors; _i4 < _newEditors2.length; _i4++) {\n                    var editor = _newEditors2[_i4];\n                    editor.remove();\n                  }\n                };\n                this.addCommands({\n                  cmd: cmd,\n                  undo: undo,\n                  mustExec: true\n                });\n              } catch (ex) {\n                (0, _util.warn)(\"paste: \\\"\".concat(ex.message, \"\\\".\"));\n              }\n            }\n          }, {\n            key: \"keydown\",\n            value: function keydown(event) {\n              var _this$getActive;\n              if (!((_this$getActive = this.getActive()) !== null && _this$getActive !== void 0 && _this$getActive.shouldGetKeyboardEvents())) {\n                AnnotationEditorUIManager._keyboardManager.exec(this, event);\n              }\n            }\n          }, {\n            key: \"onEditingAction\",\n            value: function onEditingAction(details) {\n              if ([\"undo\", \"redo\", \"delete\", \"selectAll\"].includes(details.name)) {\n                this[details.name]();\n              }\n            }\n          }, {\n            key: \"setEditingState\",\n            value: function setEditingState(isEditing) {\n              if (isEditing) {\n                _classPrivateMethodGet(this, _addKeyboardManager, _addKeyboardManager2).call(this);\n                _classPrivateMethodGet(this, _addCopyPasteListeners, _addCopyPasteListeners2).call(this);\n                _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                  isEditing: _classPrivateFieldGet(this, _mode) !== _util.AnnotationEditorType.NONE,\n                  isEmpty: _classPrivateMethodGet(this, _isEmpty, _isEmpty2).call(this),\n                  hasSomethingToUndo: _classPrivateFieldGet(this, _commandManager).hasSomethingToUndo(),\n                  hasSomethingToRedo: _classPrivateFieldGet(this, _commandManager).hasSomethingToRedo(),\n                  hasSelectedEditor: false\n                });\n              } else {\n                _classPrivateMethodGet(this, _removeKeyboardManager, _removeKeyboardManager2).call(this);\n                _classPrivateMethodGet(this, _removeCopyPasteListeners, _removeCopyPasteListeners2).call(this);\n                _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                  isEditing: false\n                });\n              }\n            }\n          }, {\n            key: \"registerEditorTypes\",\n            value: function registerEditorTypes(types) {\n              if (_classPrivateFieldGet(this, _editorTypes)) {\n                return;\n              }\n              _classPrivateFieldSet(this, _editorTypes, types);\n              var _iterator26 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _editorTypes)),\n                _step26;\n              try {\n                for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n                  var editorType = _step26.value;\n                  _classPrivateMethodGet(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editorType.defaultPropertiesToUpdate);\n                }\n              } catch (err) {\n                _iterator26.e(err);\n              } finally {\n                _iterator26.f();\n              }\n            }\n          }, {\n            key: \"getId\",\n            value: function getId() {\n              return _classPrivateFieldGet(this, _idManager).getId();\n            }\n          }, {\n            key: \"currentLayer\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _allLayers).get(_classPrivateFieldGet(this, _currentPageIndex));\n            }\n          }, {\n            key: \"currentPageIndex\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _currentPageIndex);\n            }\n          }, {\n            key: \"addLayer\",\n            value: function addLayer(layer) {\n              _classPrivateFieldGet(this, _allLayers).set(layer.pageIndex, layer);\n              if (_classPrivateFieldGet(this, _isEnabled)) {\n                layer.enable();\n              } else {\n                layer.disable();\n              }\n            }\n          }, {\n            key: \"removeLayer\",\n            value: function removeLayer(layer) {\n              _classPrivateFieldGet(this, _allLayers).delete(layer.pageIndex);\n            }\n          }, {\n            key: \"updateMode\",\n            value: function updateMode(mode) {\n              _classPrivateFieldSet(this, _mode, mode);\n              if (mode === _util.AnnotationEditorType.NONE) {\n                this.setEditingState(false);\n                _classPrivateMethodGet(this, _disableAll, _disableAll2).call(this);\n              } else {\n                this.setEditingState(true);\n                _classPrivateMethodGet(this, _enableAll, _enableAll2).call(this);\n                var _iterator27 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _allLayers).values()),\n                  _step27;\n                try {\n                  for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                    var layer = _step27.value;\n                    layer.updateMode(mode);\n                  }\n                } catch (err) {\n                  _iterator27.e(err);\n                } finally {\n                  _iterator27.f();\n                }\n              }\n            }\n          }, {\n            key: \"updateToolbar\",\n            value: function updateToolbar(mode) {\n              if (mode === _classPrivateFieldGet(this, _mode)) {\n                return;\n              }\n              _classPrivateFieldGet(this, _eventBus).dispatch(\"switchannotationeditormode\", {\n                source: this,\n                mode: mode\n              });\n            }\n          }, {\n            key: \"updateParams\",\n            value: function updateParams(type, value) {\n              if (!_classPrivateFieldGet(this, _editorTypes)) {\n                return;\n              }\n              var _iterator28 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _selectedEditors)),\n                _step28;\n              try {\n                for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                  var editor = _step28.value;\n                  editor.updateParams(type, value);\n                }\n              } catch (err) {\n                _iterator28.e(err);\n              } finally {\n                _iterator28.f();\n              }\n              var _iterator29 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _editorTypes)),\n                _step29;\n              try {\n                for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                  var editorType = _step29.value;\n                  editorType.updateDefaultParams(type, value);\n                }\n              } catch (err) {\n                _iterator29.e(err);\n              } finally {\n                _iterator29.f();\n              }\n            }\n          }, {\n            key: \"getEditors\",\n            value: function getEditors(pageIndex) {\n              var editors = [];\n              var _iterator30 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _allEditors).values()),\n                _step30;\n              try {\n                for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                  var editor = _step30.value;\n                  if (editor.pageIndex === pageIndex) {\n                    editors.push(editor);\n                  }\n                }\n              } catch (err) {\n                _iterator30.e(err);\n              } finally {\n                _iterator30.f();\n              }\n              return editors;\n            }\n          }, {\n            key: \"getEditor\",\n            value: function getEditor(id) {\n              return _classPrivateFieldGet(this, _allEditors).get(id);\n            }\n          }, {\n            key: \"addEditor\",\n            value: function addEditor(editor) {\n              _classPrivateFieldGet(this, _allEditors).set(editor.id, editor);\n            }\n          }, {\n            key: \"removeEditor\",\n            value: function removeEditor(editor) {\n              var _classPrivateFieldGet3;\n              _classPrivateFieldGet(this, _allEditors).delete(editor.id);\n              this.unselect(editor);\n              (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _annotationStorage)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.remove(editor.id);\n            }\n          }, {\n            key: \"setActiveEditor\",\n            value: function setActiveEditor(editor) {\n              if (_classPrivateFieldGet(this, _activeEditor) === editor) {\n                return;\n              }\n              _classPrivateFieldSet(this, _activeEditor, editor);\n              if (editor) {\n                _classPrivateMethodGet(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editor.propertiesToUpdate);\n              }\n            }\n          }, {\n            key: \"toggleSelected\",\n            value: function toggleSelected(editor) {\n              if (_classPrivateFieldGet(this, _selectedEditors).has(editor)) {\n                _classPrivateFieldGet(this, _selectedEditors).delete(editor);\n                editor.unselect();\n                _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                  hasSelectedEditor: this.hasSelection\n                });\n                return;\n              }\n              _classPrivateFieldGet(this, _selectedEditors).add(editor);\n              editor.select();\n              _classPrivateMethodGet(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editor.propertiesToUpdate);\n              _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                hasSelectedEditor: true\n              });\n            }\n          }, {\n            key: \"setSelected\",\n            value: function setSelected(editor) {\n              var _iterator31 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _selectedEditors)),\n                _step31;\n              try {\n                for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n                  var ed = _step31.value;\n                  if (ed !== editor) {\n                    ed.unselect();\n                  }\n                }\n              } catch (err) {\n                _iterator31.e(err);\n              } finally {\n                _iterator31.f();\n              }\n              _classPrivateFieldGet(this, _selectedEditors).clear();\n              _classPrivateFieldGet(this, _selectedEditors).add(editor);\n              editor.select();\n              _classPrivateMethodGet(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editor.propertiesToUpdate);\n              _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                hasSelectedEditor: true\n              });\n            }\n          }, {\n            key: \"isSelected\",\n            value: function isSelected(editor) {\n              return _classPrivateFieldGet(this, _selectedEditors).has(editor);\n            }\n          }, {\n            key: \"unselect\",\n            value: function unselect(editor) {\n              editor.unselect();\n              _classPrivateFieldGet(this, _selectedEditors).delete(editor);\n              _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                hasSelectedEditor: this.hasSelection\n              });\n            }\n          }, {\n            key: \"hasSelection\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _selectedEditors).size !== 0;\n            }\n          }, {\n            key: \"undo\",\n            value: function undo() {\n              _classPrivateFieldGet(this, _commandManager).undo();\n              _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                hasSomethingToUndo: _classPrivateFieldGet(this, _commandManager).hasSomethingToUndo(),\n                hasSomethingToRedo: true,\n                isEmpty: _classPrivateMethodGet(this, _isEmpty, _isEmpty2).call(this)\n              });\n            }\n          }, {\n            key: \"redo\",\n            value: function redo() {\n              _classPrivateFieldGet(this, _commandManager).redo();\n              _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                hasSomethingToUndo: true,\n                hasSomethingToRedo: _classPrivateFieldGet(this, _commandManager).hasSomethingToRedo(),\n                isEmpty: _classPrivateMethodGet(this, _isEmpty, _isEmpty2).call(this)\n              });\n            }\n          }, {\n            key: \"addCommands\",\n            value: function addCommands(params) {\n              _classPrivateFieldGet(this, _commandManager).add(params);\n              _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                hasSomethingToUndo: true,\n                hasSomethingToRedo: false,\n                isEmpty: _classPrivateMethodGet(this, _isEmpty, _isEmpty2).call(this)\n              });\n            }\n          }, {\n            key: \"delete\",\n            value: function _delete() {\n              var _this24 = this;\n              this.commitOrRemove();\n              if (!this.hasSelection) {\n                return;\n              }\n              var editors = _toConsumableArray(_classPrivateFieldGet(this, _selectedEditors));\n              var cmd = function cmd() {\n                var _iterator32 = _createForOfIteratorHelper(editors),\n                  _step32;\n                try {\n                  for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                    var editor = _step32.value;\n                    editor.remove();\n                  }\n                } catch (err) {\n                  _iterator32.e(err);\n                } finally {\n                  _iterator32.f();\n                }\n              };\n              var undo = function undo() {\n                var _iterator33 = _createForOfIteratorHelper(editors),\n                  _step33;\n                try {\n                  for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n                    var editor = _step33.value;\n                    _classPrivateMethodGet(_this24, _addEditorToLayer, _addEditorToLayer2).call(_this24, editor);\n                  }\n                } catch (err) {\n                  _iterator33.e(err);\n                } finally {\n                  _iterator33.f();\n                }\n              };\n              this.addCommands({\n                cmd: cmd,\n                undo: undo,\n                mustExec: true\n              });\n            }\n          }, {\n            key: \"commitOrRemove\",\n            value: function commitOrRemove() {\n              var _classPrivateFieldGet4;\n              (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _activeEditor)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.commitOrRemove();\n            }\n          }, {\n            key: \"selectAll\",\n            value: function selectAll() {\n              var _iterator34 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _selectedEditors)),\n                _step34;\n              try {\n                for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n                  var editor = _step34.value;\n                  editor.commit();\n                }\n              } catch (err) {\n                _iterator34.e(err);\n              } finally {\n                _iterator34.f();\n              }\n              _classPrivateMethodGet(this, _selectEditors, _selectEditors2).call(this, _classPrivateFieldGet(this, _allEditors).values());\n            }\n          }, {\n            key: \"unselectAll\",\n            value: function unselectAll() {\n              if (_classPrivateFieldGet(this, _activeEditor)) {\n                _classPrivateFieldGet(this, _activeEditor).commitOrRemove();\n                return;\n              }\n              if (_classPrivateFieldGet(this, _selectedEditors).size === 0) {\n                return;\n              }\n              var _iterator35 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _selectedEditors)),\n                _step35;\n              try {\n                for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n                  var editor = _step35.value;\n                  editor.unselect();\n                }\n              } catch (err) {\n                _iterator35.e(err);\n              } finally {\n                _iterator35.f();\n              }\n              _classPrivateFieldGet(this, _selectedEditors).clear();\n              _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n                hasSelectedEditor: false\n              });\n            }\n          }, {\n            key: \"isActive\",\n            value: function isActive(editor) {\n              return _classPrivateFieldGet(this, _activeEditor) === editor;\n            }\n          }, {\n            key: \"getActive\",\n            value: function getActive() {\n              return _classPrivateFieldGet(this, _activeEditor);\n            }\n          }, {\n            key: \"getMode\",\n            value: function getMode() {\n              return _classPrivateFieldGet(this, _mode);\n            }\n          }]);\n          return AnnotationEditorUIManager;\n        }();\n        function _addKeyboardManager2() {\n          _classPrivateFieldGet(this, _container).addEventListener(\"keydown\", _classPrivateFieldGet(this, _boundKeydown));\n        }\n        function _removeKeyboardManager2() {\n          _classPrivateFieldGet(this, _container).removeEventListener(\"keydown\", _classPrivateFieldGet(this, _boundKeydown));\n        }\n        function _addCopyPasteListeners2() {\n          document.addEventListener(\"copy\", _classPrivateFieldGet(this, _boundCopy));\n          document.addEventListener(\"cut\", _classPrivateFieldGet(this, _boundCut));\n          document.addEventListener(\"paste\", _classPrivateFieldGet(this, _boundPaste));\n        }\n        function _removeCopyPasteListeners2() {\n          document.removeEventListener(\"copy\", _classPrivateFieldGet(this, _boundCopy));\n          document.removeEventListener(\"cut\", _classPrivateFieldGet(this, _boundCut));\n          document.removeEventListener(\"paste\", _classPrivateFieldGet(this, _boundPaste));\n        }\n        function _dispatchUpdateStates2(details) {\n          var _this25 = this;\n          var hasChanged = Object.entries(details).some(function (_ref29) {\n            var _ref30 = _slicedToArray(_ref29, 2),\n              key = _ref30[0],\n              value = _ref30[1];\n            return _classPrivateFieldGet(_this25, _previousStates)[key] !== value;\n          });\n          if (hasChanged) {\n            _classPrivateFieldGet(this, _eventBus).dispatch(\"annotationeditorstateschanged\", {\n              source: this,\n              details: Object.assign(_classPrivateFieldGet(this, _previousStates), details)\n            });\n          }\n        }\n        function _dispatchUpdateUI2(details) {\n          _classPrivateFieldGet(this, _eventBus).dispatch(\"annotationeditorparamschanged\", {\n            source: this,\n            details: details\n          });\n        }\n        function _enableAll2() {\n          if (!_classPrivateFieldGet(this, _isEnabled)) {\n            _classPrivateFieldSet(this, _isEnabled, true);\n            var _iterator36 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _allLayers).values()),\n              _step36;\n            try {\n              for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n                var layer = _step36.value;\n                layer.enable();\n              }\n            } catch (err) {\n              _iterator36.e(err);\n            } finally {\n              _iterator36.f();\n            }\n          }\n        }\n        function _disableAll2() {\n          this.unselectAll();\n          if (_classPrivateFieldGet(this, _isEnabled)) {\n            _classPrivateFieldSet(this, _isEnabled, false);\n            var _iterator37 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _allLayers).values()),\n              _step37;\n            try {\n              for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n                var layer = _step37.value;\n                layer.disable();\n              }\n            } catch (err) {\n              _iterator37.e(err);\n            } finally {\n              _iterator37.f();\n            }\n          }\n        }\n        function _addEditorToLayer2(editor) {\n          var layer = _classPrivateFieldGet(this, _allLayers).get(editor.pageIndex);\n          if (layer) {\n            layer.addOrRebuild(editor);\n          } else {\n            this.addEditor(editor);\n          }\n        }\n        function _isEmpty2() {\n          if (_classPrivateFieldGet(this, _allEditors).size === 0) {\n            return true;\n          }\n          if (_classPrivateFieldGet(this, _allEditors).size === 1) {\n            var _iterator38 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _allEditors).values()),\n              _step38;\n            try {\n              for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n                var editor = _step38.value;\n                return editor.isEmpty();\n              }\n            } catch (err) {\n              _iterator38.e(err);\n            } finally {\n              _iterator38.f();\n            }\n          }\n          return false;\n        }\n        function _selectEditors2(editors) {\n          _classPrivateFieldGet(this, _selectedEditors).clear();\n          var _iterator39 = _createForOfIteratorHelper(editors),\n            _step39;\n          try {\n            for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n              var editor = _step39.value;\n              if (editor.isEmpty()) {\n                continue;\n              }\n              _classPrivateFieldGet(this, _selectedEditors).add(editor);\n              editor.select();\n            }\n          } catch (err) {\n            _iterator39.e(err);\n          } finally {\n            _iterator39.f();\n          }\n          _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {\n            hasSelectedEditor: true\n          });\n        }\n        _defineProperty(AnnotationEditorUIManager, \"_keyboardManager\", new KeyboardManager([[[\"ctrl+a\", \"mac+meta+a\"], AnnotationEditorUIManager.prototype.selectAll], [[\"ctrl+z\", \"mac+meta+z\"], AnnotationEditorUIManager.prototype.undo], [[\"ctrl+y\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], AnnotationEditorUIManager.prototype.redo], [[\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\"], AnnotationEditorUIManager.prototype.delete], [[\"Escape\", \"mac+Escape\"], AnnotationEditorUIManager.prototype.unselectAll]]));\n        exports.AnnotationEditorUIManager = AnnotationEditorUIManager;\n\n        /***/\n      }, /* 6 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMFilterFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = exports.AnnotationPrefix = void 0;\n        exports.deprecated = deprecated;\n        exports.getColorValues = getColorValues;\n        exports.getCurrentTransform = getCurrentTransform;\n        exports.getCurrentTransformInverse = getCurrentTransformInverse;\n        exports.getFilenameFromUrl = getFilenameFromUrl;\n        exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\n        exports.getRGB = getRGB;\n        exports.getXfaPageViewport = getXfaPageViewport;\n        exports.isDataScheme = isDataScheme;\n        exports.isPdfFile = isPdfFile;\n        exports.isValidFetchUrl = isValidFetchUrl;\n        exports.loadScript = loadScript;\n        exports.setLayerDimensions = setLayerDimensions;\n        var _base_factory = __w_pdfjs_require__(7);\n        var _util = __w_pdfjs_require__(1);\n        var SVG_NS = \"http://www.w3.org/2000/svg\";\n        var AnnotationPrefix = \"pdfjs_internal_id_\";\n        exports.AnnotationPrefix = AnnotationPrefix;\n        var PixelsPerInch = /*#__PURE__*/_createClass(function PixelsPerInch() {\n          _classCallCheck(this, PixelsPerInch);\n        });\n        _defineProperty(PixelsPerInch, \"CSS\", 96.0);\n        _defineProperty(PixelsPerInch, \"PDF\", 72.0);\n        _defineProperty(PixelsPerInch, \"PDF_TO_CSS_UNITS\", PixelsPerInch.CSS / PixelsPerInch.PDF);\n        exports.PixelsPerInch = PixelsPerInch;\n        var _cache = /*#__PURE__*/new WeakMap();\n        var _defs = /*#__PURE__*/new WeakMap();\n        var _docId2 = /*#__PURE__*/new WeakMap();\n        var _document2 = /*#__PURE__*/new WeakMap();\n        var _hcmFilter = /*#__PURE__*/new WeakMap();\n        var _hcmKey = /*#__PURE__*/new WeakMap();\n        var _hcmUrl = /*#__PURE__*/new WeakMap();\n        var _id2 = /*#__PURE__*/new WeakMap();\n        var _cache2 = /*#__PURE__*/new WeakMap();\n        var _defs2 = /*#__PURE__*/new WeakMap();\n        var _appendFeFunc = /*#__PURE__*/new WeakSet();\n        var DOMFilterFactory = /*#__PURE__*/function (_base_factory$BaseFil) {\n          _inherits(DOMFilterFactory, _base_factory$BaseFil);\n          var _super9 = _createSuper(DOMFilterFactory);\n          function DOMFilterFactory() {\n            var _this26;\n            var _ref31 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n              docId = _ref31.docId,\n              _ref31$ownerDocument = _ref31.ownerDocument,\n              ownerDocument = _ref31$ownerDocument === void 0 ? globalThis.document : _ref31$ownerDocument;\n            _classCallCheck(this, DOMFilterFactory);\n            _this26 = _super9.call(this);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this26), _appendFeFunc);\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _defs2, {\n              get: _get_defs,\n              set: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _cache2, {\n              get: _get_cache,\n              set: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _cache, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _defs, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _docId2, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _document2, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _hcmFilter, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _hcmKey, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _hcmUrl, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this26), _id2, {\n              writable: true,\n              value: 0\n            });\n            _classPrivateFieldSet(_assertThisInitialized(_this26), _docId2, docId);\n            _classPrivateFieldSet(_assertThisInitialized(_this26), _document2, ownerDocument);\n            return _this26;\n          }\n          _createClass(DOMFilterFactory, [{\n            key: \"addFilter\",\n            value: function addFilter(maps) {\n              var _this$id3, _this$id4;\n              if (!maps) {\n                return \"none\";\n              }\n              var value = _classPrivateFieldGet(this, _cache2).get(maps);\n              if (value) {\n                return value;\n              }\n              var tableR, tableG, tableB, key;\n              if (maps.length === 1) {\n                var mapR = maps[0];\n                var buffer = new Array(256);\n                for (var i = 0; i < 256; i++) {\n                  buffer[i] = mapR[i] / 255;\n                }\n                key = tableR = tableG = tableB = buffer.join(\",\");\n              } else {\n                var _maps = _slicedToArray(maps, 3),\n                  _mapR = _maps[0],\n                  mapG = _maps[1],\n                  mapB = _maps[2];\n                var bufferR = new Array(256);\n                var bufferG = new Array(256);\n                var bufferB = new Array(256);\n                for (var _i5 = 0; _i5 < 256; _i5++) {\n                  bufferR[_i5] = _mapR[_i5] / 255;\n                  bufferG[_i5] = mapG[_i5] / 255;\n                  bufferB[_i5] = mapB[_i5] / 255;\n                }\n                tableR = bufferR.join(\",\");\n                tableG = bufferG.join(\",\");\n                tableB = bufferB.join(\",\");\n                key = \"\".concat(tableR).concat(tableG).concat(tableB);\n              }\n              value = _classPrivateFieldGet(this, _cache2).get(key);\n              if (value) {\n                _classPrivateFieldGet(this, _cache2).set(maps, value);\n                return value;\n              }\n              var id = \"g_\".concat(_classPrivateFieldGet(this, _docId2), \"_transfer_map_\").concat((_classPrivateFieldSet(this, _id2, (_this$id3 = _classPrivateFieldGet(this, _id2), _this$id4 = _this$id3++, _this$id3)), _this$id4));\n              var url = \"url(#\".concat(id, \")\");\n              _classPrivateFieldGet(this, _cache2).set(maps, url);\n              _classPrivateFieldGet(this, _cache2).set(key, url);\n              var filter = _classPrivateFieldGet(this, _document2).createElementNS(SVG_NS, \"filter\", SVG_NS);\n              filter.setAttribute(\"id\", id);\n              filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n              var feComponentTransfer = _classPrivateFieldGet(this, _document2).createElementNS(SVG_NS, \"feComponentTransfer\");\n              filter.append(feComponentTransfer);\n              _classPrivateMethodGet(this, _appendFeFunc, _appendFeFunc2).call(this, feComponentTransfer, \"feFuncR\", tableR);\n              _classPrivateMethodGet(this, _appendFeFunc, _appendFeFunc2).call(this, feComponentTransfer, \"feFuncG\", tableG);\n              _classPrivateMethodGet(this, _appendFeFunc, _appendFeFunc2).call(this, feComponentTransfer, \"feFuncB\", tableB);\n              _classPrivateFieldGet(this, _defs2).append(filter);\n              return url;\n            }\n          }, {\n            key: \"addHCMFilter\",\n            value: function addHCMFilter(fgColor, bgColor) {\n              var _classPrivateFieldGet5, _util$Util2, _util$Util3;\n              var key = \"\".concat(fgColor, \"-\").concat(bgColor);\n              if (_classPrivateFieldGet(this, _hcmKey) === key) {\n                return _classPrivateFieldGet(this, _hcmUrl);\n              }\n              _classPrivateFieldSet(this, _hcmKey, key);\n              _classPrivateFieldSet(this, _hcmUrl, \"none\");\n              (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _hcmFilter)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.remove();\n              if (!fgColor || !bgColor) {\n                return _classPrivateFieldGet(this, _hcmUrl);\n              }\n              _classPrivateFieldGet(this, _defs2).style.color = fgColor;\n              fgColor = getComputedStyle(_classPrivateFieldGet(this, _defs2)).getPropertyValue(\"color\");\n              var fgRGB = getRGB(fgColor);\n              fgColor = (_util$Util2 = _util.Util).makeHexColor.apply(_util$Util2, _toConsumableArray(fgRGB));\n              _classPrivateFieldGet(this, _defs2).style.color = bgColor;\n              bgColor = getComputedStyle(_classPrivateFieldGet(this, _defs2)).getPropertyValue(\"color\");\n              var bgRGB = getRGB(bgColor);\n              bgColor = (_util$Util3 = _util.Util).makeHexColor.apply(_util$Util3, _toConsumableArray(bgRGB));\n              _classPrivateFieldGet(this, _defs2).style.color = \"\";\n              if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n                return _classPrivateFieldGet(this, _hcmUrl);\n              }\n              var map = new Array(256);\n              for (var i = 0; i <= 255; i++) {\n                var x = i / 255;\n                map[i] = x <= 0.03928 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n              }\n              var table = map.join(\",\");\n              var id = \"g_\".concat(_classPrivateFieldGet(this, _docId2), \"_hcm_filter\");\n              var filter = _classPrivateFieldSet(this, _hcmFilter, _classPrivateFieldGet(this, _document2).createElementNS(SVG_NS, \"filter\", SVG_NS));\n              filter.setAttribute(\"id\", id);\n              filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n              var feComponentTransfer = _classPrivateFieldGet(this, _document2).createElementNS(SVG_NS, \"feComponentTransfer\");\n              filter.append(feComponentTransfer);\n              _classPrivateMethodGet(this, _appendFeFunc, _appendFeFunc2).call(this, feComponentTransfer, \"feFuncR\", table);\n              _classPrivateMethodGet(this, _appendFeFunc, _appendFeFunc2).call(this, feComponentTransfer, \"feFuncG\", table);\n              _classPrivateMethodGet(this, _appendFeFunc, _appendFeFunc2).call(this, feComponentTransfer, \"feFuncB\", table);\n              var feColorMatrix = _classPrivateFieldGet(this, _document2).createElementNS(SVG_NS, \"feColorMatrix\");\n              feColorMatrix.setAttribute(\"type\", \"matrix\");\n              feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n              filter.append(feColorMatrix);\n              feComponentTransfer = _classPrivateFieldGet(this, _document2).createElementNS(SVG_NS, \"feComponentTransfer\");\n              filter.append(feComponentTransfer);\n              var getSteps = function getSteps(c, n) {\n                var start = fgRGB[c] / 255;\n                var end = bgRGB[c] / 255;\n                var arr = new Array(n + 1);\n                for (var _i6 = 0; _i6 <= n; _i6++) {\n                  arr[_i6] = start + _i6 / n * (end - start);\n                }\n                return arr.join(\",\");\n              };\n              _classPrivateMethodGet(this, _appendFeFunc, _appendFeFunc2).call(this, feComponentTransfer, \"feFuncR\", getSteps(0, 5));\n              _classPrivateMethodGet(this, _appendFeFunc, _appendFeFunc2).call(this, feComponentTransfer, \"feFuncG\", getSteps(1, 5));\n              _classPrivateMethodGet(this, _appendFeFunc, _appendFeFunc2).call(this, feComponentTransfer, \"feFuncB\", getSteps(2, 5));\n              _classPrivateFieldGet(this, _defs2).append(filter);\n              _classPrivateFieldSet(this, _hcmUrl, \"url(#\".concat(id, \")\"));\n              return _classPrivateFieldGet(this, _hcmUrl);\n            }\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              var keepHCM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n              if (keepHCM && _classPrivateFieldGet(this, _hcmUrl)) {\n                return;\n              }\n              if (_classPrivateFieldGet(this, _defs)) {\n                _classPrivateFieldGet(this, _defs).parentNode.parentNode.remove();\n                _classPrivateFieldSet(this, _defs, null);\n              }\n              if (_classPrivateFieldGet(this, _cache)) {\n                _classPrivateFieldGet(this, _cache).clear();\n                _classPrivateFieldSet(this, _cache, null);\n              }\n              _classPrivateFieldSet(this, _id2, 0);\n            }\n          }]);\n          return DOMFilterFactory;\n        }(_base_factory.BaseFilterFactory);\n        function _get_cache() {\n          return _classPrivateFieldGet(this, _cache) || _classPrivateFieldSet(this, _cache, new Map());\n        }\n        function _get_defs() {\n          if (!_classPrivateFieldGet(this, _defs)) {\n            var div = _classPrivateFieldGet(this, _document2).createElement(\"div\");\n            var style = div.style;\n            style.visibility = \"hidden\";\n            style.contain = \"strict\";\n            style.width = style.height = 0;\n            style.position = \"absolute\";\n            style.top = style.left = 0;\n            style.zIndex = -1;\n            var svg = _classPrivateFieldGet(this, _document2).createElementNS(SVG_NS, \"svg\");\n            svg.setAttribute(\"width\", 0);\n            svg.setAttribute(\"height\", 0);\n            _classPrivateFieldSet(this, _defs, _classPrivateFieldGet(this, _document2).createElementNS(SVG_NS, \"defs\"));\n            div.append(svg);\n            svg.append(_classPrivateFieldGet(this, _defs));\n            _classPrivateFieldGet(this, _document2).body.append(div);\n          }\n          return _classPrivateFieldGet(this, _defs);\n        }\n        function _appendFeFunc2(feComponentTransfer, func, table) {\n          var feFunc = _classPrivateFieldGet(this, _document2).createElementNS(SVG_NS, func);\n          feFunc.setAttribute(\"type\", \"discrete\");\n          feFunc.setAttribute(\"tableValues\", table);\n          feComponentTransfer.append(feFunc);\n        }\n        exports.DOMFilterFactory = DOMFilterFactory;\n        var DOMCanvasFactory = /*#__PURE__*/function (_base_factory$BaseCan) {\n          _inherits(DOMCanvasFactory, _base_factory$BaseCan);\n          var _super10 = _createSuper(DOMCanvasFactory);\n          function DOMCanvasFactory() {\n            var _this27;\n            var _ref32 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n              _ref32$ownerDocument = _ref32.ownerDocument,\n              ownerDocument = _ref32$ownerDocument === void 0 ? globalThis.document : _ref32$ownerDocument;\n            _classCallCheck(this, DOMCanvasFactory);\n            _this27 = _super10.call(this);\n            _this27._document = ownerDocument;\n            return _this27;\n          }\n          _createClass(DOMCanvasFactory, [{\n            key: \"_createCanvas\",\n            value: function _createCanvas(width, height) {\n              var canvas = this._document.createElement(\"canvas\");\n              canvas.width = width;\n              canvas.height = height;\n              return canvas;\n            }\n          }]);\n          return DOMCanvasFactory;\n        }(_base_factory.BaseCanvasFactory);\n        exports.DOMCanvasFactory = DOMCanvasFactory;\n        function fetchData(_x3) {\n          return _fetchData.apply(this, arguments);\n        }\n        function _fetchData() {\n          _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(url) {\n            var asTypedArray,\n              response,\n              _args7 = arguments;\n            return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n              while (1) switch (_context7.prev = _context7.next) {\n                case 0:\n                  asTypedArray = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : false;\n                  if (!isValidFetchUrl(url, document.baseURI)) {\n                    _context7.next = 21;\n                    break;\n                  }\n                  _context7.next = 4;\n                  return fetch(url);\n                case 4:\n                  response = _context7.sent;\n                  if (response.ok) {\n                    _context7.next = 7;\n                    break;\n                  }\n                  throw new Error(response.statusText);\n                case 7:\n                  if (!asTypedArray) {\n                    _context7.next = 15;\n                    break;\n                  }\n                  _context7.t1 = Uint8Array;\n                  _context7.next = 11;\n                  return response.arrayBuffer();\n                case 11:\n                  _context7.t2 = _context7.sent;\n                  _context7.t0 = new _context7.t1(_context7.t2);\n                  _context7.next = 20;\n                  break;\n                case 15:\n                  _context7.t3 = (0, _util.stringToBytes);\n                  _context7.next = 18;\n                  return response.text();\n                case 18:\n                  _context7.t4 = _context7.sent;\n                  _context7.t0 = (0, _context7.t3)(_context7.t4);\n                case 20:\n                  return _context7.abrupt(\"return\", _context7.t0);\n                case 21:\n                  return _context7.abrupt(\"return\", new Promise(function (resolve, reject) {\n                    var request = new XMLHttpRequest();\n                    request.open(\"GET\", url, true);\n                    if (asTypedArray) {\n                      request.responseType = \"arraybuffer\";\n                    }\n                    request.onreadystatechange = function () {\n                      if (request.readyState !== XMLHttpRequest.DONE) {\n                        return;\n                      }\n                      if (request.status === 200 || request.status === 0) {\n                        var data;\n                        if (asTypedArray && request.response) {\n                          data = new Uint8Array(request.response);\n                        } else if (!asTypedArray && request.responseText) {\n                          data = (0, _util.stringToBytes)(request.responseText);\n                        }\n                        if (data) {\n                          resolve(data);\n                          return;\n                        }\n                      }\n                      reject(new Error(request.statusText));\n                    };\n                    request.send(null);\n                  }));\n                case 22:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }, _callee7);\n          }));\n          return _fetchData.apply(this, arguments);\n        }\n        var DOMCMapReaderFactory = /*#__PURE__*/function (_base_factory$BaseCMa) {\n          _inherits(DOMCMapReaderFactory, _base_factory$BaseCMa);\n          var _super11 = _createSuper(DOMCMapReaderFactory);\n          function DOMCMapReaderFactory() {\n            _classCallCheck(this, DOMCMapReaderFactory);\n            return _super11.apply(this, arguments);\n          }\n          _createClass(DOMCMapReaderFactory, [{\n            key: \"_fetchData\",\n            value: function _fetchData(url, compressionType) {\n              return fetchData(url, this.isCompressed).then(function (data) {\n                return {\n                  cMapData: data,\n                  compressionType: compressionType\n                };\n              });\n            }\n          }]);\n          return DOMCMapReaderFactory;\n        }(_base_factory.BaseCMapReaderFactory);\n        exports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n        var DOMStandardFontDataFactory = /*#__PURE__*/function (_base_factory$BaseSta) {\n          _inherits(DOMStandardFontDataFactory, _base_factory$BaseSta);\n          var _super12 = _createSuper(DOMStandardFontDataFactory);\n          function DOMStandardFontDataFactory() {\n            _classCallCheck(this, DOMStandardFontDataFactory);\n            return _super12.apply(this, arguments);\n          }\n          _createClass(DOMStandardFontDataFactory, [{\n            key: \"_fetchData\",\n            value: function _fetchData(url) {\n              return fetchData(url, true);\n            }\n          }]);\n          return DOMStandardFontDataFactory;\n        }(_base_factory.BaseStandardFontDataFactory);\n        exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\n        var DOMSVGFactory = /*#__PURE__*/function (_base_factory$BaseSVG) {\n          _inherits(DOMSVGFactory, _base_factory$BaseSVG);\n          var _super13 = _createSuper(DOMSVGFactory);\n          function DOMSVGFactory() {\n            _classCallCheck(this, DOMSVGFactory);\n            return _super13.apply(this, arguments);\n          }\n          _createClass(DOMSVGFactory, [{\n            key: \"_createSVG\",\n            value: function _createSVG(type) {\n              return document.createElementNS(SVG_NS, type);\n            }\n          }]);\n          return DOMSVGFactory;\n        }(_base_factory.BaseSVGFactory);\n        exports.DOMSVGFactory = DOMSVGFactory;\n        var PageViewport = /*#__PURE__*/function () {\n          function PageViewport(_ref33) {\n            var viewBox = _ref33.viewBox,\n              scale = _ref33.scale,\n              rotation = _ref33.rotation,\n              _ref33$offsetX = _ref33.offsetX,\n              offsetX = _ref33$offsetX === void 0 ? 0 : _ref33$offsetX,\n              _ref33$offsetY = _ref33.offsetY,\n              offsetY = _ref33$offsetY === void 0 ? 0 : _ref33$offsetY,\n              _ref33$dontFlip = _ref33.dontFlip,\n              dontFlip = _ref33$dontFlip === void 0 ? false : _ref33$dontFlip;\n            _classCallCheck(this, PageViewport);\n            this.viewBox = viewBox;\n            this.scale = scale;\n            this.rotation = rotation;\n            this.offsetX = offsetX;\n            this.offsetY = offsetY;\n            var centerX = (viewBox[2] + viewBox[0]) / 2;\n            var centerY = (viewBox[3] + viewBox[1]) / 2;\n            var rotateA, rotateB, rotateC, rotateD;\n            rotation %= 360;\n            if (rotation < 0) {\n              rotation += 360;\n            }\n            switch (rotation) {\n              case 180:\n                rotateA = -1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = 1;\n                break;\n              case 90:\n                rotateA = 0;\n                rotateB = 1;\n                rotateC = 1;\n                rotateD = 0;\n                break;\n              case 270:\n                rotateA = 0;\n                rotateB = -1;\n                rotateC = -1;\n                rotateD = 0;\n                break;\n              case 0:\n                rotateA = 1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = -1;\n                break;\n              default:\n                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n            }\n            if (dontFlip) {\n              rotateC = -rotateC;\n              rotateD = -rotateD;\n            }\n            var offsetCanvasX, offsetCanvasY;\n            var width, height;\n            if (rotateA === 0) {\n              offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n              offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n              width = (viewBox[3] - viewBox[1]) * scale;\n              height = (viewBox[2] - viewBox[0]) * scale;\n            } else {\n              offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n              offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n              width = (viewBox[2] - viewBox[0]) * scale;\n              height = (viewBox[3] - viewBox[1]) * scale;\n            }\n            this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n            this.width = width;\n            this.height = height;\n          }\n          _createClass(PageViewport, [{\n            key: \"rawDims\",\n            get: function get() {\n              var viewBox = this.viewBox;\n              return (0, _util.shadow)(this, \"rawDims\", {\n                pageWidth: viewBox[2] - viewBox[0],\n                pageHeight: viewBox[3] - viewBox[1],\n                pageX: viewBox[0],\n                pageY: viewBox[1]\n              });\n            }\n          }, {\n            key: \"clone\",\n            value: function clone() {\n              var _ref34 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                _ref34$scale = _ref34.scale,\n                scale = _ref34$scale === void 0 ? this.scale : _ref34$scale,\n                _ref34$rotation = _ref34.rotation,\n                rotation = _ref34$rotation === void 0 ? this.rotation : _ref34$rotation,\n                _ref34$offsetX = _ref34.offsetX,\n                offsetX = _ref34$offsetX === void 0 ? this.offsetX : _ref34$offsetX,\n                _ref34$offsetY = _ref34.offsetY,\n                offsetY = _ref34$offsetY === void 0 ? this.offsetY : _ref34$offsetY,\n                _ref34$dontFlip = _ref34.dontFlip,\n                dontFlip = _ref34$dontFlip === void 0 ? false : _ref34$dontFlip;\n              return new PageViewport({\n                viewBox: this.viewBox.slice(),\n                scale: scale,\n                rotation: rotation,\n                offsetX: offsetX,\n                offsetY: offsetY,\n                dontFlip: dontFlip\n              });\n            }\n          }, {\n            key: \"convertToViewportPoint\",\n            value: function convertToViewportPoint(x, y) {\n              return _util.Util.applyTransform([x, y], this.transform);\n            }\n          }, {\n            key: \"convertToViewportRectangle\",\n            value: function convertToViewportRectangle(rect) {\n              var topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n              var bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n              return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n            }\n          }, {\n            key: \"convertToPdfPoint\",\n            value: function convertToPdfPoint(x, y) {\n              return _util.Util.applyInverseTransform([x, y], this.transform);\n            }\n          }]);\n          return PageViewport;\n        }();\n        exports.PageViewport = PageViewport;\n        var RenderingCancelledException = /*#__PURE__*/function (_util$BaseException) {\n          _inherits(RenderingCancelledException, _util$BaseException);\n          var _super14 = _createSuper(RenderingCancelledException);\n          function RenderingCancelledException(msg, type) {\n            var _this28;\n            var extraDelay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            _classCallCheck(this, RenderingCancelledException);\n            _this28 = _super14.call(this, msg, \"RenderingCancelledException\");\n            _this28.type = type;\n            _this28.extraDelay = extraDelay;\n            return _this28;\n          }\n          return _createClass(RenderingCancelledException);\n        }(_util.BaseException);\n        exports.RenderingCancelledException = RenderingCancelledException;\n        function isDataScheme(url) {\n          var ii = url.length;\n          var i = 0;\n          while (i < ii && url[i].trim() === \"\") {\n            i++;\n          }\n          return url.substring(i, i + 5).toLowerCase() === \"data:\";\n        }\n        function isPdfFile(filename) {\n          return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n        }\n        function getFilenameFromUrl(url) {\n          var onlyStripPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n          if (!onlyStripPath) {\n            var _url$split = url.split(/[#?]/, 1);\n            var _url$split2 = _slicedToArray(_url$split, 1);\n            url = _url$split2[0];\n          }\n          return url.substring(url.lastIndexOf(\"/\") + 1);\n        }\n        function getPdfFilenameFromUrl(url) {\n          var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"document.pdf\";\n          if (typeof url !== \"string\") {\n            return defaultFilename;\n          }\n          if (isDataScheme(url)) {\n            (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n            return defaultFilename;\n          }\n          var reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n          var reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n          var splitURI = reURI.exec(url);\n          var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n          if (suggestedFilename) {\n            suggestedFilename = suggestedFilename[0];\n            if (suggestedFilename.includes(\"%\")) {\n              try {\n                suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n              } catch (ex) {}\n            }\n          }\n          return suggestedFilename || defaultFilename;\n        }\n        var StatTimer = /*#__PURE__*/function () {\n          function StatTimer() {\n            _classCallCheck(this, StatTimer);\n            _defineProperty(this, \"started\", Object.create(null));\n            _defineProperty(this, \"times\", []);\n          }\n          _createClass(StatTimer, [{\n            key: \"time\",\n            value: function time(name) {\n              if (name in this.started) {\n                (0, _util.warn)(\"Timer is already running for \".concat(name));\n              }\n              this.started[name] = Date.now();\n            }\n          }, {\n            key: \"timeEnd\",\n            value: function timeEnd(name) {\n              if (!(name in this.started)) {\n                (0, _util.warn)(\"Timer has not been started for \".concat(name));\n              }\n              this.times.push({\n                name: name,\n                start: this.started[name],\n                end: Date.now()\n              });\n              delete this.started[name];\n            }\n          }, {\n            key: \"toString\",\n            value: function toString() {\n              var outBuf = [];\n              var longest = 0;\n              var _iterator40 = _createForOfIteratorHelper(this.times),\n                _step40;\n              try {\n                for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n                  var name = _step40.value.name;\n                  longest = Math.max(name.length, longest);\n                }\n              } catch (err) {\n                _iterator40.e(err);\n              } finally {\n                _iterator40.f();\n              }\n              var _iterator41 = _createForOfIteratorHelper(this.times),\n                _step41;\n              try {\n                for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n                  var _step41$value = _step41.value,\n                    _name = _step41$value.name,\n                    start = _step41$value.start,\n                    end = _step41$value.end;\n                  outBuf.push(\"\".concat(_name.padEnd(longest), \" \").concat(end - start, \"ms\\n\"));\n                }\n              } catch (err) {\n                _iterator41.e(err);\n              } finally {\n                _iterator41.f();\n              }\n              return outBuf.join(\"\");\n            }\n          }]);\n          return StatTimer;\n        }();\n        exports.StatTimer = StatTimer;\n        function isValidFetchUrl(url, baseUrl) {\n          try {\n            var _ref35 = baseUrl ? new URL(url, baseUrl) : new URL(url),\n              protocol = _ref35.protocol;\n            return protocol === \"http:\" || protocol === \"https:\";\n          } catch (ex) {\n            return false;\n          }\n        }\n        function loadScript(src) {\n          var removeScriptElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n          return new Promise(function (resolve, reject) {\n            var script = document.createElement(\"script\");\n            script.src = src;\n            script.onload = function (evt) {\n              if (removeScriptElement) {\n                script.remove();\n              }\n              resolve(evt);\n            };\n            script.onerror = function () {\n              reject(new Error(\"Cannot load script at: \".concat(script.src)));\n            };\n            (document.head || document.documentElement).append(script);\n          });\n        }\n        function deprecated(details) {\n          console.log(\"Deprecated API usage: \" + details);\n        }\n        var pdfDateStringRegex;\n        var PDFDateString = /*#__PURE__*/function () {\n          function PDFDateString() {\n            _classCallCheck(this, PDFDateString);\n          }\n          _createClass(PDFDateString, null, [{\n            key: \"toDateObject\",\n            value: function toDateObject(input) {\n              if (!input || typeof input !== \"string\") {\n                return null;\n              }\n              if (!pdfDateStringRegex) {\n                pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n              }\n              var matches = pdfDateStringRegex.exec(input);\n              if (!matches) {\n                return null;\n              }\n              var year = parseInt(matches[1], 10);\n              var month = parseInt(matches[2], 10);\n              month = month >= 1 && month <= 12 ? month - 1 : 0;\n              var day = parseInt(matches[3], 10);\n              day = day >= 1 && day <= 31 ? day : 1;\n              var hour = parseInt(matches[4], 10);\n              hour = hour >= 0 && hour <= 23 ? hour : 0;\n              var minute = parseInt(matches[5], 10);\n              minute = minute >= 0 && minute <= 59 ? minute : 0;\n              var second = parseInt(matches[6], 10);\n              second = second >= 0 && second <= 59 ? second : 0;\n              var universalTimeRelation = matches[7] || \"Z\";\n              var offsetHour = parseInt(matches[8], 10);\n              offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n              var offsetMinute = parseInt(matches[9], 10) || 0;\n              offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n              if (universalTimeRelation === \"-\") {\n                hour += offsetHour;\n                minute += offsetMinute;\n              } else if (universalTimeRelation === \"+\") {\n                hour -= offsetHour;\n                minute -= offsetMinute;\n              }\n              return new Date(Date.UTC(year, month, day, hour, minute, second));\n            }\n          }]);\n          return PDFDateString;\n        }();\n        exports.PDFDateString = PDFDateString;\n        function getXfaPageViewport(xfaPage, _ref36) {\n          var _ref36$scale = _ref36.scale,\n            scale = _ref36$scale === void 0 ? 1 : _ref36$scale,\n            _ref36$rotation = _ref36.rotation,\n            rotation = _ref36$rotation === void 0 ? 0 : _ref36$rotation;\n          var _xfaPage$attributes$s = xfaPage.attributes.style,\n            width = _xfaPage$attributes$s.width,\n            height = _xfaPage$attributes$s.height;\n          var viewBox = [0, 0, parseInt(width), parseInt(height)];\n          return new PageViewport({\n            viewBox: viewBox,\n            scale: scale,\n            rotation: rotation\n          });\n        }\n        function getRGB(color) {\n          if (color.startsWith(\"#\")) {\n            var colorRGB = parseInt(color.slice(1), 16);\n            return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];\n          }\n          if (color.startsWith(\"rgb(\")) {\n            return color.slice(4, -1).split(\",\").map(function (x) {\n              return parseInt(x);\n            });\n          }\n          if (color.startsWith(\"rgba(\")) {\n            return color.slice(5, -1).split(\",\").map(function (x) {\n              return parseInt(x);\n            }).slice(0, 3);\n          }\n          (0, _util.warn)(\"Not a valid color format: \\\"\".concat(color, \"\\\"\"));\n          return [0, 0, 0];\n        }\n        function getColorValues(colors) {\n          var span = document.createElement(\"span\");\n          span.style.visibility = \"hidden\";\n          document.body.append(span);\n          var _iterator42 = _createForOfIteratorHelper(colors.keys()),\n            _step42;\n          try {\n            for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n              var name = _step42.value;\n              span.style.color = name;\n              var computedColor = window.getComputedStyle(span).color;\n              colors.set(name, getRGB(computedColor));\n            }\n          } catch (err) {\n            _iterator42.e(err);\n          } finally {\n            _iterator42.f();\n          }\n          span.remove();\n        }\n        function getCurrentTransform(ctx) {\n          var _ctx$getTransform = ctx.getTransform(),\n            a = _ctx$getTransform.a,\n            b = _ctx$getTransform.b,\n            c = _ctx$getTransform.c,\n            d = _ctx$getTransform.d,\n            e = _ctx$getTransform.e,\n            f = _ctx$getTransform.f;\n          return [a, b, c, d, e, f];\n        }\n        function getCurrentTransformInverse(ctx) {\n          var _ctx$getTransform$inv = ctx.getTransform().invertSelf(),\n            a = _ctx$getTransform$inv.a,\n            b = _ctx$getTransform$inv.b,\n            c = _ctx$getTransform$inv.c,\n            d = _ctx$getTransform$inv.d,\n            e = _ctx$getTransform$inv.e,\n            f = _ctx$getTransform$inv.f;\n          return [a, b, c, d, e, f];\n        }\n        function setLayerDimensions(div, viewport) {\n          var mustFlip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n          var mustRotate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n          if (viewport instanceof PageViewport) {\n            var _viewport$rawDims = viewport.rawDims,\n              pageWidth = _viewport$rawDims.pageWidth,\n              pageHeight = _viewport$rawDims.pageHeight;\n            var style = div.style;\n            var widthStr = \"calc(var(--scale-factor) * \".concat(pageWidth, \"px)\");\n            var heightStr = \"calc(var(--scale-factor) * \".concat(pageHeight, \"px)\");\n            if (!mustFlip || viewport.rotation % 180 === 0) {\n              style.width = widthStr;\n              style.height = heightStr;\n            } else {\n              style.width = heightStr;\n              style.height = widthStr;\n            }\n          }\n          if (mustRotate) {\n            div.setAttribute(\"data-main-rotation\", viewport.rotation);\n          }\n        }\n\n        /***/\n      }, /* 7 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseFilterFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var BaseFilterFactory = /*#__PURE__*/function () {\n          function BaseFilterFactory() {\n            _classCallCheck(this, BaseFilterFactory);\n            if (this.constructor === BaseFilterFactory) {\n              (0, _util.unreachable)(\"Cannot initialize BaseFilterFactory.\");\n            }\n          }\n          _createClass(BaseFilterFactory, [{\n            key: \"addFilter\",\n            value: function addFilter(maps) {\n              return \"none\";\n            }\n          }, {\n            key: \"addHCMFilter\",\n            value: function addHCMFilter(fgColor, bgColor) {\n              return \"none\";\n            }\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              var keepHCM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n            }\n          }]);\n          return BaseFilterFactory;\n        }();\n        exports.BaseFilterFactory = BaseFilterFactory;\n        var BaseCanvasFactory = /*#__PURE__*/function () {\n          function BaseCanvasFactory() {\n            _classCallCheck(this, BaseCanvasFactory);\n            if (this.constructor === BaseCanvasFactory) {\n              (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n            }\n          }\n          _createClass(BaseCanvasFactory, [{\n            key: \"create\",\n            value: function create(width, height) {\n              if (width <= 0 || height <= 0) {\n                throw new Error(\"Invalid canvas size\");\n              }\n              var canvas = this._createCanvas(width, height);\n              return {\n                canvas: canvas,\n                context: canvas.getContext(\"2d\")\n              };\n            }\n          }, {\n            key: \"reset\",\n            value: function reset(canvasAndContext, width, height) {\n              if (!canvasAndContext.canvas) {\n                throw new Error(\"Canvas is not specified\");\n              }\n              if (width <= 0 || height <= 0) {\n                throw new Error(\"Invalid canvas size\");\n              }\n              canvasAndContext.canvas.width = width;\n              canvasAndContext.canvas.height = height;\n            }\n          }, {\n            key: \"destroy\",\n            value: function destroy(canvasAndContext) {\n              if (!canvasAndContext.canvas) {\n                throw new Error(\"Canvas is not specified\");\n              }\n              canvasAndContext.canvas.width = 0;\n              canvasAndContext.canvas.height = 0;\n              canvasAndContext.canvas = null;\n              canvasAndContext.context = null;\n            }\n          }, {\n            key: \"_createCanvas\",\n            value: function _createCanvas(width, height) {\n              (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n            }\n          }]);\n          return BaseCanvasFactory;\n        }();\n        exports.BaseCanvasFactory = BaseCanvasFactory;\n        var BaseCMapReaderFactory = /*#__PURE__*/function () {\n          function BaseCMapReaderFactory(_ref37) {\n            var _ref37$baseUrl = _ref37.baseUrl,\n              baseUrl = _ref37$baseUrl === void 0 ? null : _ref37$baseUrl,\n              _ref37$isCompressed = _ref37.isCompressed,\n              isCompressed = _ref37$isCompressed === void 0 ? true : _ref37$isCompressed;\n            _classCallCheck(this, BaseCMapReaderFactory);\n            if (this.constructor === BaseCMapReaderFactory) {\n              (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n            }\n            this.baseUrl = baseUrl;\n            this.isCompressed = isCompressed;\n          }\n          _createClass(BaseCMapReaderFactory, [{\n            key: \"fetch\",\n            value: function () {\n              var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref38) {\n                var _this29 = this;\n                var name, url, compressionType;\n                return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                  while (1) switch (_context8.prev = _context8.next) {\n                    case 0:\n                      name = _ref38.name;\n                      if (this.baseUrl) {\n                        _context8.next = 3;\n                        break;\n                      }\n                      throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n                    case 3:\n                      if (name) {\n                        _context8.next = 5;\n                        break;\n                      }\n                      throw new Error(\"CMap name must be specified.\");\n                    case 5:\n                      url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n                      compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n                      return _context8.abrupt(\"return\", this._fetchData(url, compressionType).catch(function (reason) {\n                        throw new Error(\"Unable to load \".concat(_this29.isCompressed ? \"binary \" : \"\", \"CMap at: \").concat(url));\n                      }));\n                    case 8:\n                    case \"end\":\n                      return _context8.stop();\n                  }\n                }, _callee8, this);\n              }));\n              function fetch(_x4) {\n                return _fetch.apply(this, arguments);\n              }\n              return fetch;\n            }()\n          }, {\n            key: \"_fetchData\",\n            value: function _fetchData(url, compressionType) {\n              (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n            }\n          }]);\n          return BaseCMapReaderFactory;\n        }();\n        exports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n        var BaseStandardFontDataFactory = /*#__PURE__*/function () {\n          function BaseStandardFontDataFactory(_ref39) {\n            var _ref39$baseUrl = _ref39.baseUrl,\n              baseUrl = _ref39$baseUrl === void 0 ? null : _ref39$baseUrl;\n            _classCallCheck(this, BaseStandardFontDataFactory);\n            if (this.constructor === BaseStandardFontDataFactory) {\n              (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n            }\n            this.baseUrl = baseUrl;\n          }\n          _createClass(BaseStandardFontDataFactory, [{\n            key: \"fetch\",\n            value: function () {\n              var _fetch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref40) {\n                var filename, url;\n                return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                  while (1) switch (_context9.prev = _context9.next) {\n                    case 0:\n                      filename = _ref40.filename;\n                      if (this.baseUrl) {\n                        _context9.next = 3;\n                        break;\n                      }\n                      throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n                    case 3:\n                      if (filename) {\n                        _context9.next = 5;\n                        break;\n                      }\n                      throw new Error(\"Font filename must be specified.\");\n                    case 5:\n                      url = \"\".concat(this.baseUrl).concat(filename);\n                      return _context9.abrupt(\"return\", this._fetchData(url).catch(function (reason) {\n                        throw new Error(\"Unable to load font data at: \".concat(url));\n                      }));\n                    case 7:\n                    case \"end\":\n                      return _context9.stop();\n                  }\n                }, _callee9, this);\n              }));\n              function fetch(_x5) {\n                return _fetch2.apply(this, arguments);\n              }\n              return fetch;\n            }()\n          }, {\n            key: \"_fetchData\",\n            value: function _fetchData(url) {\n              (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n            }\n          }]);\n          return BaseStandardFontDataFactory;\n        }();\n        exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\n        var BaseSVGFactory = /*#__PURE__*/function () {\n          function BaseSVGFactory() {\n            _classCallCheck(this, BaseSVGFactory);\n            if (this.constructor === BaseSVGFactory) {\n              (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n            }\n          }\n          _createClass(BaseSVGFactory, [{\n            key: \"create\",\n            value: function create(width, height) {\n              var skipDimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n              if (width <= 0 || height <= 0) {\n                throw new Error(\"Invalid SVG dimensions\");\n              }\n              var svg = this._createSVG(\"svg:svg\");\n              svg.setAttribute(\"version\", \"1.1\");\n              if (!skipDimensions) {\n                svg.setAttribute(\"width\", \"\".concat(width, \"px\"));\n                svg.setAttribute(\"height\", \"\".concat(height, \"px\"));\n              }\n              svg.setAttribute(\"preserveAspectRatio\", \"none\");\n              svg.setAttribute(\"viewBox\", \"0 0 \".concat(width, \" \").concat(height));\n              return svg;\n            }\n          }, {\n            key: \"createElement\",\n            value: function createElement(type) {\n              if (typeof type !== \"string\") {\n                throw new Error(\"Invalid SVG element type\");\n              }\n              return this._createSVG(type);\n            }\n          }, {\n            key: \"_createSVG\",\n            value: function _createSVG(type) {\n              (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n            }\n          }]);\n          return BaseSVGFactory;\n        }();\n        exports.BaseSVGFactory = BaseSVGFactory;\n\n        /***/\n      }, /* 8 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.MurmurHash3_64 = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var SEED = 0xc3d2e1f0;\n        var MASK_HIGH = 0xffff0000;\n        var MASK_LOW = 0xffff;\n        var MurmurHash3_64 = /*#__PURE__*/function () {\n          function MurmurHash3_64(seed) {\n            _classCallCheck(this, MurmurHash3_64);\n            this.h1 = seed ? seed & 0xffffffff : SEED;\n            this.h2 = seed ? seed & 0xffffffff : SEED;\n          }\n          _createClass(MurmurHash3_64, [{\n            key: \"update\",\n            value: function update(input) {\n              var data, length;\n              if (typeof input === \"string\") {\n                data = new Uint8Array(input.length * 2);\n                length = 0;\n                for (var i = 0, ii = input.length; i < ii; i++) {\n                  var code = input.charCodeAt(i);\n                  if (code <= 0xff) {\n                    data[length++] = code;\n                  } else {\n                    data[length++] = code >>> 8;\n                    data[length++] = code & 0xff;\n                  }\n                }\n              } else if ((0, _util.isArrayBuffer)(input)) {\n                data = input.slice();\n                length = data.byteLength;\n              } else {\n                throw new Error(\"Wrong data format in MurmurHash3_64_update. \" + \"Input must be a string or array.\");\n              }\n              var blockCounts = length >> 2;\n              var tailLength = length - blockCounts * 4;\n              var dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n              var k1 = 0,\n                k2 = 0;\n              var h1 = this.h1,\n                h2 = this.h2;\n              var C1 = 0xcc9e2d51,\n                C2 = 0x1b873593;\n              var C1_LOW = C1 & MASK_LOW,\n                C2_LOW = C2 & MASK_LOW;\n              for (var _i7 = 0; _i7 < blockCounts; _i7++) {\n                if (_i7 & 1) {\n                  k1 = dataUint32[_i7];\n                  k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                  k1 = k1 << 15 | k1 >>> 17;\n                  k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                  h1 ^= k1;\n                  h1 = h1 << 13 | h1 >>> 19;\n                  h1 = h1 * 5 + 0xe6546b64;\n                } else {\n                  k2 = dataUint32[_i7];\n                  k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                  k2 = k2 << 15 | k2 >>> 17;\n                  k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                  h2 ^= k2;\n                  h2 = h2 << 13 | h2 >>> 19;\n                  h2 = h2 * 5 + 0xe6546b64;\n                }\n              }\n              k1 = 0;\n              switch (tailLength) {\n                case 3:\n                  k1 ^= data[blockCounts * 4 + 2] << 16;\n                case 2:\n                  k1 ^= data[blockCounts * 4 + 1] << 8;\n                case 1:\n                  k1 ^= data[blockCounts * 4];\n                  k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                  k1 = k1 << 15 | k1 >>> 17;\n                  k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                  if (blockCounts & 1) {\n                    h1 ^= k1;\n                  } else {\n                    h2 ^= k1;\n                  }\n              }\n              this.h1 = h1;\n              this.h2 = h2;\n            }\n          }, {\n            key: \"hexdigest\",\n            value: function hexdigest() {\n              var h1 = this.h1,\n                h2 = this.h2;\n              h1 ^= h2 >>> 1;\n              h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n              h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n              h1 ^= h2 >>> 1;\n              h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n              h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n              h1 ^= h2 >>> 1;\n              return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n            }\n          }]);\n          return MurmurHash3_64;\n        }();\n        exports.MurmurHash3_64 = MurmurHash3_64;\n\n        /***/\n      }, /* 9 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.FontLoader = exports.FontFaceObject = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _is_node = __w_pdfjs_require__(10);\n        var FontLoader = /*#__PURE__*/function () {\n          function FontLoader(_ref41) {\n            var _ref41$ownerDocument = _ref41.ownerDocument,\n              ownerDocument = _ref41$ownerDocument === void 0 ? globalThis.document : _ref41$ownerDocument,\n              _ref41$styleElement = _ref41.styleElement,\n              styleElement = _ref41$styleElement === void 0 ? null : _ref41$styleElement;\n            _classCallCheck(this, FontLoader);\n            this._document = ownerDocument;\n            this.nativeFontFaces = [];\n            this.styleElement = null;\n            this.loadingRequests = [];\n            this.loadTestFontId = 0;\n          }\n          _createClass(FontLoader, [{\n            key: \"addNativeFontFace\",\n            value: function addNativeFontFace(nativeFontFace) {\n              this.nativeFontFaces.push(nativeFontFace);\n              this._document.fonts.add(nativeFontFace);\n            }\n          }, {\n            key: \"insertRule\",\n            value: function insertRule(rule) {\n              if (!this.styleElement) {\n                this.styleElement = this._document.createElement(\"style\");\n                this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n              }\n              var styleSheet = this.styleElement.sheet;\n              styleSheet.insertRule(rule, styleSheet.cssRules.length);\n            }\n          }, {\n            key: \"clear\",\n            value: function clear() {\n              var _iterator43 = _createForOfIteratorHelper(this.nativeFontFaces),\n                _step43;\n              try {\n                for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n                  var nativeFontFace = _step43.value;\n                  this._document.fonts.delete(nativeFontFace);\n                }\n              } catch (err) {\n                _iterator43.e(err);\n              } finally {\n                _iterator43.f();\n              }\n              this.nativeFontFaces.length = 0;\n              if (this.styleElement) {\n                this.styleElement.remove();\n                this.styleElement = null;\n              }\n            }\n          }, {\n            key: \"bind\",\n            value: function () {\n              var _bind = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(font) {\n                var _this30 = this;\n                var nativeFontFace, rule;\n                return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n                  while (1) switch (_context10.prev = _context10.next) {\n                    case 0:\n                      if (!(font.attached || font.missingFile)) {\n                        _context10.next = 2;\n                        break;\n                      }\n                      return _context10.abrupt(\"return\");\n                    case 2:\n                      font.attached = true;\n                      if (!this.isFontLoadingAPISupported) {\n                        _context10.next = 18;\n                        break;\n                      }\n                      nativeFontFace = font.createNativeFontFace();\n                      if (!nativeFontFace) {\n                        _context10.next = 17;\n                        break;\n                      }\n                      this.addNativeFontFace(nativeFontFace);\n                      _context10.prev = 7;\n                      _context10.next = 10;\n                      return nativeFontFace.loaded;\n                    case 10:\n                      _context10.next = 17;\n                      break;\n                    case 12:\n                      _context10.prev = 12;\n                      _context10.t0 = _context10[\"catch\"](7);\n                      (0, _util.warn)(\"Failed to load font '\".concat(nativeFontFace.family, \"': '\").concat(_context10.t0, \"'.\"));\n                      font.disableFontFace = true;\n                      throw _context10.t0;\n                    case 17:\n                      return _context10.abrupt(\"return\");\n                    case 18:\n                      rule = font.createFontFaceRule();\n                      if (!rule) {\n                        _context10.next = 25;\n                        break;\n                      }\n                      this.insertRule(rule);\n                      if (!this.isSyncFontLoadingSupported) {\n                        _context10.next = 23;\n                        break;\n                      }\n                      return _context10.abrupt(\"return\");\n                    case 23:\n                      _context10.next = 25;\n                      return new Promise(function (resolve) {\n                        var request = _this30._queueLoadingCallback(resolve);\n                        _this30._prepareFontLoadEvent(font, request);\n                      });\n                    case 25:\n                    case \"end\":\n                      return _context10.stop();\n                  }\n                }, _callee10, this, [[7, 12]]);\n              }));\n              function bind(_x6) {\n                return _bind.apply(this, arguments);\n              }\n              return bind;\n            }()\n          }, {\n            key: \"isFontLoadingAPISupported\",\n            get: function get() {\n              var _this$_document;\n              var hasFonts = !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts);\n              return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n            }\n          }, {\n            key: \"isSyncFontLoadingSupported\",\n            get: function get() {\n              var supported = false;\n              if (_is_node.isNodeJS) {\n                supported = true;\n              } else if (typeof navigator !== \"undefined\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n                supported = true;\n              }\n              return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n            }\n          }, {\n            key: \"_queueLoadingCallback\",\n            value: function _queueLoadingCallback(callback) {\n              function completeRequest() {\n                (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n                request.done = true;\n                while (loadingRequests.length > 0 && loadingRequests[0].done) {\n                  var otherRequest = loadingRequests.shift();\n                  setTimeout(otherRequest.callback, 0);\n                }\n              }\n              var loadingRequests = this.loadingRequests;\n              var request = {\n                done: false,\n                complete: completeRequest,\n                callback: callback\n              };\n              loadingRequests.push(request);\n              return request;\n            }\n          }, {\n            key: \"_loadTestFont\",\n            get: function get() {\n              var testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n              return (0, _util.shadow)(this, \"_loadTestFont\", testFont);\n            }\n          }, {\n            key: \"_prepareFontLoadEvent\",\n            value: function _prepareFontLoadEvent(font, request) {\n              function int32(data, offset) {\n                return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n              }\n              function spliceString(s, offset, remove, insert) {\n                var chunk1 = s.substring(0, offset);\n                var chunk2 = s.substring(offset + remove);\n                return chunk1 + insert + chunk2;\n              }\n              var i, ii;\n              var canvas = this._document.createElement(\"canvas\");\n              canvas.width = 1;\n              canvas.height = 1;\n              var ctx = canvas.getContext(\"2d\");\n              var called = 0;\n              function isFontReady(name, callback) {\n                if (++called > 30) {\n                  (0, _util.warn)(\"Load test font never loaded.\");\n                  callback();\n                  return;\n                }\n                ctx.font = \"30px \" + name;\n                ctx.fillText(\".\", 0, 20);\n                var imageData = ctx.getImageData(0, 0, 1, 1);\n                if (imageData.data[3] > 0) {\n                  callback();\n                  return;\n                }\n                setTimeout(isFontReady.bind(null, name, callback));\n              }\n              var loadTestFontId = \"lt\".concat(Date.now()).concat(this.loadTestFontId++);\n              var data = this._loadTestFont;\n              var COMMENT_OFFSET = 976;\n              data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n              var CFF_CHECKSUM_OFFSET = 16;\n              var XXXX_VALUE = 0x58585858;\n              var checksum = int32(data, CFF_CHECKSUM_OFFSET);\n              for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n                checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n              }\n              if (i < loadTestFontId.length) {\n                checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n              }\n              data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n              var url = \"url(data:font/opentype;base64,\".concat(btoa(data), \");\");\n              var rule = \"@font-face {font-family:\\\"\".concat(loadTestFontId, \"\\\";src:\").concat(url, \"}\");\n              this.insertRule(rule);\n              var div = this._document.createElement(\"div\");\n              div.style.visibility = \"hidden\";\n              div.style.width = div.style.height = \"10px\";\n              div.style.position = \"absolute\";\n              div.style.top = div.style.left = \"0px\";\n              for (var _i8 = 0, _arr = [font.loadedName, loadTestFontId]; _i8 < _arr.length; _i8++) {\n                var name = _arr[_i8];\n                var span = this._document.createElement(\"span\");\n                span.textContent = \"Hi\";\n                span.style.fontFamily = name;\n                div.append(span);\n              }\n              this._document.body.append(div);\n              isFontReady(loadTestFontId, function () {\n                div.remove();\n                request.complete();\n              });\n            }\n          }]);\n          return FontLoader;\n        }();\n        exports.FontLoader = FontLoader;\n        var FontFaceObject = /*#__PURE__*/function () {\n          function FontFaceObject(translatedData, _ref42) {\n            var _ref42$isEvalSupporte = _ref42.isEvalSupported,\n              isEvalSupported = _ref42$isEvalSupporte === void 0 ? true : _ref42$isEvalSupporte,\n              _ref42$disableFontFac = _ref42.disableFontFace,\n              disableFontFace = _ref42$disableFontFac === void 0 ? false : _ref42$disableFontFac,\n              _ref42$ignoreErrors = _ref42.ignoreErrors,\n              ignoreErrors = _ref42$ignoreErrors === void 0 ? false : _ref42$ignoreErrors,\n              _ref42$inspectFont = _ref42.inspectFont,\n              inspectFont = _ref42$inspectFont === void 0 ? null : _ref42$inspectFont;\n            _classCallCheck(this, FontFaceObject);\n            this.compiledGlyphs = Object.create(null);\n            for (var i in translatedData) {\n              this[i] = translatedData[i];\n            }\n            this.isEvalSupported = isEvalSupported !== false;\n            this.disableFontFace = disableFontFace === true;\n            this.ignoreErrors = ignoreErrors === true;\n            this._inspectFont = inspectFont;\n          }\n          _createClass(FontFaceObject, [{\n            key: \"createNativeFontFace\",\n            value: function createNativeFontFace() {\n              var _this$_inspectFont;\n              if (!this.data || this.disableFontFace) {\n                return null;\n              }\n              var nativeFontFace;\n              if (!this.cssFontInfo) {\n                nativeFontFace = new FontFace(this.loadedName, this.data, {});\n              } else {\n                var css = {\n                  weight: this.cssFontInfo.fontWeight\n                };\n                if (this.cssFontInfo.italicAngle) {\n                  css.style = \"oblique \".concat(this.cssFontInfo.italicAngle, \"deg\");\n                }\n                nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n              }\n              (_this$_inspectFont = this._inspectFont) === null || _this$_inspectFont === void 0 ? void 0 : _this$_inspectFont.call(this, this);\n              return nativeFontFace;\n            }\n          }, {\n            key: \"createFontFaceRule\",\n            value: function createFontFaceRule() {\n              var _this$_inspectFont2;\n              if (!this.data || this.disableFontFace) {\n                return null;\n              }\n              var data = (0, _util.bytesToString)(this.data);\n              var url = \"url(data:\".concat(this.mimetype, \";base64,\").concat(btoa(data), \");\");\n              var rule;\n              if (!this.cssFontInfo) {\n                rule = \"@font-face {font-family:\\\"\".concat(this.loadedName, \"\\\";src:\").concat(url, \"}\");\n              } else {\n                var css = \"font-weight: \".concat(this.cssFontInfo.fontWeight, \";\");\n                if (this.cssFontInfo.italicAngle) {\n                  css += \"font-style: oblique \".concat(this.cssFontInfo.italicAngle, \"deg;\");\n                }\n                rule = \"@font-face {font-family:\\\"\".concat(this.cssFontInfo.fontFamily, \"\\\";\").concat(css, \"src:\").concat(url, \"}\");\n              }\n              (_this$_inspectFont2 = this._inspectFont) === null || _this$_inspectFont2 === void 0 ? void 0 : _this$_inspectFont2.call(this, this, url);\n              return rule;\n            }\n          }, {\n            key: \"getPathGenerator\",\n            value: function getPathGenerator(objs, character) {\n              if (this.compiledGlyphs[character] !== undefined) {\n                return this.compiledGlyphs[character];\n              }\n              var cmds;\n              try {\n                cmds = objs.get(this.loadedName + \"_path_\" + character);\n              } catch (ex) {\n                if (!this.ignoreErrors) {\n                  throw ex;\n                }\n                (0, _util.warn)(\"getPathGenerator - ignoring character: \\\"\".concat(ex, \"\\\".\"));\n                return this.compiledGlyphs[character] = function (c, size) {};\n              }\n              if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {\n                var jsBuf = [];\n                var _iterator44 = _createForOfIteratorHelper(cmds),\n                  _step44;\n                try {\n                  for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n                    var current = _step44.value;\n                    var args = current.args !== undefined ? current.args.join(\",\") : \"\";\n                    jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n                  }\n                } catch (err) {\n                  _iterator44.e(err);\n                } finally {\n                  _iterator44.f();\n                }\n                return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n              }\n              return this.compiledGlyphs[character] = function (c, size) {\n                var _iterator45 = _createForOfIteratorHelper(cmds),\n                  _step45;\n                try {\n                  for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n                    var _current = _step45.value;\n                    if (_current.cmd === \"scale\") {\n                      _current.args = [size, -size];\n                    }\n                    c[_current.cmd].apply(c, _current.args);\n                  }\n                } catch (err) {\n                  _iterator45.e(err);\n                } finally {\n                  _iterator45.f();\n                }\n              };\n            }\n          }]);\n          return FontFaceObject;\n        }();\n        exports.FontFaceObject = FontFaceObject;\n\n        /***/\n      }, /* 10 */\n      /***/function (__unused_webpack_module, exports) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.isNodeJS = void 0;\n        var isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\n        exports.isNodeJS = isNodeJS;\n\n        /***/\n      }, /* 11 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.CanvasGraphics = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _display_utils = __w_pdfjs_require__(6);\n        var _pattern_helper = __w_pdfjs_require__(12);\n        var _image_utils = __w_pdfjs_require__(13);\n        var _is_node = __w_pdfjs_require__(10);\n        var MIN_FONT_SIZE = 16;\n        var MAX_FONT_SIZE = 100;\n        var MAX_GROUP_SIZE = 4096;\n        var EXECUTION_TIME = 15;\n        var EXECUTION_STEPS = 10;\n        var MAX_SIZE_TO_COMPILE = 1000;\n        var FULL_CHUNK_HEIGHT = 16;\n        function mirrorContextOperations(ctx, destCtx) {\n          if (ctx._removeMirroring) {\n            throw new Error(\"Context is already forwarding operations.\");\n          }\n          ctx.__originalSave = ctx.save;\n          ctx.__originalRestore = ctx.restore;\n          ctx.__originalRotate = ctx.rotate;\n          ctx.__originalScale = ctx.scale;\n          ctx.__originalTranslate = ctx.translate;\n          ctx.__originalTransform = ctx.transform;\n          ctx.__originalSetTransform = ctx.setTransform;\n          ctx.__originalResetTransform = ctx.resetTransform;\n          ctx.__originalClip = ctx.clip;\n          ctx.__originalMoveTo = ctx.moveTo;\n          ctx.__originalLineTo = ctx.lineTo;\n          ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n          ctx.__originalRect = ctx.rect;\n          ctx.__originalClosePath = ctx.closePath;\n          ctx.__originalBeginPath = ctx.beginPath;\n          ctx._removeMirroring = function () {\n            ctx.save = ctx.__originalSave;\n            ctx.restore = ctx.__originalRestore;\n            ctx.rotate = ctx.__originalRotate;\n            ctx.scale = ctx.__originalScale;\n            ctx.translate = ctx.__originalTranslate;\n            ctx.transform = ctx.__originalTransform;\n            ctx.setTransform = ctx.__originalSetTransform;\n            ctx.resetTransform = ctx.__originalResetTransform;\n            ctx.clip = ctx.__originalClip;\n            ctx.moveTo = ctx.__originalMoveTo;\n            ctx.lineTo = ctx.__originalLineTo;\n            ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n            ctx.rect = ctx.__originalRect;\n            ctx.closePath = ctx.__originalClosePath;\n            ctx.beginPath = ctx.__originalBeginPath;\n            delete ctx._removeMirroring;\n          };\n          ctx.save = function ctxSave() {\n            destCtx.save();\n            this.__originalSave();\n          };\n          ctx.restore = function ctxRestore() {\n            destCtx.restore();\n            this.__originalRestore();\n          };\n          ctx.translate = function ctxTranslate(x, y) {\n            destCtx.translate(x, y);\n            this.__originalTranslate(x, y);\n          };\n          ctx.scale = function ctxScale(x, y) {\n            destCtx.scale(x, y);\n            this.__originalScale(x, y);\n          };\n          ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n            destCtx.transform(a, b, c, d, e, f);\n            this.__originalTransform(a, b, c, d, e, f);\n          };\n          ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n            destCtx.setTransform(a, b, c, d, e, f);\n            this.__originalSetTransform(a, b, c, d, e, f);\n          };\n          ctx.resetTransform = function ctxResetTransform() {\n            destCtx.resetTransform();\n            this.__originalResetTransform();\n          };\n          ctx.rotate = function ctxRotate(angle) {\n            destCtx.rotate(angle);\n            this.__originalRotate(angle);\n          };\n          ctx.clip = function ctxRotate(rule) {\n            destCtx.clip(rule);\n            this.__originalClip(rule);\n          };\n          ctx.moveTo = function (x, y) {\n            destCtx.moveTo(x, y);\n            this.__originalMoveTo(x, y);\n          };\n          ctx.lineTo = function (x, y) {\n            destCtx.lineTo(x, y);\n            this.__originalLineTo(x, y);\n          };\n          ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n            destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n            this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n          };\n          ctx.rect = function (x, y, width, height) {\n            destCtx.rect(x, y, width, height);\n            this.__originalRect(x, y, width, height);\n          };\n          ctx.closePath = function () {\n            destCtx.closePath();\n            this.__originalClosePath();\n          };\n          ctx.beginPath = function () {\n            destCtx.beginPath();\n            this.__originalBeginPath();\n          };\n        }\n        var CachedCanvases = /*#__PURE__*/function () {\n          function CachedCanvases(canvasFactory) {\n            _classCallCheck(this, CachedCanvases);\n            this.canvasFactory = canvasFactory;\n            this.cache = Object.create(null);\n          }\n          _createClass(CachedCanvases, [{\n            key: \"getCanvas\",\n            value: function getCanvas(id, width, height) {\n              var canvasEntry;\n              if (this.cache[id] !== undefined) {\n                canvasEntry = this.cache[id];\n                this.canvasFactory.reset(canvasEntry, width, height);\n              } else {\n                canvasEntry = this.canvasFactory.create(width, height);\n                this.cache[id] = canvasEntry;\n              }\n              return canvasEntry;\n            }\n          }, {\n            key: \"delete\",\n            value: function _delete(id) {\n              delete this.cache[id];\n            }\n          }, {\n            key: \"clear\",\n            value: function clear() {\n              for (var id in this.cache) {\n                var canvasEntry = this.cache[id];\n                this.canvasFactory.destroy(canvasEntry);\n                delete this.cache[id];\n              }\n            }\n          }]);\n          return CachedCanvases;\n        }();\n        function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n          var _ref43 = (0, _display_utils.getCurrentTransform)(ctx),\n            _ref44 = _slicedToArray(_ref43, 6),\n            a = _ref44[0],\n            b = _ref44[1],\n            c = _ref44[2],\n            d = _ref44[3],\n            tx = _ref44[4],\n            ty = _ref44[5];\n          if (b === 0 && c === 0) {\n            var tlX = destX * a + tx;\n            var rTlX = Math.round(tlX);\n            var tlY = destY * d + ty;\n            var rTlY = Math.round(tlY);\n            var brX = (destX + destW) * a + tx;\n            var rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n            var brY = (destY + destH) * d + ty;\n            var rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n            ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n            ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n            ctx.setTransform(a, b, c, d, tx, ty);\n            return [rWidth, rHeight];\n          }\n          if (a === 0 && d === 0) {\n            var _tlX = destY * c + tx;\n            var _rTlX = Math.round(_tlX);\n            var _tlY = destX * b + ty;\n            var _rTlY = Math.round(_tlY);\n            var _brX = (destY + destH) * c + tx;\n            var _rWidth = Math.abs(Math.round(_brX) - _rTlX) || 1;\n            var _brY = (destX + destW) * b + ty;\n            var _rHeight = Math.abs(Math.round(_brY) - _rTlY) || 1;\n            ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, _rTlX, _rTlY);\n            ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, _rHeight, _rWidth);\n            ctx.setTransform(a, b, c, d, tx, ty);\n            return [_rHeight, _rWidth];\n          }\n          ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n          var scaleX = Math.hypot(a, b);\n          var scaleY = Math.hypot(c, d);\n          return [scaleX * destW, scaleY * destH];\n        }\n        function compileType3Glyph(imgData) {\n          var width = imgData.width,\n            height = imgData.height;\n          if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n            return null;\n          }\n          var POINT_TO_PROCESS_LIMIT = 1000;\n          var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n          var width1 = width + 1;\n          var points = new Uint8Array(width1 * (height + 1));\n          var i, j, j0;\n          var lineSize = width + 7 & ~7;\n          var data = new Uint8Array(lineSize * height),\n            pos = 0;\n          var _iterator46 = _createForOfIteratorHelper(imgData.data),\n            _step46;\n          try {\n            for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n              var elem = _step46.value;\n              var mask = 128;\n              while (mask > 0) {\n                data[pos++] = elem & mask ? 0 : 255;\n                mask >>= 1;\n              }\n            }\n          } catch (err) {\n            _iterator46.e(err);\n          } finally {\n            _iterator46.f();\n          }\n          var count = 0;\n          pos = 0;\n          if (data[pos] !== 0) {\n            points[0] = 1;\n            ++count;\n          }\n          for (j = 1; j < width; j++) {\n            if (data[pos] !== data[pos + 1]) {\n              points[j] = data[pos] ? 2 : 1;\n              ++count;\n            }\n            pos++;\n          }\n          if (data[pos] !== 0) {\n            points[j] = 2;\n            ++count;\n          }\n          for (i = 1; i < height; i++) {\n            pos = i * lineSize;\n            j0 = i * width1;\n            if (data[pos - lineSize] !== data[pos]) {\n              points[j0] = data[pos] ? 1 : 8;\n              ++count;\n            }\n            var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n            for (j = 1; j < width; j++) {\n              sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n              if (POINT_TYPES[sum]) {\n                points[j0 + j] = POINT_TYPES[sum];\n                ++count;\n              }\n              pos++;\n            }\n            if (data[pos - lineSize] !== data[pos]) {\n              points[j0 + j] = data[pos] ? 2 : 4;\n              ++count;\n            }\n            if (count > POINT_TO_PROCESS_LIMIT) {\n              return null;\n            }\n          }\n          pos = lineSize * (height - 1);\n          j0 = i * width1;\n          if (data[pos] !== 0) {\n            points[j0] = 8;\n            ++count;\n          }\n          for (j = 1; j < width; j++) {\n            if (data[pos] !== data[pos + 1]) {\n              points[j0 + j] = data[pos] ? 4 : 8;\n              ++count;\n            }\n            pos++;\n          }\n          if (data[pos] !== 0) {\n            points[j0 + j] = 4;\n            ++count;\n          }\n          if (count > POINT_TO_PROCESS_LIMIT) {\n            return null;\n          }\n          var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n          var path = new Path2D();\n          for (i = 0; count && i <= height; i++) {\n            var p = i * width1;\n            var end = p + width;\n            while (p < end && !points[p]) {\n              p++;\n            }\n            if (p === end) {\n              continue;\n            }\n            path.moveTo(p % width1, i);\n            var p0 = p;\n            var type = points[p];\n            do {\n              var step = steps[type];\n              do {\n                p += step;\n              } while (!points[p]);\n              var pp = points[p];\n              if (pp !== 5 && pp !== 10) {\n                type = pp;\n                points[p] = 0;\n              } else {\n                type = pp & 0x33 * type >> 4;\n                points[p] &= type >> 2 | type << 2;\n              }\n              path.lineTo(p % width1, p / width1 | 0);\n              if (!points[p]) {\n                --count;\n              }\n            } while (p0 !== p);\n            --i;\n          }\n          data = null;\n          points = null;\n          var drawOutline = function drawOutline(c) {\n            c.save();\n            c.scale(1 / width, -1 / height);\n            c.translate(0, -height);\n            c.fill(path);\n            c.beginPath();\n            c.restore();\n          };\n          return drawOutline;\n        }\n        var CanvasExtraState = /*#__PURE__*/function () {\n          function CanvasExtraState(width, height) {\n            _classCallCheck(this, CanvasExtraState);\n            this.alphaIsShape = false;\n            this.fontSize = 0;\n            this.fontSizeScale = 1;\n            this.textMatrix = _util.IDENTITY_MATRIX;\n            this.textMatrixScale = 1;\n            this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n            this.leading = 0;\n            this.x = 0;\n            this.y = 0;\n            this.lineX = 0;\n            this.lineY = 0;\n            this.charSpacing = 0;\n            this.wordSpacing = 0;\n            this.textHScale = 1;\n            this.textRenderingMode = _util.TextRenderingMode.FILL;\n            this.textRise = 0;\n            this.fillColor = \"#000000\";\n            this.strokeColor = \"#000000\";\n            this.patternFill = false;\n            this.fillAlpha = 1;\n            this.strokeAlpha = 1;\n            this.lineWidth = 1;\n            this.activeSMask = null;\n            this.transferMaps = \"none\";\n            this.startNewPathAndClipBox([0, 0, width, height]);\n          }\n          _createClass(CanvasExtraState, [{\n            key: \"clone\",\n            value: function clone() {\n              var clone = Object.create(this);\n              clone.clipBox = this.clipBox.slice();\n              return clone;\n            }\n          }, {\n            key: \"setCurrentPoint\",\n            value: function setCurrentPoint(x, y) {\n              this.x = x;\n              this.y = y;\n            }\n          }, {\n            key: \"updatePathMinMax\",\n            value: function updatePathMinMax(transform, x, y) {\n              var _util$Util$applyTrans = _util.Util.applyTransform([x, y], transform);\n              var _util$Util$applyTrans2 = _slicedToArray(_util$Util$applyTrans, 2);\n              x = _util$Util$applyTrans2[0];\n              y = _util$Util$applyTrans2[1];\n              this.minX = Math.min(this.minX, x);\n              this.minY = Math.min(this.minY, y);\n              this.maxX = Math.max(this.maxX, x);\n              this.maxY = Math.max(this.maxY, y);\n            }\n          }, {\n            key: \"updateRectMinMax\",\n            value: function updateRectMinMax(transform, rect) {\n              var p1 = _util.Util.applyTransform(rect, transform);\n              var p2 = _util.Util.applyTransform(rect.slice(2), transform);\n              this.minX = Math.min(this.minX, p1[0], p2[0]);\n              this.minY = Math.min(this.minY, p1[1], p2[1]);\n              this.maxX = Math.max(this.maxX, p1[0], p2[0]);\n              this.maxY = Math.max(this.maxY, p1[1], p2[1]);\n            }\n          }, {\n            key: \"updateScalingPathMinMax\",\n            value: function updateScalingPathMinMax(transform, minMax) {\n              _util.Util.scaleMinMax(transform, minMax);\n              this.minX = Math.min(this.minX, minMax[0]);\n              this.maxX = Math.max(this.maxX, minMax[1]);\n              this.minY = Math.min(this.minY, minMax[2]);\n              this.maxY = Math.max(this.maxY, minMax[3]);\n            }\n          }, {\n            key: \"updateCurvePathMinMax\",\n            value: function updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n              var box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n              if (minMax) {\n                minMax[0] = Math.min(minMax[0], box[0], box[2]);\n                minMax[1] = Math.max(minMax[1], box[0], box[2]);\n                minMax[2] = Math.min(minMax[2], box[1], box[3]);\n                minMax[3] = Math.max(minMax[3], box[1], box[3]);\n                return;\n              }\n              this.updateRectMinMax(transform, box);\n            }\n          }, {\n            key: \"getPathBoundingBox\",\n            value: function getPathBoundingBox() {\n              var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;\n              var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n              var box = [this.minX, this.minY, this.maxX, this.maxY];\n              if (pathType === _pattern_helper.PathType.STROKE) {\n                if (!transform) {\n                  (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n                }\n                var scale = _util.Util.singularValueDecompose2dScale(transform);\n                var xStrokePad = scale[0] * this.lineWidth / 2;\n                var yStrokePad = scale[1] * this.lineWidth / 2;\n                box[0] -= xStrokePad;\n                box[1] -= yStrokePad;\n                box[2] += xStrokePad;\n                box[3] += yStrokePad;\n              }\n              return box;\n            }\n          }, {\n            key: \"updateClipFromPath\",\n            value: function updateClipFromPath() {\n              var intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n              this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n            }\n          }, {\n            key: \"isEmptyClip\",\n            value: function isEmptyClip() {\n              return this.minX === Infinity;\n            }\n          }, {\n            key: \"startNewPathAndClipBox\",\n            value: function startNewPathAndClipBox(box) {\n              this.clipBox = box;\n              this.minX = Infinity;\n              this.minY = Infinity;\n              this.maxX = 0;\n              this.maxY = 0;\n            }\n          }, {\n            key: \"getClippedPathBoundingBox\",\n            value: function getClippedPathBoundingBox() {\n              var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;\n              var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n              return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n            }\n          }]);\n          return CanvasExtraState;\n        }();\n        function putBinaryImageData(ctx, imgData) {\n          if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n            ctx.putImageData(imgData, 0, 0);\n            return;\n          }\n          var height = imgData.height,\n            width = imgData.width;\n          var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n          var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n          var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n          var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n          var srcPos = 0,\n            destPos;\n          var src = imgData.data;\n          var dest = chunkImgData.data;\n          var i, j, thisChunkHeight, elemsInThisChunk;\n          if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n            var srcLength = src.byteLength;\n            var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n            var dest32DataLength = dest32.length;\n            var fullSrcDiff = width + 7 >> 3;\n            var white = 0xffffffff;\n            var black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n            for (i = 0; i < totalChunks; i++) {\n              thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n              destPos = 0;\n              for (j = 0; j < thisChunkHeight; j++) {\n                var srcDiff = srcLength - srcPos;\n                var k = 0;\n                var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                var kEndUnrolled = kEnd & ~7;\n                var mask = 0;\n                var srcByte = 0;\n                for (; k < kEndUnrolled; k += 8) {\n                  srcByte = src[srcPos++];\n                  dest32[destPos++] = srcByte & 128 ? white : black;\n                  dest32[destPos++] = srcByte & 64 ? white : black;\n                  dest32[destPos++] = srcByte & 32 ? white : black;\n                  dest32[destPos++] = srcByte & 16 ? white : black;\n                  dest32[destPos++] = srcByte & 8 ? white : black;\n                  dest32[destPos++] = srcByte & 4 ? white : black;\n                  dest32[destPos++] = srcByte & 2 ? white : black;\n                  dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for (; k < kEnd; k++) {\n                  if (mask === 0) {\n                    srcByte = src[srcPos++];\n                    mask = 128;\n                  }\n                  dest32[destPos++] = srcByte & mask ? white : black;\n                  mask >>= 1;\n                }\n              }\n              while (destPos < dest32DataLength) {\n                dest32[destPos++] = 0;\n              }\n              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n            }\n          } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n            j = 0;\n            elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n            for (i = 0; i < fullChunks; i++) {\n              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n              srcPos += elemsInThisChunk;\n              ctx.putImageData(chunkImgData, 0, j);\n              j += FULL_CHUNK_HEIGHT;\n            }\n            if (i < totalChunks) {\n              elemsInThisChunk = width * partialChunkHeight * 4;\n              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n              ctx.putImageData(chunkImgData, 0, j);\n            }\n          } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n            thisChunkHeight = FULL_CHUNK_HEIGHT;\n            elemsInThisChunk = width * thisChunkHeight;\n            for (i = 0; i < totalChunks; i++) {\n              if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n              }\n              destPos = 0;\n              for (j = elemsInThisChunk; j--;) {\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n              }\n              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n            }\n          } else {\n            throw new Error(\"bad image kind: \".concat(imgData.kind));\n          }\n        }\n        function putBinaryImageMask(ctx, imgData) {\n          if (imgData.bitmap) {\n            ctx.drawImage(imgData.bitmap, 0, 0);\n            return;\n          }\n          var height = imgData.height,\n            width = imgData.width;\n          var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n          var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n          var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n          var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n          var srcPos = 0;\n          var src = imgData.data;\n          var dest = chunkImgData.data;\n          for (var i = 0; i < totalChunks; i++) {\n            var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            var _ref45 = (0, _image_utils.convertBlackAndWhiteToRGBA)({\n              src: src,\n              srcPos: srcPos,\n              dest: dest,\n              width: width,\n              height: thisChunkHeight,\n              nonBlackColor: 0\n            });\n            srcPos = _ref45.srcPos;\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n          }\n        }\n        function copyCtxState(sourceCtx, destCtx) {\n          var properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\", \"filter\"];\n          for (var _i9 = 0, _properties = properties; _i9 < _properties.length; _i9++) {\n            var property = _properties[_i9];\n            if (sourceCtx[property] !== undefined) {\n              destCtx[property] = sourceCtx[property];\n            }\n          }\n          if (sourceCtx.setLineDash !== undefined) {\n            destCtx.setLineDash(sourceCtx.getLineDash());\n            destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n          }\n        }\n        function resetCtxToDefault(ctx) {\n          ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n          ctx.fillRule = \"nonzero\";\n          ctx.globalAlpha = 1;\n          ctx.lineWidth = 1;\n          ctx.lineCap = \"butt\";\n          ctx.lineJoin = \"miter\";\n          ctx.miterLimit = 10;\n          ctx.globalCompositeOperation = \"source-over\";\n          ctx.font = \"10px sans-serif\";\n          if (ctx.setLineDash !== undefined) {\n            ctx.setLineDash([]);\n            ctx.lineDashOffset = 0;\n          }\n          if (!_is_node.isNodeJS) {\n            ctx.filter = \"none\";\n          }\n        }\n        function composeSMaskBackdrop(bytes, r0, g0, b0) {\n          var length = bytes.length;\n          for (var i = 3; i < length; i += 4) {\n            var alpha = bytes[i];\n            if (alpha === 0) {\n              bytes[i - 3] = r0;\n              bytes[i - 2] = g0;\n              bytes[i - 1] = b0;\n            } else if (alpha < 255) {\n              var alpha_ = 255 - alpha;\n              bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n              bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n              bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n            }\n          }\n        }\n        function composeSMaskAlpha(maskData, layerData, transferMap) {\n          var length = maskData.length;\n          var scale = 1 / 255;\n          for (var i = 3; i < length; i += 4) {\n            var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n            layerData[i] = layerData[i] * alpha * scale | 0;\n          }\n        }\n        function composeSMaskLuminosity(maskData, layerData, transferMap) {\n          var length = maskData.length;\n          for (var i = 3; i < length; i += 4) {\n            var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n            layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n          }\n        }\n        function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n          var hasBackdrop = !!backdrop;\n          var r0 = hasBackdrop ? backdrop[0] : 0;\n          var g0 = hasBackdrop ? backdrop[1] : 0;\n          var b0 = hasBackdrop ? backdrop[2] : 0;\n          var composeFn;\n          if (subtype === \"Luminosity\") {\n            composeFn = composeSMaskLuminosity;\n          } else {\n            composeFn = composeSMaskAlpha;\n          }\n          var PIXELS_TO_PROCESS = 1048576;\n          var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n          for (var row = 0; row < height; row += chunkSize) {\n            var chunkHeight = Math.min(chunkSize, height - row);\n            var maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n            var layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n            if (hasBackdrop) {\n              composeSMaskBackdrop(maskData.data, r0, g0, b0);\n            }\n            composeFn(maskData.data, layerData.data, transferMap);\n            layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n          }\n        }\n        function composeSMask(ctx, smask, layerCtx, layerBox) {\n          var layerOffsetX = layerBox[0];\n          var layerOffsetY = layerBox[1];\n          var layerWidth = layerBox[2] - layerOffsetX;\n          var layerHeight = layerBox[3] - layerOffsetY;\n          if (layerWidth === 0 || layerHeight === 0) {\n            return;\n          }\n          genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n          ctx.save();\n          ctx.globalAlpha = 1;\n          ctx.globalCompositeOperation = \"source-over\";\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.drawImage(layerCtx.canvas, 0, 0);\n          ctx.restore();\n        }\n        function getImageSmoothingEnabled(transform, interpolate) {\n          var scale = _util.Util.singularValueDecompose2dScale(transform);\n          scale[0] = Math.fround(scale[0]);\n          scale[1] = Math.fround(scale[1]);\n          var actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n          if (interpolate !== undefined) {\n            return interpolate;\n          } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n            return true;\n          }\n          return false;\n        }\n        var LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n        var LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n        var NORMAL_CLIP = {};\n        var EO_CLIP = {};\n        var _restoreInitialState = /*#__PURE__*/new WeakSet();\n        var _drawFilter = /*#__PURE__*/new WeakSet();\n        var CanvasGraphics = /*#__PURE__*/function () {\n          function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, _ref46, annotationCanvasMap, pageColors) {\n            var optionalContentConfig = _ref46.optionalContentConfig,\n              _ref46$markedContentS = _ref46.markedContentStack,\n              markedContentStack = _ref46$markedContentS === void 0 ? null : _ref46$markedContentS;\n            _classCallCheck(this, CanvasGraphics);\n            _classPrivateMethodInitSpec(this, _drawFilter);\n            _classPrivateMethodInitSpec(this, _restoreInitialState);\n            this.ctx = canvasCtx;\n            this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n            this.stateStack = [];\n            this.pendingClip = null;\n            this.pendingEOFill = false;\n            this.res = null;\n            this.xobjs = null;\n            this.commonObjs = commonObjs;\n            this.objs = objs;\n            this.canvasFactory = canvasFactory;\n            this.filterFactory = filterFactory;\n            this.groupStack = [];\n            this.processingType3 = null;\n            this.baseTransform = null;\n            this.baseTransformStack = [];\n            this.groupLevel = 0;\n            this.smaskStack = [];\n            this.smaskCounter = 0;\n            this.tempSMask = null;\n            this.suspendedCtx = null;\n            this.contentVisible = true;\n            this.markedContentStack = markedContentStack || [];\n            this.optionalContentConfig = optionalContentConfig;\n            this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n            this.cachedPatterns = new Map();\n            this.annotationCanvasMap = annotationCanvasMap;\n            this.viewportScale = 1;\n            this.outputScaleX = 1;\n            this.outputScaleY = 1;\n            this.pageColors = pageColors;\n            this._cachedScaleForStroking = null;\n            this._cachedGetSinglePixelWidth = null;\n            this._cachedBitmapsMap = new Map();\n          }\n          _createClass(CanvasGraphics, [{\n            key: \"getObject\",\n            value: function getObject(data) {\n              var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n              if (typeof data === \"string\") {\n                return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n              }\n              return fallback;\n            }\n          }, {\n            key: \"beginDrawing\",\n            value: function beginDrawing(_ref47) {\n              var _this$ctx3;\n              var transform = _ref47.transform,\n                viewport = _ref47.viewport,\n                _ref47$transparency = _ref47.transparency,\n                transparency = _ref47$transparency === void 0 ? false : _ref47$transparency,\n                _ref47$background = _ref47.background,\n                background = _ref47$background === void 0 ? null : _ref47$background;\n              var width = this.ctx.canvas.width;\n              var height = this.ctx.canvas.height;\n              var savedFillStyle = this.ctx.fillStyle;\n              this.ctx.fillStyle = background || \"#ffffff\";\n              this.ctx.fillRect(0, 0, width, height);\n              this.ctx.fillStyle = savedFillStyle;\n              if (transparency) {\n                var _this$ctx;\n                var transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n                this.compositeCtx = this.ctx;\n                this.transparentCanvas = transparentCanvas.canvas;\n                this.ctx = transparentCanvas.context;\n                this.ctx.save();\n                (_this$ctx = this.ctx).transform.apply(_this$ctx, _toConsumableArray((0, _display_utils.getCurrentTransform)(this.compositeCtx)));\n              }\n              this.ctx.save();\n              resetCtxToDefault(this.ctx);\n              if (transform) {\n                var _this$ctx2;\n                (_this$ctx2 = this.ctx).transform.apply(_this$ctx2, _toConsumableArray(transform));\n                this.outputScaleX = transform[0];\n                this.outputScaleY = transform[0];\n              }\n              (_this$ctx3 = this.ctx).transform.apply(_this$ctx3, _toConsumableArray(viewport.transform));\n              this.viewportScale = viewport.scale;\n              this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n            }\n          }, {\n            key: \"executeOperatorList\",\n            value: function executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n              var argsArray = operatorList.argsArray;\n              var fnArray = operatorList.fnArray;\n              var i = executionStartIdx || 0;\n              var argsArrayLen = argsArray.length;\n              if (argsArrayLen === i) {\n                return i;\n              }\n              var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n              var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n              var steps = 0;\n              var commonObjs = this.commonObjs;\n              var objs = this.objs;\n              var fnId;\n              while (true) {\n                if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                  stepper.breakIt(i, continueCallback);\n                  return i;\n                }\n                fnId = fnArray[i];\n                if (fnId !== _util.OPS.dependency) {\n                  this[fnId].apply(this, argsArray[i]);\n                } else {\n                  var _iterator47 = _createForOfIteratorHelper(argsArray[i]),\n                    _step47;\n                  try {\n                    for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n                      var depObjId = _step47.value;\n                      var objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                      if (!objsPool.has(depObjId)) {\n                        objsPool.get(depObjId, continueCallback);\n                        return i;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator47.e(err);\n                  } finally {\n                    _iterator47.f();\n                  }\n                }\n                i++;\n                if (i === argsArrayLen) {\n                  return i;\n                }\n                if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                  if (Date.now() > endTime) {\n                    continueCallback();\n                    return i;\n                  }\n                  steps = 0;\n                }\n              }\n            }\n          }, {\n            key: \"endDrawing\",\n            value: function endDrawing() {\n              _classPrivateMethodGet(this, _restoreInitialState, _restoreInitialState2).call(this);\n              this.cachedCanvases.clear();\n              this.cachedPatterns.clear();\n              var _iterator48 = _createForOfIteratorHelper(this._cachedBitmapsMap.values()),\n                _step48;\n              try {\n                for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n                  var cache = _step48.value;\n                  var _iterator49 = _createForOfIteratorHelper(cache.values()),\n                    _step49;\n                  try {\n                    for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {\n                      var canvas = _step49.value;\n                      if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                        canvas.width = canvas.height = 0;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator49.e(err);\n                  } finally {\n                    _iterator49.f();\n                  }\n                  cache.clear();\n                }\n              } catch (err) {\n                _iterator48.e(err);\n              } finally {\n                _iterator48.f();\n              }\n              this._cachedBitmapsMap.clear();\n              _classPrivateMethodGet(this, _drawFilter, _drawFilter2).call(this);\n            }\n          }, {\n            key: \"_scaleImage\",\n            value: function _scaleImage(img, inverseTransform) {\n              var width = img.width;\n              var height = img.height;\n              var widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n              var heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n              var paintWidth = width,\n                paintHeight = height;\n              var tmpCanvasId = \"prescale1\";\n              var tmpCanvas, tmpCtx;\n              while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n                var newWidth = paintWidth,\n                  newHeight = paintHeight;\n                if (widthScale > 2 && paintWidth > 1) {\n                  newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                  widthScale /= paintWidth / newWidth;\n                }\n                if (heightScale > 2 && paintHeight > 1) {\n                  newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                  heightScale /= paintHeight / newHeight;\n                }\n                tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n                tmpCtx = tmpCanvas.context;\n                tmpCtx.clearRect(0, 0, newWidth, newHeight);\n                tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n                img = tmpCanvas.canvas;\n                paintWidth = newWidth;\n                paintHeight = newHeight;\n                tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n              }\n              return {\n                img: img,\n                paintWidth: paintWidth,\n                paintHeight: paintHeight\n              };\n            }\n          }, {\n            key: \"_createMaskCanvas\",\n            value: function _createMaskCanvas(img) {\n              var ctx = this.ctx;\n              var width = img.width,\n                height = img.height;\n              var fillColor = this.current.fillColor;\n              var isPatternFill = this.current.patternFill;\n              var currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n              var cache, cacheKey, scaled, maskCanvas;\n              if ((img.bitmap || img.data) && img.count > 1) {\n                var mainKey = img.bitmap || img.data.buffer;\n                cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);\n                cache = this._cachedBitmapsMap.get(mainKey);\n                if (!cache) {\n                  cache = new Map();\n                  this._cachedBitmapsMap.set(mainKey, cache);\n                }\n                var cachedImage = cache.get(cacheKey);\n                if (cachedImage && !isPatternFill) {\n                  var _offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                  var _offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                  return {\n                    canvas: cachedImage,\n                    offsetX: _offsetX,\n                    offsetY: _offsetY\n                  };\n                }\n                scaled = cachedImage;\n              }\n              if (!scaled) {\n                maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n                putBinaryImageMask(maskCanvas.context, img);\n              }\n              var maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);\n              maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n              var cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);\n              var cord2 = _util.Util.applyTransform([width, height], maskToCanvas);\n              var rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);\n              var drawnWidth = Math.round(rect[2] - rect[0]) || 1;\n              var drawnHeight = Math.round(rect[3] - rect[1]) || 1;\n              var fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n              var fillCtx = fillCanvas.context;\n              var offsetX = Math.min(cord1[0], cord2[0]);\n              var offsetY = Math.min(cord1[1], cord2[1]);\n              fillCtx.translate(-offsetX, -offsetY);\n              fillCtx.transform.apply(fillCtx, _toConsumableArray(maskToCanvas));\n              if (!scaled) {\n                scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));\n                scaled = scaled.img;\n                if (cache && isPatternFill) {\n                  cache.set(cacheKey, scaled);\n                }\n              }\n              fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);\n              drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n              fillCtx.globalCompositeOperation = \"source-in\";\n              var inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);\n              fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n              fillCtx.fillRect(0, 0, width, height);\n              if (cache && !isPatternFill) {\n                this.cachedCanvases.delete(\"fillCanvas\");\n                cache.set(cacheKey, fillCanvas.canvas);\n              }\n              return {\n                canvas: fillCanvas.canvas,\n                offsetX: Math.round(offsetX),\n                offsetY: Math.round(offsetY)\n              };\n            }\n          }, {\n            key: \"setLineWidth\",\n            value: function setLineWidth(width) {\n              if (width !== this.current.lineWidth) {\n                this._cachedScaleForStroking = null;\n              }\n              this.current.lineWidth = width;\n              this.ctx.lineWidth = width;\n            }\n          }, {\n            key: \"setLineCap\",\n            value: function setLineCap(style) {\n              this.ctx.lineCap = LINE_CAP_STYLES[style];\n            }\n          }, {\n            key: \"setLineJoin\",\n            value: function setLineJoin(style) {\n              this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n            }\n          }, {\n            key: \"setMiterLimit\",\n            value: function setMiterLimit(limit) {\n              this.ctx.miterLimit = limit;\n            }\n          }, {\n            key: \"setDash\",\n            value: function setDash(dashArray, dashPhase) {\n              var ctx = this.ctx;\n              if (ctx.setLineDash !== undefined) {\n                ctx.setLineDash(dashArray);\n                ctx.lineDashOffset = dashPhase;\n              }\n            }\n          }, {\n            key: \"setRenderingIntent\",\n            value: function setRenderingIntent(intent) {}\n          }, {\n            key: \"setFlatness\",\n            value: function setFlatness(flatness) {}\n          }, {\n            key: \"setGState\",\n            value: function setGState(states) {\n              var _iterator50 = _createForOfIteratorHelper(states),\n                _step50;\n              try {\n                for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {\n                  var _step50$value = _slicedToArray(_step50.value, 2),\n                    key = _step50$value[0],\n                    value = _step50$value[1];\n                  switch (key) {\n                    case \"LW\":\n                      this.setLineWidth(value);\n                      break;\n                    case \"LC\":\n                      this.setLineCap(value);\n                      break;\n                    case \"LJ\":\n                      this.setLineJoin(value);\n                      break;\n                    case \"ML\":\n                      this.setMiterLimit(value);\n                      break;\n                    case \"D\":\n                      this.setDash(value[0], value[1]);\n                      break;\n                    case \"RI\":\n                      this.setRenderingIntent(value);\n                      break;\n                    case \"FL\":\n                      this.setFlatness(value);\n                      break;\n                    case \"Font\":\n                      this.setFont(value[0], value[1]);\n                      break;\n                    case \"CA\":\n                      this.current.strokeAlpha = value;\n                      break;\n                    case \"ca\":\n                      this.current.fillAlpha = value;\n                      this.ctx.globalAlpha = value;\n                      break;\n                    case \"BM\":\n                      this.ctx.globalCompositeOperation = value;\n                      break;\n                    case \"SMask\":\n                      this.current.activeSMask = value ? this.tempSMask : null;\n                      this.tempSMask = null;\n                      this.checkSMaskState();\n                      break;\n                    case \"TR\":\n                      this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                      break;\n                  }\n                }\n              } catch (err) {\n                _iterator50.e(err);\n              } finally {\n                _iterator50.f();\n              }\n            }\n          }, {\n            key: \"inSMaskMode\",\n            get: function get() {\n              return !!this.suspendedCtx;\n            }\n          }, {\n            key: \"checkSMaskState\",\n            value: function checkSMaskState() {\n              var inSMaskMode = this.inSMaskMode;\n              if (this.current.activeSMask && !inSMaskMode) {\n                this.beginSMaskMode();\n              } else if (!this.current.activeSMask && inSMaskMode) {\n                this.endSMaskMode();\n              }\n            }\n          }, {\n            key: \"beginSMaskMode\",\n            value: function beginSMaskMode() {\n              if (this.inSMaskMode) {\n                throw new Error(\"beginSMaskMode called while already in smask mode\");\n              }\n              var drawnWidth = this.ctx.canvas.width;\n              var drawnHeight = this.ctx.canvas.height;\n              var cacheId = \"smaskGroupAt\" + this.groupLevel;\n              var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n              this.suspendedCtx = this.ctx;\n              this.ctx = scratchCanvas.context;\n              var ctx = this.ctx;\n              ctx.setTransform.apply(ctx, _toConsumableArray((0, _display_utils.getCurrentTransform)(this.suspendedCtx)));\n              copyCtxState(this.suspendedCtx, ctx);\n              mirrorContextOperations(ctx, this.suspendedCtx);\n              this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n            }\n          }, {\n            key: \"endSMaskMode\",\n            value: function endSMaskMode() {\n              if (!this.inSMaskMode) {\n                throw new Error(\"endSMaskMode called while not in smask mode\");\n              }\n              this.ctx._removeMirroring();\n              copyCtxState(this.ctx, this.suspendedCtx);\n              this.ctx = this.suspendedCtx;\n              this.suspendedCtx = null;\n            }\n          }, {\n            key: \"compose\",\n            value: function compose(dirtyBox) {\n              if (!this.current.activeSMask) {\n                return;\n              }\n              if (!dirtyBox) {\n                dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n              } else {\n                dirtyBox[0] = Math.floor(dirtyBox[0]);\n                dirtyBox[1] = Math.floor(dirtyBox[1]);\n                dirtyBox[2] = Math.ceil(dirtyBox[2]);\n                dirtyBox[3] = Math.ceil(dirtyBox[3]);\n              }\n              var smask = this.current.activeSMask;\n              var suspendedCtx = this.suspendedCtx;\n              composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n              this.ctx.save();\n              this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n              this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n              this.ctx.restore();\n            }\n          }, {\n            key: \"save\",\n            value: function save() {\n              if (this.inSMaskMode) {\n                copyCtxState(this.ctx, this.suspendedCtx);\n                this.suspendedCtx.save();\n              } else {\n                this.ctx.save();\n              }\n              var old = this.current;\n              this.stateStack.push(old);\n              this.current = old.clone();\n            }\n          }, {\n            key: \"restore\",\n            value: function restore() {\n              if (this.stateStack.length === 0 && this.inSMaskMode) {\n                this.endSMaskMode();\n              }\n              if (this.stateStack.length !== 0) {\n                this.current = this.stateStack.pop();\n                if (this.inSMaskMode) {\n                  this.suspendedCtx.restore();\n                  copyCtxState(this.suspendedCtx, this.ctx);\n                } else {\n                  this.ctx.restore();\n                }\n                this.checkSMaskState();\n                this.pendingClip = null;\n                this._cachedScaleForStroking = null;\n                this._cachedGetSinglePixelWidth = null;\n              }\n            }\n          }, {\n            key: \"transform\",\n            value: function transform(a, b, c, d, e, f) {\n              this.ctx.transform(a, b, c, d, e, f);\n              this._cachedScaleForStroking = null;\n              this._cachedGetSinglePixelWidth = null;\n            }\n          }, {\n            key: \"constructPath\",\n            value: function constructPath(ops, args, minMax) {\n              var ctx = this.ctx;\n              var current = this.current;\n              var x = current.x,\n                y = current.y;\n              var startX, startY;\n              var currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n              var isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n              var minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n              for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {\n                switch (ops[i] | 0) {\n                  case _util.OPS.rectangle:\n                    x = args[j++];\n                    y = args[j++];\n                    var width = args[j++];\n                    var height = args[j++];\n                    var xw = x + width;\n                    var yh = y + height;\n                    ctx.moveTo(x, y);\n                    if (width === 0 || height === 0) {\n                      ctx.lineTo(xw, yh);\n                    } else {\n                      ctx.lineTo(xw, y);\n                      ctx.lineTo(xw, yh);\n                      ctx.lineTo(x, yh);\n                    }\n                    if (!isScalingMatrix) {\n                      current.updateRectMinMax(currentTransform, [x, y, xw, yh]);\n                    }\n                    ctx.closePath();\n                    break;\n                  case _util.OPS.moveTo:\n                    x = args[j++];\n                    y = args[j++];\n                    ctx.moveTo(x, y);\n                    if (!isScalingMatrix) {\n                      current.updatePathMinMax(currentTransform, x, y);\n                    }\n                    break;\n                  case _util.OPS.lineTo:\n                    x = args[j++];\n                    y = args[j++];\n                    ctx.lineTo(x, y);\n                    if (!isScalingMatrix) {\n                      current.updatePathMinMax(currentTransform, x, y);\n                    }\n                    break;\n                  case _util.OPS.curveTo:\n                    startX = x;\n                    startY = y;\n                    x = args[j + 4];\n                    y = args[j + 5];\n                    ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n                    j += 6;\n                    break;\n                  case _util.OPS.curveTo2:\n                    startX = x;\n                    startY = y;\n                    ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n                    x = args[j + 2];\n                    y = args[j + 3];\n                    j += 4;\n                    break;\n                  case _util.OPS.curveTo3:\n                    startX = x;\n                    startY = y;\n                    x = args[j + 2];\n                    y = args[j + 3];\n                    ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n                    j += 4;\n                    break;\n                  case _util.OPS.closePath:\n                    ctx.closePath();\n                    break;\n                }\n              }\n              if (isScalingMatrix) {\n                current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n              }\n              current.setCurrentPoint(x, y);\n            }\n          }, {\n            key: \"closePath\",\n            value: function closePath() {\n              this.ctx.closePath();\n            }\n          }, {\n            key: \"stroke\",\n            value: function stroke() {\n              var consumePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n              var ctx = this.ctx;\n              var strokeColor = this.current.strokeColor;\n              ctx.globalAlpha = this.current.strokeAlpha;\n              if (this.contentVisible) {\n                if (typeof strokeColor === \"object\" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {\n                  ctx.save();\n                  ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);\n                  this.rescaleAndStroke(false);\n                  ctx.restore();\n                } else {\n                  this.rescaleAndStroke(true);\n                }\n              }\n              if (consumePath) {\n                this.consumePath(this.current.getClippedPathBoundingBox());\n              }\n              ctx.globalAlpha = this.current.fillAlpha;\n            }\n          }, {\n            key: \"closeStroke\",\n            value: function closeStroke() {\n              this.closePath();\n              this.stroke();\n            }\n          }, {\n            key: \"fill\",\n            value: function fill() {\n              var consumePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n              var ctx = this.ctx;\n              var fillColor = this.current.fillColor;\n              var isPatternFill = this.current.patternFill;\n              var needRestore = false;\n              if (isPatternFill) {\n                ctx.save();\n                ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n                needRestore = true;\n              }\n              var intersect = this.current.getClippedPathBoundingBox();\n              if (this.contentVisible && intersect !== null) {\n                if (this.pendingEOFill) {\n                  ctx.fill(\"evenodd\");\n                  this.pendingEOFill = false;\n                } else {\n                  ctx.fill();\n                }\n              }\n              if (needRestore) {\n                ctx.restore();\n              }\n              if (consumePath) {\n                this.consumePath(intersect);\n              }\n            }\n          }, {\n            key: \"eoFill\",\n            value: function eoFill() {\n              this.pendingEOFill = true;\n              this.fill();\n            }\n          }, {\n            key: \"fillStroke\",\n            value: function fillStroke() {\n              this.fill(false);\n              this.stroke(false);\n              this.consumePath();\n            }\n          }, {\n            key: \"eoFillStroke\",\n            value: function eoFillStroke() {\n              this.pendingEOFill = true;\n              this.fillStroke();\n            }\n          }, {\n            key: \"closeFillStroke\",\n            value: function closeFillStroke() {\n              this.closePath();\n              this.fillStroke();\n            }\n          }, {\n            key: \"closeEOFillStroke\",\n            value: function closeEOFillStroke() {\n              this.pendingEOFill = true;\n              this.closePath();\n              this.fillStroke();\n            }\n          }, {\n            key: \"endPath\",\n            value: function endPath() {\n              this.consumePath();\n            }\n          }, {\n            key: \"clip\",\n            value: function clip() {\n              this.pendingClip = NORMAL_CLIP;\n            }\n          }, {\n            key: \"eoClip\",\n            value: function eoClip() {\n              this.pendingClip = EO_CLIP;\n            }\n          }, {\n            key: \"beginText\",\n            value: function beginText() {\n              this.current.textMatrix = _util.IDENTITY_MATRIX;\n              this.current.textMatrixScale = 1;\n              this.current.x = this.current.lineX = 0;\n              this.current.y = this.current.lineY = 0;\n            }\n          }, {\n            key: \"endText\",\n            value: function endText() {\n              var paths = this.pendingTextPaths;\n              var ctx = this.ctx;\n              if (paths === undefined) {\n                ctx.beginPath();\n                return;\n              }\n              ctx.save();\n              ctx.beginPath();\n              var _iterator51 = _createForOfIteratorHelper(paths),\n                _step51;\n              try {\n                for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {\n                  var path = _step51.value;\n                  ctx.setTransform.apply(ctx, _toConsumableArray(path.transform));\n                  ctx.translate(path.x, path.y);\n                  path.addToPath(ctx, path.fontSize);\n                }\n              } catch (err) {\n                _iterator51.e(err);\n              } finally {\n                _iterator51.f();\n              }\n              ctx.restore();\n              ctx.clip();\n              ctx.beginPath();\n              delete this.pendingTextPaths;\n            }\n          }, {\n            key: \"setCharSpacing\",\n            value: function setCharSpacing(spacing) {\n              this.current.charSpacing = spacing;\n            }\n          }, {\n            key: \"setWordSpacing\",\n            value: function setWordSpacing(spacing) {\n              this.current.wordSpacing = spacing;\n            }\n          }, {\n            key: \"setHScale\",\n            value: function setHScale(scale) {\n              this.current.textHScale = scale / 100;\n            }\n          }, {\n            key: \"setLeading\",\n            value: function setLeading(leading) {\n              this.current.leading = -leading;\n            }\n          }, {\n            key: \"setFont\",\n            value: function setFont(fontRefName, size) {\n              var fontObj = this.commonObjs.get(fontRefName);\n              var current = this.current;\n              if (!fontObj) {\n                throw new Error(\"Can't find font for \".concat(fontRefName));\n              }\n              current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n              if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n                (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n              }\n              if (size < 0) {\n                size = -size;\n                current.fontDirection = -1;\n              } else {\n                current.fontDirection = 1;\n              }\n              this.current.font = fontObj;\n              this.current.fontSize = size;\n              if (fontObj.isType3Font) {\n                return;\n              }\n              var name = fontObj.loadedName || \"sans-serif\";\n              var bold = \"normal\";\n              if (fontObj.black) {\n                bold = \"900\";\n              } else if (fontObj.bold) {\n                bold = \"bold\";\n              }\n              var italic = fontObj.italic ? \"italic\" : \"normal\";\n              var typeface = \"\\\"\".concat(name, \"\\\", \").concat(fontObj.fallbackName);\n              var browserFontSize = size;\n              if (size < MIN_FONT_SIZE) {\n                browserFontSize = MIN_FONT_SIZE;\n              } else if (size > MAX_FONT_SIZE) {\n                browserFontSize = MAX_FONT_SIZE;\n              }\n              this.current.fontSizeScale = size / browserFontSize;\n              this.ctx.font = \"\".concat(italic, \" \").concat(bold, \" \").concat(browserFontSize, \"px \").concat(typeface);\n            }\n          }, {\n            key: \"setTextRenderingMode\",\n            value: function setTextRenderingMode(mode) {\n              this.current.textRenderingMode = mode;\n            }\n          }, {\n            key: \"setTextRise\",\n            value: function setTextRise(rise) {\n              this.current.textRise = rise;\n            }\n          }, {\n            key: \"moveText\",\n            value: function moveText(x, y) {\n              this.current.x = this.current.lineX += x;\n              this.current.y = this.current.lineY += y;\n            }\n          }, {\n            key: \"setLeadingMoveText\",\n            value: function setLeadingMoveText(x, y) {\n              this.setLeading(-y);\n              this.moveText(x, y);\n            }\n          }, {\n            key: \"setTextMatrix\",\n            value: function setTextMatrix(a, b, c, d, e, f) {\n              this.current.textMatrix = [a, b, c, d, e, f];\n              this.current.textMatrixScale = Math.hypot(a, b);\n              this.current.x = this.current.lineX = 0;\n              this.current.y = this.current.lineY = 0;\n            }\n          }, {\n            key: \"nextLine\",\n            value: function nextLine() {\n              this.moveText(0, this.current.leading);\n            }\n          }, {\n            key: \"paintChar\",\n            value: function paintChar(character, x, y, patternTransform) {\n              var ctx = this.ctx;\n              var current = this.current;\n              var font = current.font;\n              var textRenderingMode = current.textRenderingMode;\n              var fontSize = current.fontSize / current.fontSizeScale;\n              var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n              var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n              var patternFill = current.patternFill && !font.missingFile;\n              var addToPath;\n              if (font.disableFontFace || isAddToPathSet || patternFill) {\n                addToPath = font.getPathGenerator(this.commonObjs, character);\n              }\n              if (font.disableFontFace || patternFill) {\n                ctx.save();\n                ctx.translate(x, y);\n                ctx.beginPath();\n                addToPath(ctx, fontSize);\n                if (patternTransform) {\n                  ctx.setTransform.apply(ctx, _toConsumableArray(patternTransform));\n                }\n                if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                  ctx.fill();\n                }\n                if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                  ctx.stroke();\n                }\n                ctx.restore();\n              } else {\n                if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                  ctx.fillText(character, x, y);\n                }\n                if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                  ctx.strokeText(character, x, y);\n                }\n              }\n              if (isAddToPathSet) {\n                var paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n                paths.push({\n                  transform: (0, _display_utils.getCurrentTransform)(ctx),\n                  x: x,\n                  y: y,\n                  fontSize: fontSize,\n                  addToPath: addToPath\n                });\n              }\n            }\n          }, {\n            key: \"isFontSubpixelAAEnabled\",\n            get: function get() {\n              var _this$cachedCanvases$ = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10),\n                ctx = _this$cachedCanvases$.context;\n              ctx.scale(1.5, 1);\n              ctx.fillText(\"I\", 0, 10);\n              var data = ctx.getImageData(0, 0, 10, 10).data;\n              var enabled = false;\n              for (var i = 3; i < data.length; i += 4) {\n                if (data[i] > 0 && data[i] < 255) {\n                  enabled = true;\n                  break;\n                }\n              }\n              return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n            }\n          }, {\n            key: \"showText\",\n            value: function showText(glyphs) {\n              var current = this.current;\n              var font = current.font;\n              if (font.isType3Font) {\n                return this.showType3Text(glyphs);\n              }\n              var fontSize = current.fontSize;\n              if (fontSize === 0) {\n                return undefined;\n              }\n              var ctx = this.ctx;\n              var fontSizeScale = current.fontSizeScale;\n              var charSpacing = current.charSpacing;\n              var wordSpacing = current.wordSpacing;\n              var fontDirection = current.fontDirection;\n              var textHScale = current.textHScale * fontDirection;\n              var glyphsLength = glyphs.length;\n              var vertical = font.vertical;\n              var spacingDir = vertical ? 1 : -1;\n              var defaultVMetrics = font.defaultVMetrics;\n              var widthAdvanceScale = fontSize * current.fontMatrix[0];\n              var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n              ctx.save();\n              ctx.transform.apply(ctx, _toConsumableArray(current.textMatrix));\n              ctx.translate(current.x, current.y + current.textRise);\n              if (fontDirection > 0) {\n                ctx.scale(textHScale, -1);\n              } else {\n                ctx.scale(textHScale, 1);\n              }\n              var patternTransform;\n              if (current.patternFill) {\n                ctx.save();\n                var pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n                patternTransform = (0, _display_utils.getCurrentTransform)(ctx);\n                ctx.restore();\n                ctx.fillStyle = pattern;\n              }\n              var lineWidth = current.lineWidth;\n              var scale = current.textMatrixScale;\n              if (scale === 0 || lineWidth === 0) {\n                var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n                if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                  lineWidth = this.getSinglePixelWidth();\n                }\n              } else {\n                lineWidth /= scale;\n              }\n              if (fontSizeScale !== 1.0) {\n                ctx.scale(fontSizeScale, fontSizeScale);\n                lineWidth /= fontSizeScale;\n              }\n              ctx.lineWidth = lineWidth;\n              if (font.isInvalidPDFjsFont) {\n                var chars = [];\n                var width = 0;\n                var _iterator52 = _createForOfIteratorHelper(glyphs),\n                  _step52;\n                try {\n                  for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {\n                    var glyph = _step52.value;\n                    chars.push(glyph.unicode);\n                    width += glyph.width;\n                  }\n                } catch (err) {\n                  _iterator52.e(err);\n                } finally {\n                  _iterator52.f();\n                }\n                ctx.fillText(chars.join(\"\"), 0, 0);\n                current.x += width * widthAdvanceScale * textHScale;\n                ctx.restore();\n                this.compose();\n                return undefined;\n              }\n              var x = 0,\n                i;\n              for (i = 0; i < glyphsLength; ++i) {\n                var _glyph = glyphs[i];\n                if (typeof _glyph === \"number\") {\n                  x += spacingDir * _glyph * fontSize / 1000;\n                  continue;\n                }\n                var restoreNeeded = false;\n                var spacing = (_glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                var character = _glyph.fontChar;\n                var accent = _glyph.accent;\n                var scaledX = void 0,\n                  scaledY = void 0;\n                var _width = _glyph.width;\n                if (vertical) {\n                  var vmetric = _glyph.vmetric || defaultVMetrics;\n                  var vx = -(_glyph.vmetric ? vmetric[1] : _width * 0.5) * widthAdvanceScale;\n                  var vy = vmetric[2] * widthAdvanceScale;\n                  _width = vmetric ? -vmetric[0] : _width;\n                  scaledX = vx / fontSizeScale;\n                  scaledY = (x + vy) / fontSizeScale;\n                } else {\n                  scaledX = x / fontSizeScale;\n                  scaledY = 0;\n                }\n                if (font.remeasure && _width > 0) {\n                  var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n                  if (_width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                    var characterScaleX = _width / measuredWidth;\n                    restoreNeeded = true;\n                    ctx.save();\n                    ctx.scale(characterScaleX, 1);\n                    scaledX /= characterScaleX;\n                  } else if (_width !== measuredWidth) {\n                    scaledX += (_width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                  }\n                }\n                if (this.contentVisible && (_glyph.isInFont || font.missingFile)) {\n                  if (simpleFillText && !accent) {\n                    ctx.fillText(character, scaledX, scaledY);\n                  } else {\n                    this.paintChar(character, scaledX, scaledY, patternTransform);\n                    if (accent) {\n                      var scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                      var scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                      this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n                    }\n                  }\n                }\n                var charWidth = void 0;\n                if (vertical) {\n                  charWidth = _width * widthAdvanceScale - spacing * fontDirection;\n                } else {\n                  charWidth = _width * widthAdvanceScale + spacing * fontDirection;\n                }\n                x += charWidth;\n                if (restoreNeeded) {\n                  ctx.restore();\n                }\n              }\n              if (vertical) {\n                current.y -= x;\n              } else {\n                current.x += x * textHScale;\n              }\n              ctx.restore();\n              this.compose();\n              return undefined;\n            }\n          }, {\n            key: \"showType3Text\",\n            value: function showType3Text(glyphs) {\n              var ctx = this.ctx;\n              var current = this.current;\n              var font = current.font;\n              var fontSize = current.fontSize;\n              var fontDirection = current.fontDirection;\n              var spacingDir = font.vertical ? 1 : -1;\n              var charSpacing = current.charSpacing;\n              var wordSpacing = current.wordSpacing;\n              var textHScale = current.textHScale * fontDirection;\n              var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n              var glyphsLength = glyphs.length;\n              var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n              var i, glyph, width, spacingLength;\n              if (isTextInvisible || fontSize === 0) {\n                return;\n              }\n              this._cachedScaleForStroking = null;\n              this._cachedGetSinglePixelWidth = null;\n              ctx.save();\n              ctx.transform.apply(ctx, _toConsumableArray(current.textMatrix));\n              ctx.translate(current.x, current.y);\n              ctx.scale(textHScale, fontDirection);\n              for (i = 0; i < glyphsLength; ++i) {\n                glyph = glyphs[i];\n                if (typeof glyph === \"number\") {\n                  spacingLength = spacingDir * glyph * fontSize / 1000;\n                  this.ctx.translate(spacingLength, 0);\n                  current.x += spacingLength * textHScale;\n                  continue;\n                }\n                var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                var operatorList = font.charProcOperatorList[glyph.operatorListId];\n                if (!operatorList) {\n                  (0, _util.warn)(\"Type3 character \\\"\".concat(glyph.operatorListId, \"\\\" is not available.\"));\n                  continue;\n                }\n                if (this.contentVisible) {\n                  this.processingType3 = glyph;\n                  this.save();\n                  ctx.scale(fontSize, fontSize);\n                  ctx.transform.apply(ctx, _toConsumableArray(fontMatrix));\n                  this.executeOperatorList(operatorList);\n                  this.restore();\n                }\n                var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n                width = transformed[0] * fontSize + spacing;\n                ctx.translate(width, 0);\n                current.x += width * textHScale;\n              }\n              ctx.restore();\n              this.processingType3 = null;\n            }\n          }, {\n            key: \"setCharWidth\",\n            value: function setCharWidth(xWidth, yWidth) {}\n          }, {\n            key: \"setCharWidthAndBounds\",\n            value: function setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n              this.ctx.rect(llx, lly, urx - llx, ury - lly);\n              this.ctx.clip();\n              this.endPath();\n            }\n          }, {\n            key: \"getColorN_Pattern\",\n            value: function getColorN_Pattern(IR) {\n              var _this31 = this;\n              var pattern;\n              if (IR[0] === \"TilingPattern\") {\n                var color = IR[1];\n                var baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);\n                var canvasGraphicsFactory = {\n                  createCanvasGraphics: function createCanvasGraphics(ctx) {\n                    return new CanvasGraphics(ctx, _this31.commonObjs, _this31.objs, _this31.canvasFactory, _this31.filterFactory, {\n                      optionalContentConfig: _this31.optionalContentConfig,\n                      markedContentStack: _this31.markedContentStack\n                    });\n                  }\n                };\n                pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n              } else {\n                pattern = this._getPattern(IR[1], IR[2]);\n              }\n              return pattern;\n            }\n          }, {\n            key: \"setStrokeColorN\",\n            value: function setStrokeColorN() {\n              this.current.strokeColor = this.getColorN_Pattern(arguments);\n            }\n          }, {\n            key: \"setFillColorN\",\n            value: function setFillColorN() {\n              this.current.fillColor = this.getColorN_Pattern(arguments);\n              this.current.patternFill = true;\n            }\n          }, {\n            key: \"setStrokeRGBColor\",\n            value: function setStrokeRGBColor(r, g, b) {\n              var color = _util.Util.makeHexColor(r, g, b);\n              this.ctx.strokeStyle = color;\n              this.current.strokeColor = color;\n            }\n          }, {\n            key: \"setFillRGBColor\",\n            value: function setFillRGBColor(r, g, b) {\n              var color = _util.Util.makeHexColor(r, g, b);\n              this.ctx.fillStyle = color;\n              this.current.fillColor = color;\n              this.current.patternFill = false;\n            }\n          }, {\n            key: \"_getPattern\",\n            value: function _getPattern(objId) {\n              var matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n              var pattern;\n              if (this.cachedPatterns.has(objId)) {\n                pattern = this.cachedPatterns.get(objId);\n              } else {\n                pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));\n                this.cachedPatterns.set(objId, pattern);\n              }\n              if (matrix) {\n                pattern.matrix = matrix;\n              }\n              return pattern;\n            }\n          }, {\n            key: \"shadingFill\",\n            value: function shadingFill(objId) {\n              if (!this.contentVisible) {\n                return;\n              }\n              var ctx = this.ctx;\n              this.save();\n              var pattern = this._getPattern(objId);\n              ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);\n              var inv = (0, _display_utils.getCurrentTransformInverse)(ctx);\n              if (inv) {\n                var canvas = ctx.canvas;\n                var width = canvas.width;\n                var height = canvas.height;\n                var bl = _util.Util.applyTransform([0, 0], inv);\n                var br = _util.Util.applyTransform([0, height], inv);\n                var ul = _util.Util.applyTransform([width, 0], inv);\n                var ur = _util.Util.applyTransform([width, height], inv);\n                var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n                var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n                var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n                var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n                this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n              } else {\n                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n              }\n              this.compose(this.current.getClippedPathBoundingBox());\n              this.restore();\n            }\n          }, {\n            key: \"beginInlineImage\",\n            value: function beginInlineImage() {\n              (0, _util.unreachable)(\"Should not call beginInlineImage\");\n            }\n          }, {\n            key: \"beginImageData\",\n            value: function beginImageData() {\n              (0, _util.unreachable)(\"Should not call beginImageData\");\n            }\n          }, {\n            key: \"paintFormXObjectBegin\",\n            value: function paintFormXObjectBegin(matrix, bbox) {\n              if (!this.contentVisible) {\n                return;\n              }\n              this.save();\n              this.baseTransformStack.push(this.baseTransform);\n              if (Array.isArray(matrix) && matrix.length === 6) {\n                this.transform.apply(this, _toConsumableArray(matrix));\n              }\n              this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n              if (bbox) {\n                var width = bbox[2] - bbox[0];\n                var height = bbox[3] - bbox[1];\n                this.ctx.rect(bbox[0], bbox[1], width, height);\n                this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);\n                this.clip();\n                this.endPath();\n              }\n            }\n          }, {\n            key: \"paintFormXObjectEnd\",\n            value: function paintFormXObjectEnd() {\n              if (!this.contentVisible) {\n                return;\n              }\n              this.restore();\n              this.baseTransform = this.baseTransformStack.pop();\n            }\n          }, {\n            key: \"beginGroup\",\n            value: function beginGroup(group) {\n              if (!this.contentVisible) {\n                return;\n              }\n              this.save();\n              if (this.inSMaskMode) {\n                this.endSMaskMode();\n                this.current.activeSMask = null;\n              }\n              var currentCtx = this.ctx;\n              if (!group.isolated) {\n                (0, _util.info)(\"TODO: Support non-isolated groups.\");\n              }\n              if (group.knockout) {\n                (0, _util.warn)(\"Knockout groups not supported.\");\n              }\n              var currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);\n              if (group.matrix) {\n                currentCtx.transform.apply(currentCtx, _toConsumableArray(group.matrix));\n              }\n              if (!group.bbox) {\n                throw new Error(\"Bounding box is required.\");\n              }\n              var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));\n              var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n              bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n              var offsetX = Math.floor(bounds[0]);\n              var offsetY = Math.floor(bounds[1]);\n              var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n              var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n              var scaleX = 1,\n                scaleY = 1;\n              if (drawnWidth > MAX_GROUP_SIZE) {\n                scaleX = drawnWidth / MAX_GROUP_SIZE;\n                drawnWidth = MAX_GROUP_SIZE;\n              }\n              if (drawnHeight > MAX_GROUP_SIZE) {\n                scaleY = drawnHeight / MAX_GROUP_SIZE;\n                drawnHeight = MAX_GROUP_SIZE;\n              }\n              this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n              var cacheId = \"groupAt\" + this.groupLevel;\n              if (group.smask) {\n                cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n              }\n              var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n              var groupCtx = scratchCanvas.context;\n              groupCtx.scale(1 / scaleX, 1 / scaleY);\n              groupCtx.translate(-offsetX, -offsetY);\n              groupCtx.transform.apply(groupCtx, _toConsumableArray(currentTransform));\n              if (group.smask) {\n                this.smaskStack.push({\n                  canvas: scratchCanvas.canvas,\n                  context: groupCtx,\n                  offsetX: offsetX,\n                  offsetY: offsetY,\n                  scaleX: scaleX,\n                  scaleY: scaleY,\n                  subtype: group.smask.subtype,\n                  backdrop: group.smask.backdrop,\n                  transferMap: group.smask.transferMap || null,\n                  startTransformInverse: null\n                });\n              } else {\n                currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n                currentCtx.translate(offsetX, offsetY);\n                currentCtx.scale(scaleX, scaleY);\n                currentCtx.save();\n              }\n              copyCtxState(currentCtx, groupCtx);\n              this.ctx = groupCtx;\n              this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n              this.groupStack.push(currentCtx);\n              this.groupLevel++;\n            }\n          }, {\n            key: \"endGroup\",\n            value: function endGroup(group) {\n              if (!this.contentVisible) {\n                return;\n              }\n              this.groupLevel--;\n              var groupCtx = this.ctx;\n              var ctx = this.groupStack.pop();\n              this.ctx = ctx;\n              this.ctx.imageSmoothingEnabled = false;\n              if (group.smask) {\n                this.tempSMask = this.smaskStack.pop();\n                this.restore();\n              } else {\n                var _this$ctx4;\n                this.ctx.restore();\n                var currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);\n                this.restore();\n                this.ctx.save();\n                (_this$ctx4 = this.ctx).setTransform.apply(_this$ctx4, _toConsumableArray(currentMtx));\n                var dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);\n                this.ctx.drawImage(groupCtx.canvas, 0, 0);\n                this.ctx.restore();\n                this.compose(dirtyBox);\n              }\n            }\n          }, {\n            key: \"beginAnnotation\",\n            value: function beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n              _classPrivateMethodGet(this, _restoreInitialState, _restoreInitialState2).call(this);\n              resetCtxToDefault(this.ctx);\n              this.ctx.save();\n              this.save();\n              if (this.baseTransform) {\n                var _this$ctx5;\n                (_this$ctx5 = this.ctx).setTransform.apply(_this$ctx5, _toConsumableArray(this.baseTransform));\n              }\n              if (Array.isArray(rect) && rect.length === 4) {\n                var width = rect[2] - rect[0];\n                var height = rect[3] - rect[1];\n                if (hasOwnCanvas && this.annotationCanvasMap) {\n                  transform = transform.slice();\n                  transform[4] -= rect[0];\n                  transform[5] -= rect[1];\n                  rect = rect.slice();\n                  rect[0] = rect[1] = 0;\n                  rect[2] = width;\n                  rect[3] = height;\n                  var _util$Util$singularVa = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx)),\n                    _util$Util$singularVa2 = _slicedToArray(_util$Util$singularVa, 2),\n                    scaleX = _util$Util$singularVa2[0],\n                    scaleY = _util$Util$singularVa2[1];\n                  var viewportScale = this.viewportScale;\n                  var canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                  var canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                  this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                  var _this$annotationCanva = this.annotationCanvas,\n                    canvas = _this$annotationCanva.canvas,\n                    context = _this$annotationCanva.context;\n                  this.annotationCanvasMap.set(id, canvas);\n                  this.annotationCanvas.savedCtx = this.ctx;\n                  this.ctx = context;\n                  this.ctx.save();\n                  this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n                  resetCtxToDefault(this.ctx);\n                } else {\n                  resetCtxToDefault(this.ctx);\n                  this.ctx.rect(rect[0], rect[1], width, height);\n                  this.ctx.clip();\n                  this.endPath();\n                }\n              }\n              this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n              this.transform.apply(this, _toConsumableArray(transform));\n              this.transform.apply(this, _toConsumableArray(matrix));\n            }\n          }, {\n            key: \"endAnnotation\",\n            value: function endAnnotation() {\n              if (this.annotationCanvas) {\n                this.ctx.restore();\n                _classPrivateMethodGet(this, _drawFilter, _drawFilter2).call(this);\n                this.ctx = this.annotationCanvas.savedCtx;\n                delete this.annotationCanvas.savedCtx;\n                delete this.annotationCanvas;\n              }\n            }\n          }, {\n            key: \"paintImageMaskXObject\",\n            value: function paintImageMaskXObject(img) {\n              if (!this.contentVisible) {\n                return;\n              }\n              var count = img.count;\n              img = this.getObject(img.data, img);\n              img.count = count;\n              var ctx = this.ctx;\n              var glyph = this.processingType3;\n              if (glyph) {\n                if (glyph.compiled === undefined) {\n                  glyph.compiled = compileType3Glyph(img);\n                }\n                if (glyph.compiled) {\n                  glyph.compiled(ctx);\n                  return;\n                }\n              }\n              var mask = this._createMaskCanvas(img);\n              var maskCanvas = mask.canvas;\n              ctx.save();\n              ctx.setTransform(1, 0, 0, 1, 0, 0);\n              ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n              ctx.restore();\n              this.compose();\n            }\n          }, {\n            key: \"paintImageMaskXObjectRepeat\",\n            value: function paintImageMaskXObjectRepeat(img, scaleX) {\n              var skewX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n              var skewY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n              var scaleY = arguments.length > 4 ? arguments[4] : undefined;\n              var positions = arguments.length > 5 ? arguments[5] : undefined;\n              if (!this.contentVisible) {\n                return;\n              }\n              img = this.getObject(img.data, img);\n              var ctx = this.ctx;\n              ctx.save();\n              var currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n              ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n              var mask = this._createMaskCanvas(img);\n              ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n              for (var i = 0, ii = positions.length; i < ii; i += 2) {\n                var trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n                var _util$Util$applyTrans3 = _util.Util.applyTransform([0, 0], trans),\n                  _util$Util$applyTrans4 = _slicedToArray(_util$Util$applyTrans3, 2),\n                  x = _util$Util$applyTrans4[0],\n                  y = _util$Util$applyTrans4[1];\n                ctx.drawImage(mask.canvas, x, y);\n              }\n              ctx.restore();\n              this.compose();\n            }\n          }, {\n            key: \"paintImageMaskXObjectGroup\",\n            value: function paintImageMaskXObjectGroup(images) {\n              if (!this.contentVisible) {\n                return;\n              }\n              var ctx = this.ctx;\n              var fillColor = this.current.fillColor;\n              var isPatternFill = this.current.patternFill;\n              var _iterator53 = _createForOfIteratorHelper(images),\n                _step53;\n              try {\n                for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {\n                  var image = _step53.value;\n                  var data = image.data,\n                    width = image.width,\n                    height = image.height,\n                    transform = image.transform;\n                  var maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n                  var maskCtx = maskCanvas.context;\n                  maskCtx.save();\n                  var img = this.getObject(data, image);\n                  putBinaryImageMask(maskCtx, img);\n                  maskCtx.globalCompositeOperation = \"source-in\";\n                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;\n                  maskCtx.fillRect(0, 0, width, height);\n                  maskCtx.restore();\n                  ctx.save();\n                  ctx.transform.apply(ctx, _toConsumableArray(transform));\n                  ctx.scale(1, -1);\n                  drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n                  ctx.restore();\n                }\n              } catch (err) {\n                _iterator53.e(err);\n              } finally {\n                _iterator53.f();\n              }\n              this.compose();\n            }\n          }, {\n            key: \"paintImageXObject\",\n            value: function paintImageXObject(objId) {\n              if (!this.contentVisible) {\n                return;\n              }\n              var imgData = this.getObject(objId);\n              if (!imgData) {\n                (0, _util.warn)(\"Dependent image isn't ready yet\");\n                return;\n              }\n              this.paintInlineImageXObject(imgData);\n            }\n          }, {\n            key: \"paintImageXObjectRepeat\",\n            value: function paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n              if (!this.contentVisible) {\n                return;\n              }\n              var imgData = this.getObject(objId);\n              if (!imgData) {\n                (0, _util.warn)(\"Dependent image isn't ready yet\");\n                return;\n              }\n              var width = imgData.width;\n              var height = imgData.height;\n              var map = [];\n              for (var i = 0, ii = positions.length; i < ii; i += 2) {\n                map.push({\n                  transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n                  x: 0,\n                  y: 0,\n                  w: width,\n                  h: height\n                });\n              }\n              this.paintInlineImageXObjectGroup(imgData, map);\n            }\n          }, {\n            key: \"applyTransferMapsToCanvas\",\n            value: function applyTransferMapsToCanvas(ctx) {\n              if (this.current.transferMaps !== \"none\") {\n                ctx.filter = this.current.transferMaps;\n                ctx.drawImage(ctx.canvas, 0, 0);\n                ctx.filter = \"none\";\n              }\n              return ctx.canvas;\n            }\n          }, {\n            key: \"applyTransferMapsToBitmap\",\n            value: function applyTransferMapsToBitmap(imgData) {\n              if (this.current.transferMaps === \"none\") {\n                return imgData.bitmap;\n              }\n              var bitmap = imgData.bitmap,\n                width = imgData.width,\n                height = imgData.height;\n              var tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n              var tmpCtx = tmpCanvas.context;\n              tmpCtx.filter = this.current.transferMaps;\n              tmpCtx.drawImage(bitmap, 0, 0);\n              tmpCtx.filter = \"none\";\n              return tmpCanvas.canvas;\n            }\n          }, {\n            key: \"paintInlineImageXObject\",\n            value: function paintInlineImageXObject(imgData) {\n              if (!this.contentVisible) {\n                return;\n              }\n              var width = imgData.width;\n              var height = imgData.height;\n              var ctx = this.ctx;\n              this.save();\n              if (!_is_node.isNodeJS) {\n                ctx.filter = \"none\";\n              }\n              ctx.scale(1 / width, -1 / height);\n              var imgToPaint;\n              if (imgData.bitmap) {\n                imgToPaint = this.applyTransferMapsToBitmap(imgData);\n              } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n                imgToPaint = imgData;\n              } else {\n                var tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n                var tmpCtx = tmpCanvas.context;\n                putBinaryImageData(tmpCtx, imgData);\n                imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n              }\n              var scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));\n              ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);\n              drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n              this.compose();\n              this.restore();\n            }\n          }, {\n            key: \"paintInlineImageXObjectGroup\",\n            value: function paintInlineImageXObjectGroup(imgData, map) {\n              if (!this.contentVisible) {\n                return;\n              }\n              var ctx = this.ctx;\n              var imgToPaint;\n              if (imgData.bitmap) {\n                imgToPaint = imgData.bitmap;\n              } else {\n                var w = imgData.width;\n                var h = imgData.height;\n                var tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n                var tmpCtx = tmpCanvas.context;\n                putBinaryImageData(tmpCtx, imgData);\n                imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n              }\n              var _iterator54 = _createForOfIteratorHelper(map),\n                _step54;\n              try {\n                for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {\n                  var entry = _step54.value;\n                  ctx.save();\n                  ctx.transform.apply(ctx, _toConsumableArray(entry.transform));\n                  ctx.scale(1, -1);\n                  drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n                  ctx.restore();\n                }\n              } catch (err) {\n                _iterator54.e(err);\n              } finally {\n                _iterator54.f();\n              }\n              this.compose();\n            }\n          }, {\n            key: \"paintSolidColorImageMask\",\n            value: function paintSolidColorImageMask() {\n              if (!this.contentVisible) {\n                return;\n              }\n              this.ctx.fillRect(0, 0, 1, 1);\n              this.compose();\n            }\n          }, {\n            key: \"markPoint\",\n            value: function markPoint(tag) {}\n          }, {\n            key: \"markPointProps\",\n            value: function markPointProps(tag, properties) {}\n          }, {\n            key: \"beginMarkedContent\",\n            value: function beginMarkedContent(tag) {\n              this.markedContentStack.push({\n                visible: true\n              });\n            }\n          }, {\n            key: \"beginMarkedContentProps\",\n            value: function beginMarkedContentProps(tag, properties) {\n              if (tag === \"OC\") {\n                this.markedContentStack.push({\n                  visible: this.optionalContentConfig.isVisible(properties)\n                });\n              } else {\n                this.markedContentStack.push({\n                  visible: true\n                });\n              }\n              this.contentVisible = this.isContentVisible();\n            }\n          }, {\n            key: \"endMarkedContent\",\n            value: function endMarkedContent() {\n              this.markedContentStack.pop();\n              this.contentVisible = this.isContentVisible();\n            }\n          }, {\n            key: \"beginCompat\",\n            value: function beginCompat() {}\n          }, {\n            key: \"endCompat\",\n            value: function endCompat() {}\n          }, {\n            key: \"consumePath\",\n            value: function consumePath(clipBox) {\n              var isEmpty = this.current.isEmptyClip();\n              if (this.pendingClip) {\n                this.current.updateClipFromPath();\n              }\n              if (!this.pendingClip) {\n                this.compose(clipBox);\n              }\n              var ctx = this.ctx;\n              if (this.pendingClip) {\n                if (!isEmpty) {\n                  if (this.pendingClip === EO_CLIP) {\n                    ctx.clip(\"evenodd\");\n                  } else {\n                    ctx.clip();\n                  }\n                }\n                this.pendingClip = null;\n              }\n              this.current.startNewPathAndClipBox(this.current.clipBox);\n              ctx.beginPath();\n            }\n          }, {\n            key: \"getSinglePixelWidth\",\n            value: function getSinglePixelWidth() {\n              if (!this._cachedGetSinglePixelWidth) {\n                var m = (0, _display_utils.getCurrentTransform)(this.ctx);\n                if (m[1] === 0 && m[2] === 0) {\n                  this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n                } else {\n                  var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                  var normX = Math.hypot(m[0], m[2]);\n                  var normY = Math.hypot(m[1], m[3]);\n                  this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n                }\n              }\n              return this._cachedGetSinglePixelWidth;\n            }\n          }, {\n            key: \"getScaleForStroking\",\n            value: function getScaleForStroking() {\n              if (!this._cachedScaleForStroking) {\n                var lineWidth = this.current.lineWidth;\n                var m = (0, _display_utils.getCurrentTransform)(this.ctx);\n                var scaleX, scaleY;\n                if (m[1] === 0 && m[2] === 0) {\n                  var normX = Math.abs(m[0]);\n                  var normY = Math.abs(m[3]);\n                  if (lineWidth === 0) {\n                    scaleX = 1 / normX;\n                    scaleY = 1 / normY;\n                  } else {\n                    var scaledXLineWidth = normX * lineWidth;\n                    var scaledYLineWidth = normY * lineWidth;\n                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                  }\n                } else {\n                  var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                  var _normX = Math.hypot(m[0], m[1]);\n                  var _normY = Math.hypot(m[2], m[3]);\n                  if (lineWidth === 0) {\n                    scaleX = _normY / absDet;\n                    scaleY = _normX / absDet;\n                  } else {\n                    var baseArea = lineWidth * absDet;\n                    scaleX = _normY > baseArea ? _normY / baseArea : 1;\n                    scaleY = _normX > baseArea ? _normX / baseArea : 1;\n                  }\n                }\n                this._cachedScaleForStroking = [scaleX, scaleY];\n              }\n              return this._cachedScaleForStroking;\n            }\n          }, {\n            key: \"rescaleAndStroke\",\n            value: function rescaleAndStroke(saveRestore) {\n              var ctx = this.ctx;\n              var lineWidth = this.current.lineWidth;\n              var _this$getScaleForStro = this.getScaleForStroking(),\n                _this$getScaleForStro2 = _slicedToArray(_this$getScaleForStro, 2),\n                scaleX = _this$getScaleForStro2[0],\n                scaleY = _this$getScaleForStro2[1];\n              ctx.lineWidth = lineWidth || 1;\n              if (scaleX === 1 && scaleY === 1) {\n                ctx.stroke();\n                return;\n              }\n              var savedMatrix, savedDashes, savedDashOffset;\n              if (saveRestore) {\n                savedMatrix = (0, _display_utils.getCurrentTransform)(ctx);\n                savedDashes = ctx.getLineDash().slice();\n                savedDashOffset = ctx.lineDashOffset;\n              }\n              ctx.scale(scaleX, scaleY);\n              var scale = Math.max(scaleX, scaleY);\n              ctx.setLineDash(ctx.getLineDash().map(function (x) {\n                return x / scale;\n              }));\n              ctx.lineDashOffset /= scale;\n              ctx.stroke();\n              if (saveRestore) {\n                ctx.setTransform.apply(ctx, _toConsumableArray(savedMatrix));\n                ctx.setLineDash(savedDashes);\n                ctx.lineDashOffset = savedDashOffset;\n              }\n            }\n          }, {\n            key: \"isContentVisible\",\n            value: function isContentVisible() {\n              for (var i = this.markedContentStack.length - 1; i >= 0; i--) {\n                if (!this.markedContentStack[i].visible) {\n                  return false;\n                }\n              }\n              return true;\n            }\n          }]);\n          return CanvasGraphics;\n        }();\n        function _restoreInitialState2() {\n          while (this.stateStack.length || this.inSMaskMode) {\n            this.restore();\n          }\n          this.ctx.restore();\n          if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n          }\n        }\n        function _drawFilter2() {\n          if (this.pageColors) {\n            var hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n            if (hcmFilterId !== \"none\") {\n              var savedFilter = this.ctx.filter;\n              this.ctx.filter = hcmFilterId;\n              this.ctx.drawImage(this.ctx.canvas, 0, 0);\n              this.ctx.filter = savedFilter;\n            }\n          }\n        }\n        exports.CanvasGraphics = CanvasGraphics;\n        for (var op in _util.OPS) {\n          if (CanvasGraphics.prototype[op] !== undefined) {\n            CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n          }\n        }\n\n        /***/\n      }, /* 12 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.TilingPattern = exports.PathType = void 0;\n        exports.getShadingPattern = getShadingPattern;\n        var _util = __w_pdfjs_require__(1);\n        var _display_utils = __w_pdfjs_require__(6);\n        var PathType = {\n          FILL: \"Fill\",\n          STROKE: \"Stroke\",\n          SHADING: \"Shading\"\n        };\n        exports.PathType = PathType;\n        function applyBoundingBox(ctx, bbox) {\n          if (!bbox) {\n            return;\n          }\n          var width = bbox[2] - bbox[0];\n          var height = bbox[3] - bbox[1];\n          var region = new Path2D();\n          region.rect(bbox[0], bbox[1], width, height);\n          ctx.clip(region);\n        }\n        var BaseShadingPattern = /*#__PURE__*/function () {\n          function BaseShadingPattern() {\n            _classCallCheck(this, BaseShadingPattern);\n            if (this.constructor === BaseShadingPattern) {\n              (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n            }\n          }\n          _createClass(BaseShadingPattern, [{\n            key: \"getPattern\",\n            value: function getPattern() {\n              (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n            }\n          }]);\n          return BaseShadingPattern;\n        }();\n        var RadialAxialShadingPattern = /*#__PURE__*/function (_BaseShadingPattern) {\n          _inherits(RadialAxialShadingPattern, _BaseShadingPattern);\n          var _super15 = _createSuper(RadialAxialShadingPattern);\n          function RadialAxialShadingPattern(IR) {\n            var _this32;\n            _classCallCheck(this, RadialAxialShadingPattern);\n            _this32 = _super15.call(this);\n            _this32._type = IR[1];\n            _this32._bbox = IR[2];\n            _this32._colorStops = IR[3];\n            _this32._p0 = IR[4];\n            _this32._p1 = IR[5];\n            _this32._r0 = IR[6];\n            _this32._r1 = IR[7];\n            _this32.matrix = null;\n            return _this32;\n          }\n          _createClass(RadialAxialShadingPattern, [{\n            key: \"_createGradient\",\n            value: function _createGradient(ctx) {\n              var grad;\n              if (this._type === \"axial\") {\n                grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n              } else if (this._type === \"radial\") {\n                grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n              }\n              var _iterator55 = _createForOfIteratorHelper(this._colorStops),\n                _step55;\n              try {\n                for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {\n                  var colorStop = _step55.value;\n                  grad.addColorStop(colorStop[0], colorStop[1]);\n                }\n              } catch (err) {\n                _iterator55.e(err);\n              } finally {\n                _iterator55.f();\n              }\n              return grad;\n            }\n          }, {\n            key: \"getPattern\",\n            value: function getPattern(ctx, owner, inverse, pathType) {\n              var pattern;\n              if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n                var ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0];\n                var width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n                var height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n                var tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n                var tmpCtx = tmpCanvas.context;\n                tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n                tmpCtx.beginPath();\n                tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n                tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n                inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n                tmpCtx.transform.apply(tmpCtx, _toConsumableArray(owner.baseTransform));\n                if (this.matrix) {\n                  tmpCtx.transform.apply(tmpCtx, _toConsumableArray(this.matrix));\n                }\n                applyBoundingBox(tmpCtx, this._bbox);\n                tmpCtx.fillStyle = this._createGradient(tmpCtx);\n                tmpCtx.fill();\n                pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n                var domMatrix = new DOMMatrix(inverse);\n                pattern.setTransform(domMatrix);\n              } else {\n                applyBoundingBox(ctx, this._bbox);\n                pattern = this._createGradient(ctx);\n              }\n              return pattern;\n            }\n          }]);\n          return RadialAxialShadingPattern;\n        }(BaseShadingPattern);\n        function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n          var coords = context.coords,\n            colors = context.colors;\n          var bytes = data.data,\n            rowSize = data.width * 4;\n          var tmp;\n          if (coords[p1 + 1] > coords[p2 + 1]) {\n            tmp = p1;\n            p1 = p2;\n            p2 = tmp;\n            tmp = c1;\n            c1 = c2;\n            c2 = tmp;\n          }\n          if (coords[p2 + 1] > coords[p3 + 1]) {\n            tmp = p2;\n            p2 = p3;\n            p3 = tmp;\n            tmp = c2;\n            c2 = c3;\n            c3 = tmp;\n          }\n          if (coords[p1 + 1] > coords[p2 + 1]) {\n            tmp = p1;\n            p1 = p2;\n            p2 = tmp;\n            tmp = c1;\n            c1 = c2;\n            c2 = tmp;\n          }\n          var x1 = (coords[p1] + context.offsetX) * context.scaleX;\n          var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n          var x2 = (coords[p2] + context.offsetX) * context.scaleX;\n          var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n          var x3 = (coords[p3] + context.offsetX) * context.scaleX;\n          var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n          if (y1 >= y3) {\n            return;\n          }\n          var c1r = colors[c1],\n            c1g = colors[c1 + 1],\n            c1b = colors[c1 + 2];\n          var c2r = colors[c2],\n            c2g = colors[c2 + 1],\n            c2b = colors[c2 + 2];\n          var c3r = colors[c3],\n            c3g = colors[c3 + 1],\n            c3b = colors[c3 + 2];\n          var minY = Math.round(y1),\n            maxY = Math.round(y3);\n          var xa, car, cag, cab;\n          var xb, cbr, cbg, cbb;\n          for (var y = minY; y <= maxY; y++) {\n            if (y < y2) {\n              var _k = void 0;\n              if (y < y1) {\n                _k = 0;\n              } else {\n                _k = (y1 - y) / (y1 - y2);\n              }\n              xa = x1 - (x1 - x2) * _k;\n              car = c1r - (c1r - c2r) * _k;\n              cag = c1g - (c1g - c2g) * _k;\n              cab = c1b - (c1b - c2b) * _k;\n            } else {\n              var _k2 = void 0;\n              if (y > y3) {\n                _k2 = 1;\n              } else if (y2 === y3) {\n                _k2 = 0;\n              } else {\n                _k2 = (y2 - y) / (y2 - y3);\n              }\n              xa = x2 - (x2 - x3) * _k2;\n              car = c2r - (c2r - c3r) * _k2;\n              cag = c2g - (c2g - c3g) * _k2;\n              cab = c2b - (c2b - c3b) * _k2;\n            }\n            var k = void 0;\n            if (y < y1) {\n              k = 0;\n            } else if (y > y3) {\n              k = 1;\n            } else {\n              k = (y1 - y) / (y1 - y3);\n            }\n            xb = x1 - (x1 - x3) * k;\n            cbr = c1r - (c1r - c3r) * k;\n            cbg = c1g - (c1g - c3g) * k;\n            cbb = c1b - (c1b - c3b) * k;\n            var x1_ = Math.round(Math.min(xa, xb));\n            var x2_ = Math.round(Math.max(xa, xb));\n            var j = rowSize * y + x1_ * 4;\n            for (var x = x1_; x <= x2_; x++) {\n              k = (xa - x) / (xa - xb);\n              if (k < 0) {\n                k = 0;\n              } else if (k > 1) {\n                k = 1;\n              }\n              bytes[j++] = car - (car - cbr) * k | 0;\n              bytes[j++] = cag - (cag - cbg) * k | 0;\n              bytes[j++] = cab - (cab - cbb) * k | 0;\n              bytes[j++] = 255;\n            }\n          }\n        }\n        function drawFigure(data, figure, context) {\n          var ps = figure.coords;\n          var cs = figure.colors;\n          var i, ii;\n          switch (figure.type) {\n            case \"lattice\":\n              var verticesPerRow = figure.verticesPerRow;\n              var rows = Math.floor(ps.length / verticesPerRow) - 1;\n              var cols = verticesPerRow - 1;\n              for (i = 0; i < rows; i++) {\n                var q = i * verticesPerRow;\n                for (var j = 0; j < cols; j++, q++) {\n                  drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                  drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n              }\n              break;\n            case \"triangles\":\n              for (i = 0, ii = ps.length; i < ii; i += 3) {\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n              }\n              break;\n            default:\n              throw new Error(\"illegal figure\");\n          }\n        }\n        var MeshShadingPattern = /*#__PURE__*/function (_BaseShadingPattern2) {\n          _inherits(MeshShadingPattern, _BaseShadingPattern2);\n          var _super16 = _createSuper(MeshShadingPattern);\n          function MeshShadingPattern(IR) {\n            var _this33;\n            _classCallCheck(this, MeshShadingPattern);\n            _this33 = _super16.call(this);\n            _this33._coords = IR[2];\n            _this33._colors = IR[3];\n            _this33._figures = IR[4];\n            _this33._bounds = IR[5];\n            _this33._bbox = IR[7];\n            _this33._background = IR[8];\n            _this33.matrix = null;\n            return _this33;\n          }\n          _createClass(MeshShadingPattern, [{\n            key: \"_createMeshCanvas\",\n            value: function _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n              var EXPECTED_SCALE = 1.1;\n              var MAX_PATTERN_SIZE = 3000;\n              var BORDER_SIZE = 2;\n              var offsetX = Math.floor(this._bounds[0]);\n              var offsetY = Math.floor(this._bounds[1]);\n              var boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n              var boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n              var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n              var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n              var scaleX = boundsWidth / width;\n              var scaleY = boundsHeight / height;\n              var context = {\n                coords: this._coords,\n                colors: this._colors,\n                offsetX: -offsetX,\n                offsetY: -offsetY,\n                scaleX: 1 / scaleX,\n                scaleY: 1 / scaleY\n              };\n              var paddedWidth = width + BORDER_SIZE * 2;\n              var paddedHeight = height + BORDER_SIZE * 2;\n              var tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n              var tmpCtx = tmpCanvas.context;\n              var data = tmpCtx.createImageData(width, height);\n              if (backgroundColor) {\n                var bytes = data.data;\n                for (var i = 0, ii = bytes.length; i < ii; i += 4) {\n                  bytes[i] = backgroundColor[0];\n                  bytes[i + 1] = backgroundColor[1];\n                  bytes[i + 2] = backgroundColor[2];\n                  bytes[i + 3] = 255;\n                }\n              }\n              var _iterator56 = _createForOfIteratorHelper(this._figures),\n                _step56;\n              try {\n                for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {\n                  var figure = _step56.value;\n                  drawFigure(data, figure, context);\n                }\n              } catch (err) {\n                _iterator56.e(err);\n              } finally {\n                _iterator56.f();\n              }\n              tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n              var canvas = tmpCanvas.canvas;\n              return {\n                canvas: canvas,\n                offsetX: offsetX - BORDER_SIZE * scaleX,\n                offsetY: offsetY - BORDER_SIZE * scaleY,\n                scaleX: scaleX,\n                scaleY: scaleY\n              };\n            }\n          }, {\n            key: \"getPattern\",\n            value: function getPattern(ctx, owner, inverse, pathType) {\n              applyBoundingBox(ctx, this._bbox);\n              var scale;\n              if (pathType === PathType.SHADING) {\n                scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));\n              } else {\n                scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n                if (this.matrix) {\n                  var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n                  scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n                }\n              }\n              var temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n              if (pathType !== PathType.SHADING) {\n                ctx.setTransform.apply(ctx, _toConsumableArray(owner.baseTransform));\n                if (this.matrix) {\n                  ctx.transform.apply(ctx, _toConsumableArray(this.matrix));\n                }\n              }\n              ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n              ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n              return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n            }\n          }]);\n          return MeshShadingPattern;\n        }(BaseShadingPattern);\n        var DummyShadingPattern = /*#__PURE__*/function (_BaseShadingPattern3) {\n          _inherits(DummyShadingPattern, _BaseShadingPattern3);\n          var _super17 = _createSuper(DummyShadingPattern);\n          function DummyShadingPattern() {\n            _classCallCheck(this, DummyShadingPattern);\n            return _super17.apply(this, arguments);\n          }\n          _createClass(DummyShadingPattern, [{\n            key: \"getPattern\",\n            value: function getPattern() {\n              return \"hotpink\";\n            }\n          }]);\n          return DummyShadingPattern;\n        }(BaseShadingPattern);\n        function getShadingPattern(IR) {\n          switch (IR[0]) {\n            case \"RadialAxial\":\n              return new RadialAxialShadingPattern(IR);\n            case \"Mesh\":\n              return new MeshShadingPattern(IR);\n            case \"Dummy\":\n              return new DummyShadingPattern();\n          }\n          throw new Error(\"Unknown IR type: \".concat(IR[0]));\n        }\n        var PaintType = {\n          COLORED: 1,\n          UNCOLORED: 2\n        };\n        var TilingPattern = /*#__PURE__*/function () {\n          function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n            _classCallCheck(this, TilingPattern);\n            this.operatorList = IR[2];\n            this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n            this.bbox = IR[4];\n            this.xstep = IR[5];\n            this.ystep = IR[6];\n            this.paintType = IR[7];\n            this.tilingType = IR[8];\n            this.color = color;\n            this.ctx = ctx;\n            this.canvasGraphicsFactory = canvasGraphicsFactory;\n            this.baseTransform = baseTransform;\n          }\n          _createClass(TilingPattern, [{\n            key: \"createPatternCanvas\",\n            value: function createPatternCanvas(owner) {\n              var operatorList = this.operatorList;\n              var bbox = this.bbox;\n              var xstep = this.xstep;\n              var ystep = this.ystep;\n              var paintType = this.paintType;\n              var tilingType = this.tilingType;\n              var color = this.color;\n              var canvasGraphicsFactory = this.canvasGraphicsFactory;\n              (0, _util.info)(\"TilingType: \" + tilingType);\n              var x0 = bbox[0],\n                y0 = bbox[1],\n                x1 = bbox[2],\n                y1 = bbox[3];\n              var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n              var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n              var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n              var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n              var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n              var tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n              var tmpCtx = tmpCanvas.context;\n              var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n              graphics.groupLevel = owner.groupLevel;\n              this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n              var adjustedX0 = x0;\n              var adjustedY0 = y0;\n              var adjustedX1 = x1;\n              var adjustedY1 = y1;\n              if (x0 < 0) {\n                adjustedX0 = 0;\n                adjustedX1 += Math.abs(x0);\n              }\n              if (y0 < 0) {\n                adjustedY0 = 0;\n                adjustedY1 += Math.abs(y0);\n              }\n              tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n              graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n              tmpCtx.save();\n              this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n              graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);\n              graphics.executeOperatorList(operatorList);\n              graphics.endDrawing();\n              return {\n                canvas: tmpCanvas.canvas,\n                scaleX: dimx.scale,\n                scaleY: dimy.scale,\n                offsetX: adjustedX0,\n                offsetY: adjustedY0\n              };\n            }\n          }, {\n            key: \"getSizeAndScale\",\n            value: function getSizeAndScale(step, realOutputSize, scale) {\n              step = Math.abs(step);\n              var maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n              var size = Math.ceil(step * scale);\n              if (size >= maxSize) {\n                size = maxSize;\n              } else {\n                scale = size / step;\n              }\n              return {\n                scale: scale,\n                size: size\n              };\n            }\n          }, {\n            key: \"clipBbox\",\n            value: function clipBbox(graphics, x0, y0, x1, y1) {\n              var bboxWidth = x1 - x0;\n              var bboxHeight = y1 - y0;\n              graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n              graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);\n              graphics.clip();\n              graphics.endPath();\n            }\n          }, {\n            key: \"setFillAndStrokeStyleToContext\",\n            value: function setFillAndStrokeStyleToContext(graphics, paintType, color) {\n              var context = graphics.ctx,\n                current = graphics.current;\n              switch (paintType) {\n                case PaintType.COLORED:\n                  var ctx = this.ctx;\n                  context.fillStyle = ctx.fillStyle;\n                  context.strokeStyle = ctx.strokeStyle;\n                  current.fillColor = ctx.fillStyle;\n                  current.strokeColor = ctx.strokeStyle;\n                  break;\n                case PaintType.UNCOLORED:\n                  var cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n                  context.fillStyle = cssColor;\n                  context.strokeStyle = cssColor;\n                  current.fillColor = cssColor;\n                  current.strokeColor = cssColor;\n                  break;\n                default:\n                  throw new _util.FormatError(\"Unsupported paint type: \".concat(paintType));\n              }\n            }\n          }, {\n            key: \"getPattern\",\n            value: function getPattern(ctx, owner, inverse, pathType) {\n              var matrix = inverse;\n              if (pathType !== PathType.SHADING) {\n                matrix = _util.Util.transform(matrix, owner.baseTransform);\n                if (this.matrix) {\n                  matrix = _util.Util.transform(matrix, this.matrix);\n                }\n              }\n              var temporaryPatternCanvas = this.createPatternCanvas(owner);\n              var domMatrix = new DOMMatrix(matrix);\n              domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n              domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n              var pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n              pattern.setTransform(domMatrix);\n              return pattern;\n            }\n          }]);\n          return TilingPattern;\n        }();\n        _defineProperty(TilingPattern, \"MAX_PATTERN_SIZE\", 3000);\n        exports.TilingPattern = TilingPattern;\n\n        /***/\n      }, /* 13 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;\n        exports.convertToRGBA = convertToRGBA;\n        exports.grayToRGBA = grayToRGBA;\n        var _util = __w_pdfjs_require__(1);\n        function convertToRGBA(params) {\n          switch (params.kind) {\n            case _util.ImageKind.GRAYSCALE_1BPP:\n              return convertBlackAndWhiteToRGBA(params);\n            case _util.ImageKind.RGB_24BPP:\n              return convertRGBToRGBA(params);\n          }\n          return null;\n        }\n        function convertBlackAndWhiteToRGBA(_ref48) {\n          var src = _ref48.src,\n            _ref48$srcPos = _ref48.srcPos,\n            srcPos = _ref48$srcPos === void 0 ? 0 : _ref48$srcPos,\n            dest = _ref48.dest,\n            width = _ref48.width,\n            height = _ref48.height,\n            _ref48$nonBlackColor = _ref48.nonBlackColor,\n            nonBlackColor = _ref48$nonBlackColor === void 0 ? 0xffffffff : _ref48$nonBlackColor,\n            _ref48$inverseDecode = _ref48.inverseDecode,\n            inverseDecode = _ref48$inverseDecode === void 0 ? false : _ref48$inverseDecode;\n          var black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n          var _ref49 = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor],\n            _ref50 = _slicedToArray(_ref49, 2),\n            zeroMapping = _ref50[0],\n            oneMapping = _ref50[1];\n          var widthInSource = width >> 3;\n          var widthRemainder = width & 7;\n          var srcLength = src.length;\n          dest = new Uint32Array(dest.buffer);\n          var destPos = 0;\n          for (var i = 0; i < height; i++) {\n            for (var max = srcPos + widthInSource; srcPos < max; srcPos++) {\n              var _elem = srcPos < srcLength ? src[srcPos] : 255;\n              dest[destPos++] = _elem & 128 ? oneMapping : zeroMapping;\n              dest[destPos++] = _elem & 64 ? oneMapping : zeroMapping;\n              dest[destPos++] = _elem & 32 ? oneMapping : zeroMapping;\n              dest[destPos++] = _elem & 16 ? oneMapping : zeroMapping;\n              dest[destPos++] = _elem & 8 ? oneMapping : zeroMapping;\n              dest[destPos++] = _elem & 4 ? oneMapping : zeroMapping;\n              dest[destPos++] = _elem & 2 ? oneMapping : zeroMapping;\n              dest[destPos++] = _elem & 1 ? oneMapping : zeroMapping;\n            }\n            if (widthRemainder === 0) {\n              continue;\n            }\n            var elem = srcPos < srcLength ? src[srcPos++] : 255;\n            for (var j = 0; j < widthRemainder; j++) {\n              dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n            }\n          }\n          return {\n            srcPos: srcPos,\n            destPos: destPos\n          };\n        }\n        function convertRGBToRGBA(_ref51) {\n          var src = _ref51.src,\n            _ref51$srcPos = _ref51.srcPos,\n            srcPos = _ref51$srcPos === void 0 ? 0 : _ref51$srcPos,\n            dest = _ref51.dest,\n            _ref51$destPos = _ref51.destPos,\n            destPos = _ref51$destPos === void 0 ? 0 : _ref51$destPos,\n            width = _ref51.width,\n            height = _ref51.height;\n          var i = 0;\n          var len32 = src.length >> 2;\n          var src32 = new Uint32Array(src.buffer, srcPos, len32);\n          if (_util.FeatureTest.isLittleEndian) {\n            for (; i < len32 - 2; i += 3, destPos += 4) {\n              var s1 = src32[i];\n              var s2 = src32[i + 1];\n              var s3 = src32[i + 2];\n              dest[destPos] = s1 | 0xff000000;\n              dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n              dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n              dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n            }\n            for (var j = i * 4, jj = src.length; j < jj; j += 3) {\n              dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n            }\n          } else {\n            for (; i < len32 - 2; i += 3, destPos += 4) {\n              var _s = src32[i];\n              var _s2 = src32[i + 1];\n              var _s3 = src32[i + 2];\n              dest[destPos] = _s | 0xff;\n              dest[destPos + 1] = _s << 24 | _s2 >>> 8 | 0xff;\n              dest[destPos + 2] = _s2 << 16 | _s3 >>> 16 | 0xff;\n              dest[destPos + 3] = _s3 << 8 | 0xff;\n            }\n            for (var _j = i * 4, _jj = src.length; _j < _jj; _j += 3) {\n              dest[destPos++] = src[_j] << 24 | src[_j + 1] << 16 | src[_j + 2] << 8 | 0xff;\n            }\n          }\n          return {\n            srcPos: srcPos,\n            destPos: destPos\n          };\n        }\n        function grayToRGBA(src, dest) {\n          if (_util.FeatureTest.isLittleEndian) {\n            for (var i = 0, ii = src.length; i < ii; i++) {\n              dest[i] = src[i] * 0x10101 | 0xff000000;\n            }\n          } else {\n            for (var _i10 = 0, _ii = src.length; _i10 < _ii; _i10++) {\n              dest[_i10] = src[_i10] * 0x1010100 | 0x000000ff;\n            }\n          }\n        }\n\n        /***/\n      }, /* 14 */\n      /***/function (__unused_webpack_module, exports) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.GlobalWorkerOptions = void 0;\n        var GlobalWorkerOptions = Object.create(null);\n        exports.GlobalWorkerOptions = GlobalWorkerOptions;\n        GlobalWorkerOptions.workerPort = null;\n        GlobalWorkerOptions.workerSrc = \"\";\n\n        /***/\n      }, /* 15 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.MessageHandler = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var CallbackKind = {\n          UNKNOWN: 0,\n          DATA: 1,\n          ERROR: 2\n        };\n        var StreamKind = {\n          UNKNOWN: 0,\n          CANCEL: 1,\n          CANCEL_COMPLETE: 2,\n          CLOSE: 3,\n          ENQUEUE: 4,\n          ERROR: 5,\n          PULL: 6,\n          PULL_COMPLETE: 7,\n          START_COMPLETE: 8\n        };\n        function wrapReason(reason) {\n          if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n            (0, _util.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n          }\n          switch (reason.name) {\n            case \"AbortException\":\n              return new _util.AbortException(reason.message);\n            case \"MissingPDFException\":\n              return new _util.MissingPDFException(reason.message);\n            case \"PasswordException\":\n              return new _util.PasswordException(reason.message, reason.code);\n            case \"UnexpectedResponseException\":\n              return new _util.UnexpectedResponseException(reason.message, reason.status);\n            case \"UnknownErrorException\":\n              return new _util.UnknownErrorException(reason.message, reason.details);\n            default:\n              return new _util.UnknownErrorException(reason.message, reason.toString());\n          }\n        }\n        var _createStreamSink = /*#__PURE__*/new WeakSet();\n        var _processStreamMessage = /*#__PURE__*/new WeakSet();\n        var _deleteStreamController = /*#__PURE__*/new WeakSet();\n        var MessageHandler = /*#__PURE__*/function () {\n          function MessageHandler(_sourceName, _targetName, _comObj) {\n            var _this34 = this;\n            _classCallCheck(this, MessageHandler);\n            _classPrivateMethodInitSpec(this, _deleteStreamController);\n            _classPrivateMethodInitSpec(this, _processStreamMessage);\n            _classPrivateMethodInitSpec(this, _createStreamSink);\n            this.sourceName = _sourceName;\n            this.targetName = _targetName;\n            this.comObj = _comObj;\n            this.callbackId = 1;\n            this.streamId = 1;\n            this.streamSinks = Object.create(null);\n            this.streamControllers = Object.create(null);\n            this.callbackCapabilities = Object.create(null);\n            this.actionHandler = Object.create(null);\n            this._onComObjOnMessage = function (event) {\n              var data = event.data;\n              if (data.targetName !== _this34.sourceName) {\n                return;\n              }\n              if (data.stream) {\n                _classPrivateMethodGet(_this34, _processStreamMessage, _processStreamMessage2).call(_this34, data);\n                return;\n              }\n              if (data.callback) {\n                var callbackId = data.callbackId;\n                var capability = _this34.callbackCapabilities[callbackId];\n                if (!capability) {\n                  throw new Error(\"Cannot resolve callback \".concat(callbackId));\n                }\n                delete _this34.callbackCapabilities[callbackId];\n                if (data.callback === CallbackKind.DATA) {\n                  capability.resolve(data.data);\n                } else if (data.callback === CallbackKind.ERROR) {\n                  capability.reject(wrapReason(data.reason));\n                } else {\n                  throw new Error(\"Unexpected callback case\");\n                }\n                return;\n              }\n              var action = _this34.actionHandler[data.action];\n              if (!action) {\n                throw new Error(\"Unknown action from worker: \".concat(data.action));\n              }\n              if (data.callbackId) {\n                var cbSourceName = _this34.sourceName;\n                var cbTargetName = data.sourceName;\n                new Promise(function (resolve) {\n                  resolve(action(data.data));\n                }).then(function (result) {\n                  _comObj.postMessage({\n                    sourceName: cbSourceName,\n                    targetName: cbTargetName,\n                    callback: CallbackKind.DATA,\n                    callbackId: data.callbackId,\n                    data: result\n                  });\n                }, function (reason) {\n                  _comObj.postMessage({\n                    sourceName: cbSourceName,\n                    targetName: cbTargetName,\n                    callback: CallbackKind.ERROR,\n                    callbackId: data.callbackId,\n                    reason: wrapReason(reason)\n                  });\n                });\n                return;\n              }\n              if (data.streamId) {\n                _classPrivateMethodGet(_this34, _createStreamSink, _createStreamSink2).call(_this34, data);\n                return;\n              }\n              action(data.data);\n            };\n            _comObj.addEventListener(\"message\", this._onComObjOnMessage);\n          }\n          _createClass(MessageHandler, [{\n            key: \"on\",\n            value: function on(actionName, handler) {\n              var ah = this.actionHandler;\n              if (ah[actionName]) {\n                throw new Error(\"There is already an actionName called \\\"\".concat(actionName, \"\\\"\"));\n              }\n              ah[actionName] = handler;\n            }\n          }, {\n            key: \"send\",\n            value: function send(actionName, data, transfers) {\n              this.comObj.postMessage({\n                sourceName: this.sourceName,\n                targetName: this.targetName,\n                action: actionName,\n                data: data\n              }, transfers);\n            }\n          }, {\n            key: \"sendWithPromise\",\n            value: function sendWithPromise(actionName, data, transfers) {\n              var callbackId = this.callbackId++;\n              var capability = new _util.PromiseCapability();\n              this.callbackCapabilities[callbackId] = capability;\n              try {\n                this.comObj.postMessage({\n                  sourceName: this.sourceName,\n                  targetName: this.targetName,\n                  action: actionName,\n                  callbackId: callbackId,\n                  data: data\n                }, transfers);\n              } catch (ex) {\n                capability.reject(ex);\n              }\n              return capability.promise;\n            }\n          }, {\n            key: \"sendWithStream\",\n            value: function sendWithStream(actionName, data, queueingStrategy, transfers) {\n              var _this35 = this;\n              var streamId = this.streamId++,\n                sourceName = this.sourceName,\n                targetName = this.targetName,\n                comObj = this.comObj;\n              return new ReadableStream({\n                start: function start(controller) {\n                  var startCapability = new _util.PromiseCapability();\n                  _this35.streamControllers[streamId] = {\n                    controller: controller,\n                    startCall: startCapability,\n                    pullCall: null,\n                    cancelCall: null,\n                    isClosed: false\n                  };\n                  comObj.postMessage({\n                    sourceName: sourceName,\n                    targetName: targetName,\n                    action: actionName,\n                    streamId: streamId,\n                    data: data,\n                    desiredSize: controller.desiredSize\n                  }, transfers);\n                  return startCapability.promise;\n                },\n                pull: function pull(controller) {\n                  var pullCapability = new _util.PromiseCapability();\n                  _this35.streamControllers[streamId].pullCall = pullCapability;\n                  comObj.postMessage({\n                    sourceName: sourceName,\n                    targetName: targetName,\n                    stream: StreamKind.PULL,\n                    streamId: streamId,\n                    desiredSize: controller.desiredSize\n                  });\n                  return pullCapability.promise;\n                },\n                cancel: function cancel(reason) {\n                  (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n                  var cancelCapability = new _util.PromiseCapability();\n                  _this35.streamControllers[streamId].cancelCall = cancelCapability;\n                  _this35.streamControllers[streamId].isClosed = true;\n                  comObj.postMessage({\n                    sourceName: sourceName,\n                    targetName: targetName,\n                    stream: StreamKind.CANCEL,\n                    streamId: streamId,\n                    reason: wrapReason(reason)\n                  });\n                  return cancelCapability.promise;\n                }\n              }, queueingStrategy);\n            }\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n            }\n          }]);\n          return MessageHandler;\n        }();\n        function _createStreamSink2(data) {\n          var streamId = data.streamId,\n            sourceName = this.sourceName,\n            targetName = data.sourceName,\n            comObj = this.comObj;\n          var self = this,\n            action = this.actionHandler[data.action];\n          var streamSink = {\n            enqueue: function enqueue(chunk) {\n              var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n              var transfers = arguments.length > 2 ? arguments[2] : undefined;\n              if (this.isCancelled) {\n                return;\n              }\n              var lastDesiredSize = this.desiredSize;\n              this.desiredSize -= size;\n              if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                this.sinkCapability = new _util.PromiseCapability();\n                this.ready = this.sinkCapability.promise;\n              }\n              comObj.postMessage({\n                sourceName: sourceName,\n                targetName: targetName,\n                stream: StreamKind.ENQUEUE,\n                streamId: streamId,\n                chunk: chunk\n              }, transfers);\n            },\n            close: function close() {\n              if (this.isCancelled) {\n                return;\n              }\n              this.isCancelled = true;\n              comObj.postMessage({\n                sourceName: sourceName,\n                targetName: targetName,\n                stream: StreamKind.CLOSE,\n                streamId: streamId\n              });\n              delete self.streamSinks[streamId];\n            },\n            error: function error(reason) {\n              (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n              if (this.isCancelled) {\n                return;\n              }\n              this.isCancelled = true;\n              comObj.postMessage({\n                sourceName: sourceName,\n                targetName: targetName,\n                stream: StreamKind.ERROR,\n                streamId: streamId,\n                reason: wrapReason(reason)\n              });\n            },\n            sinkCapability: new _util.PromiseCapability(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n          };\n          streamSink.sinkCapability.resolve();\n          streamSink.ready = streamSink.sinkCapability.promise;\n          this.streamSinks[streamId] = streamSink;\n          new Promise(function (resolve) {\n            resolve(action(data.data, streamSink));\n          }).then(function () {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.START_COMPLETE,\n              streamId: streamId,\n              success: true\n            });\n          }, function (reason) {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.START_COMPLETE,\n              streamId: streamId,\n              reason: wrapReason(reason)\n            });\n          });\n        }\n        function _processStreamMessage2(data) {\n          var streamId = data.streamId,\n            sourceName = this.sourceName,\n            targetName = data.sourceName,\n            comObj = this.comObj;\n          var streamController = this.streamControllers[streamId],\n            streamSink = this.streamSinks[streamId];\n          switch (data.stream) {\n            case StreamKind.START_COMPLETE:\n              if (data.success) {\n                streamController.startCall.resolve();\n              } else {\n                streamController.startCall.reject(wrapReason(data.reason));\n              }\n              break;\n            case StreamKind.PULL_COMPLETE:\n              if (data.success) {\n                streamController.pullCall.resolve();\n              } else {\n                streamController.pullCall.reject(wrapReason(data.reason));\n              }\n              break;\n            case StreamKind.PULL:\n              if (!streamSink) {\n                comObj.postMessage({\n                  sourceName: sourceName,\n                  targetName: targetName,\n                  stream: StreamKind.PULL_COMPLETE,\n                  streamId: streamId,\n                  success: true\n                });\n                break;\n              }\n              if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                streamSink.sinkCapability.resolve();\n              }\n              streamSink.desiredSize = data.desiredSize;\n              new Promise(function (resolve) {\n                var _streamSink$onPull;\n                resolve((_streamSink$onPull = streamSink.onPull) === null || _streamSink$onPull === void 0 ? void 0 : _streamSink$onPull.call(streamSink));\n              }).then(function () {\n                comObj.postMessage({\n                  sourceName: sourceName,\n                  targetName: targetName,\n                  stream: StreamKind.PULL_COMPLETE,\n                  streamId: streamId,\n                  success: true\n                });\n              }, function (reason) {\n                comObj.postMessage({\n                  sourceName: sourceName,\n                  targetName: targetName,\n                  stream: StreamKind.PULL_COMPLETE,\n                  streamId: streamId,\n                  reason: wrapReason(reason)\n                });\n              });\n              break;\n            case StreamKind.ENQUEUE:\n              (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n              if (streamController.isClosed) {\n                break;\n              }\n              streamController.controller.enqueue(data.chunk);\n              break;\n            case StreamKind.CLOSE:\n              (0, _util.assert)(streamController, \"close should have stream controller\");\n              if (streamController.isClosed) {\n                break;\n              }\n              streamController.isClosed = true;\n              streamController.controller.close();\n              _classPrivateMethodGet(this, _deleteStreamController, _deleteStreamController2).call(this, streamController, streamId);\n              break;\n            case StreamKind.ERROR:\n              (0, _util.assert)(streamController, \"error should have stream controller\");\n              streamController.controller.error(wrapReason(data.reason));\n              _classPrivateMethodGet(this, _deleteStreamController, _deleteStreamController2).call(this, streamController, streamId);\n              break;\n            case StreamKind.CANCEL_COMPLETE:\n              if (data.success) {\n                streamController.cancelCall.resolve();\n              } else {\n                streamController.cancelCall.reject(wrapReason(data.reason));\n              }\n              _classPrivateMethodGet(this, _deleteStreamController, _deleteStreamController2).call(this, streamController, streamId);\n              break;\n            case StreamKind.CANCEL:\n              if (!streamSink) {\n                break;\n              }\n              new Promise(function (resolve) {\n                var _streamSink$onCancel;\n                resolve((_streamSink$onCancel = streamSink.onCancel) === null || _streamSink$onCancel === void 0 ? void 0 : _streamSink$onCancel.call(streamSink, wrapReason(data.reason)));\n              }).then(function () {\n                comObj.postMessage({\n                  sourceName: sourceName,\n                  targetName: targetName,\n                  stream: StreamKind.CANCEL_COMPLETE,\n                  streamId: streamId,\n                  success: true\n                });\n              }, function (reason) {\n                comObj.postMessage({\n                  sourceName: sourceName,\n                  targetName: targetName,\n                  stream: StreamKind.CANCEL_COMPLETE,\n                  streamId: streamId,\n                  reason: wrapReason(reason)\n                });\n              });\n              streamSink.sinkCapability.reject(wrapReason(data.reason));\n              streamSink.isCancelled = true;\n              delete this.streamSinks[streamId];\n              break;\n            default:\n              throw new Error(\"Unexpected stream case\");\n          }\n        }\n        function _deleteStreamController2(_x7, _x8) {\n          return _deleteStreamController3.apply(this, arguments);\n        }\n        function _deleteStreamController3() {\n          _deleteStreamController3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(streamController, streamId) {\n            var _streamController$sta, _streamController$pul, _streamController$can;\n            return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n              while (1) switch (_context11.prev = _context11.next) {\n                case 0:\n                  _context11.next = 2;\n                  return Promise.allSettled([(_streamController$sta = streamController.startCall) === null || _streamController$sta === void 0 ? void 0 : _streamController$sta.promise, (_streamController$pul = streamController.pullCall) === null || _streamController$pul === void 0 ? void 0 : _streamController$pul.promise, (_streamController$can = streamController.cancelCall) === null || _streamController$can === void 0 ? void 0 : _streamController$can.promise]);\n                case 2:\n                  delete this.streamControllers[streamId];\n                case 3:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }, _callee11, this);\n          }));\n          return _deleteStreamController3.apply(this, arguments);\n        }\n        exports.MessageHandler = MessageHandler;\n\n        /***/\n      }, /* 16 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.Metadata = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _metadataMap = /*#__PURE__*/new WeakMap();\n        var _data = /*#__PURE__*/new WeakMap();\n        var Metadata = /*#__PURE__*/function () {\n          function Metadata(_ref52) {\n            var parsedData = _ref52.parsedData,\n              rawData = _ref52.rawData;\n            _classCallCheck(this, Metadata);\n            _classPrivateFieldInitSpec(this, _metadataMap, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(this, _data, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldSet(this, _metadataMap, parsedData);\n            _classPrivateFieldSet(this, _data, rawData);\n          }\n          _createClass(Metadata, [{\n            key: \"getRaw\",\n            value: function getRaw() {\n              return _classPrivateFieldGet(this, _data);\n            }\n          }, {\n            key: \"get\",\n            value: function get(name) {\n              var _classPrivateFieldGet6;\n              return (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _metadataMap).get(name)) !== null && _classPrivateFieldGet6 !== void 0 ? _classPrivateFieldGet6 : null;\n            }\n          }, {\n            key: \"getAll\",\n            value: function getAll() {\n              return (0, _util.objectFromMap)(_classPrivateFieldGet(this, _metadataMap));\n            }\n          }, {\n            key: \"has\",\n            value: function has(name) {\n              return _classPrivateFieldGet(this, _metadataMap).has(name);\n            }\n          }]);\n          return Metadata;\n        }();\n        exports.Metadata = Metadata;\n\n        /***/\n      }, /* 17 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.OptionalContentConfig = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _murmurhash = __w_pdfjs_require__(8);\n        var INTERNAL = Symbol(\"INTERNAL\");\n        var _visible = /*#__PURE__*/new WeakMap();\n        var OptionalContentGroup = /*#__PURE__*/function () {\n          function OptionalContentGroup(name, intent) {\n            _classCallCheck(this, OptionalContentGroup);\n            _classPrivateFieldInitSpec(this, _visible, {\n              writable: true,\n              value: true\n            });\n            this.name = name;\n            this.intent = intent;\n          }\n          _createClass(OptionalContentGroup, [{\n            key: \"visible\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _visible);\n            }\n          }, {\n            key: \"_setVisible\",\n            value: function _setVisible(internal, visible) {\n              if (internal !== INTERNAL) {\n                (0, _util.unreachable)(\"Internal method `_setVisible` called.\");\n              }\n              _classPrivateFieldSet(this, _visible, visible);\n            }\n          }]);\n          return OptionalContentGroup;\n        }();\n        var _cachedGetHash = /*#__PURE__*/new WeakMap();\n        var _groups = /*#__PURE__*/new WeakMap();\n        var _initialHash = /*#__PURE__*/new WeakMap();\n        var _order = /*#__PURE__*/new WeakMap();\n        var _evaluateVisibilityExpression = /*#__PURE__*/new WeakSet();\n        var OptionalContentConfig = /*#__PURE__*/function () {\n          function OptionalContentConfig(data) {\n            _classCallCheck(this, OptionalContentConfig);\n            _classPrivateMethodInitSpec(this, _evaluateVisibilityExpression);\n            _classPrivateFieldInitSpec(this, _cachedGetHash, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldInitSpec(this, _groups, {\n              writable: true,\n              value: new Map()\n            });\n            _classPrivateFieldInitSpec(this, _initialHash, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldInitSpec(this, _order, {\n              writable: true,\n              value: null\n            });\n            this.name = null;\n            this.creator = null;\n            if (data === null) {\n              return;\n            }\n            this.name = data.name;\n            this.creator = data.creator;\n            _classPrivateFieldSet(this, _order, data.order);\n            var _iterator57 = _createForOfIteratorHelper(data.groups),\n              _step57;\n            try {\n              for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {\n                var _group = _step57.value;\n                _classPrivateFieldGet(this, _groups).set(_group.id, new OptionalContentGroup(_group.name, _group.intent));\n              }\n            } catch (err) {\n              _iterator57.e(err);\n            } finally {\n              _iterator57.f();\n            }\n            if (data.baseState === \"OFF\") {\n              var _iterator58 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _groups).values()),\n                _step58;\n              try {\n                for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {\n                  var group = _step58.value;\n                  group._setVisible(INTERNAL, false);\n                }\n              } catch (err) {\n                _iterator58.e(err);\n              } finally {\n                _iterator58.f();\n              }\n            }\n            var _iterator59 = _createForOfIteratorHelper(data.on),\n              _step59;\n            try {\n              for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {\n                var on = _step59.value;\n                _classPrivateFieldGet(this, _groups).get(on)._setVisible(INTERNAL, true);\n              }\n            } catch (err) {\n              _iterator59.e(err);\n            } finally {\n              _iterator59.f();\n            }\n            var _iterator60 = _createForOfIteratorHelper(data.off),\n              _step60;\n            try {\n              for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {\n                var off = _step60.value;\n                _classPrivateFieldGet(this, _groups).get(off)._setVisible(INTERNAL, false);\n              }\n            } catch (err) {\n              _iterator60.e(err);\n            } finally {\n              _iterator60.f();\n            }\n            _classPrivateFieldSet(this, _initialHash, this.getHash());\n          }\n          _createClass(OptionalContentConfig, [{\n            key: \"isVisible\",\n            value: function isVisible(group) {\n              if (_classPrivateFieldGet(this, _groups).size === 0) {\n                return true;\n              }\n              if (!group) {\n                (0, _util.warn)(\"Optional content group not defined.\");\n                return true;\n              }\n              if (group.type === \"OCG\") {\n                if (!_classPrivateFieldGet(this, _groups).has(group.id)) {\n                  (0, _util.warn)(\"Optional content group not found: \".concat(group.id));\n                  return true;\n                }\n                return _classPrivateFieldGet(this, _groups).get(group.id).visible;\n              } else if (group.type === \"OCMD\") {\n                if (group.expression) {\n                  return _classPrivateMethodGet(this, _evaluateVisibilityExpression, _evaluateVisibilityExpression2).call(this, group.expression);\n                }\n                if (!group.policy || group.policy === \"AnyOn\") {\n                  var _iterator61 = _createForOfIteratorHelper(group.ids),\n                    _step61;\n                  try {\n                    for (_iterator61.s(); !(_step61 = _iterator61.n()).done;) {\n                      var id = _step61.value;\n                      if (!_classPrivateFieldGet(this, _groups).has(id)) {\n                        (0, _util.warn)(\"Optional content group not found: \".concat(id));\n                        return true;\n                      }\n                      if (_classPrivateFieldGet(this, _groups).get(id).visible) {\n                        return true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator61.e(err);\n                  } finally {\n                    _iterator61.f();\n                  }\n                  return false;\n                } else if (group.policy === \"AllOn\") {\n                  var _iterator62 = _createForOfIteratorHelper(group.ids),\n                    _step62;\n                  try {\n                    for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {\n                      var _id3 = _step62.value;\n                      if (!_classPrivateFieldGet(this, _groups).has(_id3)) {\n                        (0, _util.warn)(\"Optional content group not found: \".concat(_id3));\n                        return true;\n                      }\n                      if (!_classPrivateFieldGet(this, _groups).get(_id3).visible) {\n                        return false;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator62.e(err);\n                  } finally {\n                    _iterator62.f();\n                  }\n                  return true;\n                } else if (group.policy === \"AnyOff\") {\n                  var _iterator63 = _createForOfIteratorHelper(group.ids),\n                    _step63;\n                  try {\n                    for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {\n                      var _id4 = _step63.value;\n                      if (!_classPrivateFieldGet(this, _groups).has(_id4)) {\n                        (0, _util.warn)(\"Optional content group not found: \".concat(_id4));\n                        return true;\n                      }\n                      if (!_classPrivateFieldGet(this, _groups).get(_id4).visible) {\n                        return true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator63.e(err);\n                  } finally {\n                    _iterator63.f();\n                  }\n                  return false;\n                } else if (group.policy === \"AllOff\") {\n                  var _iterator64 = _createForOfIteratorHelper(group.ids),\n                    _step64;\n                  try {\n                    for (_iterator64.s(); !(_step64 = _iterator64.n()).done;) {\n                      var _id5 = _step64.value;\n                      if (!_classPrivateFieldGet(this, _groups).has(_id5)) {\n                        (0, _util.warn)(\"Optional content group not found: \".concat(_id5));\n                        return true;\n                      }\n                      if (_classPrivateFieldGet(this, _groups).get(_id5).visible) {\n                        return false;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator64.e(err);\n                  } finally {\n                    _iterator64.f();\n                  }\n                  return true;\n                }\n                (0, _util.warn)(\"Unknown optional content policy \".concat(group.policy, \".\"));\n                return true;\n              }\n              (0, _util.warn)(\"Unknown group type \".concat(group.type, \".\"));\n              return true;\n            }\n          }, {\n            key: \"setVisibility\",\n            value: function setVisibility(id) {\n              var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n              if (!_classPrivateFieldGet(this, _groups).has(id)) {\n                (0, _util.warn)(\"Optional content group not found: \".concat(id));\n                return;\n              }\n              _classPrivateFieldGet(this, _groups).get(id)._setVisible(INTERNAL, !!visible);\n              _classPrivateFieldSet(this, _cachedGetHash, null);\n            }\n          }, {\n            key: \"hasInitialVisibility\",\n            get: function get() {\n              return this.getHash() === _classPrivateFieldGet(this, _initialHash);\n            }\n          }, {\n            key: \"getOrder\",\n            value: function getOrder() {\n              if (!_classPrivateFieldGet(this, _groups).size) {\n                return null;\n              }\n              if (_classPrivateFieldGet(this, _order)) {\n                return _classPrivateFieldGet(this, _order).slice();\n              }\n              return _toConsumableArray(_classPrivateFieldGet(this, _groups).keys());\n            }\n          }, {\n            key: \"getGroups\",\n            value: function getGroups() {\n              return _classPrivateFieldGet(this, _groups).size > 0 ? (0, _util.objectFromMap)(_classPrivateFieldGet(this, _groups)) : null;\n            }\n          }, {\n            key: \"getGroup\",\n            value: function getGroup(id) {\n              return _classPrivateFieldGet(this, _groups).get(id) || null;\n            }\n          }, {\n            key: \"getHash\",\n            value: function getHash() {\n              if (_classPrivateFieldGet(this, _cachedGetHash) !== null) {\n                return _classPrivateFieldGet(this, _cachedGetHash);\n              }\n              var hash = new _murmurhash.MurmurHash3_64();\n              var _iterator65 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _groups)),\n                _step65;\n              try {\n                for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {\n                  var _step65$value = _slicedToArray(_step65.value, 2),\n                    id = _step65$value[0],\n                    group = _step65$value[1];\n                  hash.update(\"\".concat(id, \":\").concat(group.visible));\n                }\n              } catch (err) {\n                _iterator65.e(err);\n              } finally {\n                _iterator65.f();\n              }\n              return _classPrivateFieldSet(this, _cachedGetHash, hash.hexdigest());\n            }\n          }]);\n          return OptionalContentConfig;\n        }();\n        function _evaluateVisibilityExpression2(array) {\n          var length = array.length;\n          if (length < 2) {\n            return true;\n          }\n          var operator = array[0];\n          for (var i = 1; i < length; i++) {\n            var element = array[i];\n            var state = void 0;\n            if (Array.isArray(element)) {\n              state = _classPrivateMethodGet(this, _evaluateVisibilityExpression, _evaluateVisibilityExpression2).call(this, element);\n            } else if (_classPrivateFieldGet(this, _groups).has(element)) {\n              state = _classPrivateFieldGet(this, _groups).get(element).visible;\n            } else {\n              (0, _util.warn)(\"Optional content group not found: \".concat(element));\n              return true;\n            }\n            switch (operator) {\n              case \"And\":\n                if (!state) {\n                  return false;\n                }\n                break;\n              case \"Or\":\n                if (state) {\n                  return true;\n                }\n                break;\n              case \"Not\":\n                return !state;\n              default:\n                return true;\n            }\n          }\n          return operator === \"And\";\n        }\n        exports.OptionalContentConfig = OptionalContentConfig;\n\n        /***/\n      }, /* 18 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.PDFDataTransportStream = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _display_utils = __w_pdfjs_require__(6);\n        var PDFDataTransportStream = /*#__PURE__*/function () {\n          function PDFDataTransportStream(_ref53, pdfDataRangeTransport) {\n            var _this36 = this;\n            var length = _ref53.length,\n              initialData = _ref53.initialData,\n              _ref53$progressiveDon = _ref53.progressiveDone,\n              progressiveDone = _ref53$progressiveDon === void 0 ? false : _ref53$progressiveDon,\n              _ref53$contentDisposi = _ref53.contentDispositionFilename,\n              contentDispositionFilename = _ref53$contentDisposi === void 0 ? null : _ref53$contentDisposi,\n              _ref53$disableRange = _ref53.disableRange,\n              disableRange = _ref53$disableRange === void 0 ? false : _ref53$disableRange,\n              _ref53$disableStream = _ref53.disableStream,\n              disableStream = _ref53$disableStream === void 0 ? false : _ref53$disableStream;\n            _classCallCheck(this, PDFDataTransportStream);\n            (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n            this._queuedChunks = [];\n            this._progressiveDone = progressiveDone;\n            this._contentDispositionFilename = contentDispositionFilename;\n            if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {\n              var buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n              this._queuedChunks.push(buffer);\n            }\n            this._pdfDataRangeTransport = pdfDataRangeTransport;\n            this._isStreamingSupported = !disableStream;\n            this._isRangeSupported = !disableRange;\n            this._contentLength = length;\n            this._fullRequestReader = null;\n            this._rangeReaders = [];\n            this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {\n              _this36._onReceiveData({\n                begin: begin,\n                chunk: chunk\n              });\n            });\n            this._pdfDataRangeTransport.addProgressListener(function (loaded, total) {\n              _this36._onProgress({\n                loaded: loaded,\n                total: total\n              });\n            });\n            this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {\n              _this36._onReceiveData({\n                chunk: chunk\n              });\n            });\n            this._pdfDataRangeTransport.addProgressiveDoneListener(function () {\n              _this36._onProgressiveDone();\n            });\n            this._pdfDataRangeTransport.transportReady();\n          }\n          _createClass(PDFDataTransportStream, [{\n            key: \"_onReceiveData\",\n            value: function _onReceiveData(_ref54) {\n              var begin = _ref54.begin,\n                chunk = _ref54.chunk;\n              var buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n              if (begin === undefined) {\n                if (this._fullRequestReader) {\n                  this._fullRequestReader._enqueue(buffer);\n                } else {\n                  this._queuedChunks.push(buffer);\n                }\n              } else {\n                var found = this._rangeReaders.some(function (rangeReader) {\n                  if (rangeReader._begin !== begin) {\n                    return false;\n                  }\n                  rangeReader._enqueue(buffer);\n                  return true;\n                });\n                (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n              }\n            }\n          }, {\n            key: \"_progressiveDataLength\",\n            get: function get() {\n              var _this$_fullRequestRea, _this$_fullRequestRea2;\n              return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;\n            }\n          }, {\n            key: \"_onProgress\",\n            value: function _onProgress(evt) {\n              if (evt.total === undefined) {\n                var _this$_rangeReaders$, _this$_rangeReaders$$;\n                (_this$_rangeReaders$ = this._rangeReaders[0]) === null || _this$_rangeReaders$ === void 0 ? void 0 : (_this$_rangeReaders$$ = _this$_rangeReaders$.onProgress) === null || _this$_rangeReaders$$ === void 0 ? void 0 : _this$_rangeReaders$$.call(_this$_rangeReaders$, {\n                  loaded: evt.loaded\n                });\n              } else {\n                var _this$_fullRequestRea3, _this$_fullRequestRea4;\n                (_this$_fullRequestRea3 = this._fullRequestReader) === null || _this$_fullRequestRea3 === void 0 ? void 0 : (_this$_fullRequestRea4 = _this$_fullRequestRea3.onProgress) === null || _this$_fullRequestRea4 === void 0 ? void 0 : _this$_fullRequestRea4.call(_this$_fullRequestRea3, {\n                  loaded: evt.loaded,\n                  total: evt.total\n                });\n              }\n            }\n          }, {\n            key: \"_onProgressiveDone\",\n            value: function _onProgressiveDone() {\n              var _this$_fullRequestRea5;\n              (_this$_fullRequestRea5 = this._fullRequestReader) === null || _this$_fullRequestRea5 === void 0 ? void 0 : _this$_fullRequestRea5.progressiveDone();\n              this._progressiveDone = true;\n            }\n          }, {\n            key: \"_removeRangeReader\",\n            value: function _removeRangeReader(reader) {\n              var i = this._rangeReaders.indexOf(reader);\n              if (i >= 0) {\n                this._rangeReaders.splice(i, 1);\n              }\n            }\n          }, {\n            key: \"getFullReader\",\n            value: function getFullReader() {\n              (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n              var queuedChunks = this._queuedChunks;\n              this._queuedChunks = null;\n              return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n            }\n          }, {\n            key: \"getRangeReader\",\n            value: function getRangeReader(begin, end) {\n              if (end <= this._progressiveDataLength) {\n                return null;\n              }\n              var reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n              this._pdfDataRangeTransport.requestDataRange(begin, end);\n              this._rangeReaders.push(reader);\n              return reader;\n            }\n          }, {\n            key: \"cancelAllRequests\",\n            value: function cancelAllRequests(reason) {\n              var _this$_fullRequestRea6;\n              (_this$_fullRequestRea6 = this._fullRequestReader) === null || _this$_fullRequestRea6 === void 0 ? void 0 : _this$_fullRequestRea6.cancel(reason);\n              var _iterator66 = _createForOfIteratorHelper(this._rangeReaders.slice(0)),\n                _step66;\n              try {\n                for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {\n                  var reader = _step66.value;\n                  reader.cancel(reason);\n                }\n              } catch (err) {\n                _iterator66.e(err);\n              } finally {\n                _iterator66.f();\n              }\n              this._pdfDataRangeTransport.abort();\n            }\n          }]);\n          return PDFDataTransportStream;\n        }();\n        exports.PDFDataTransportStream = PDFDataTransportStream;\n        var PDFDataTransportStreamReader = /*#__PURE__*/function () {\n          function PDFDataTransportStreamReader(stream, queuedChunks) {\n            var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n            _classCallCheck(this, PDFDataTransportStreamReader);\n            this._stream = stream;\n            this._done = progressiveDone || false;\n            this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n            this._queuedChunks = queuedChunks || [];\n            this._loaded = 0;\n            var _iterator67 = _createForOfIteratorHelper(this._queuedChunks),\n              _step67;\n            try {\n              for (_iterator67.s(); !(_step67 = _iterator67.n()).done;) {\n                var chunk = _step67.value;\n                this._loaded += chunk.byteLength;\n              }\n            } catch (err) {\n              _iterator67.e(err);\n            } finally {\n              _iterator67.f();\n            }\n            this._requests = [];\n            this._headersReady = Promise.resolve();\n            stream._fullRequestReader = this;\n            this.onProgress = null;\n          }\n          _createClass(PDFDataTransportStreamReader, [{\n            key: \"_enqueue\",\n            value: function _enqueue(chunk) {\n              if (this._done) {\n                return;\n              }\n              if (this._requests.length > 0) {\n                var requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                  value: chunk,\n                  done: false\n                });\n              } else {\n                this._queuedChunks.push(chunk);\n              }\n              this._loaded += chunk.byteLength;\n            }\n          }, {\n            key: \"headersReady\",\n            get: function get() {\n              return this._headersReady;\n            }\n          }, {\n            key: \"filename\",\n            get: function get() {\n              return this._filename;\n            }\n          }, {\n            key: \"isRangeSupported\",\n            get: function get() {\n              return this._stream._isRangeSupported;\n            }\n          }, {\n            key: \"isStreamingSupported\",\n            get: function get() {\n              return this._stream._isStreamingSupported;\n            }\n          }, {\n            key: \"contentLength\",\n            get: function get() {\n              return this._stream._contentLength;\n            }\n          }, {\n            key: \"read\",\n            value: function () {\n              var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n                var chunk, requestCapability;\n                return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n                  while (1) switch (_context12.prev = _context12.next) {\n                    case 0:\n                      if (!(this._queuedChunks.length > 0)) {\n                        _context12.next = 3;\n                        break;\n                      }\n                      chunk = this._queuedChunks.shift();\n                      return _context12.abrupt(\"return\", {\n                        value: chunk,\n                        done: false\n                      });\n                    case 3:\n                      if (!this._done) {\n                        _context12.next = 5;\n                        break;\n                      }\n                      return _context12.abrupt(\"return\", {\n                        value: undefined,\n                        done: true\n                      });\n                    case 5:\n                      requestCapability = new _util.PromiseCapability();\n                      this._requests.push(requestCapability);\n                      return _context12.abrupt(\"return\", requestCapability.promise);\n                    case 8:\n                    case \"end\":\n                      return _context12.stop();\n                  }\n                }, _callee12, this);\n              }));\n              function read() {\n                return _read.apply(this, arguments);\n              }\n              return read;\n            }()\n          }, {\n            key: \"cancel\",\n            value: function cancel(reason) {\n              this._done = true;\n              var _iterator68 = _createForOfIteratorHelper(this._requests),\n                _step68;\n              try {\n                for (_iterator68.s(); !(_step68 = _iterator68.n()).done;) {\n                  var requestCapability = _step68.value;\n                  requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                  });\n                }\n              } catch (err) {\n                _iterator68.e(err);\n              } finally {\n                _iterator68.f();\n              }\n              this._requests.length = 0;\n            }\n          }, {\n            key: \"progressiveDone\",\n            value: function progressiveDone() {\n              if (this._done) {\n                return;\n              }\n              this._done = true;\n            }\n          }]);\n          return PDFDataTransportStreamReader;\n        }();\n        var PDFDataTransportStreamRangeReader = /*#__PURE__*/function () {\n          function PDFDataTransportStreamRangeReader(stream, begin, end) {\n            _classCallCheck(this, PDFDataTransportStreamRangeReader);\n            this._stream = stream;\n            this._begin = begin;\n            this._end = end;\n            this._queuedChunk = null;\n            this._requests = [];\n            this._done = false;\n            this.onProgress = null;\n          }\n          _createClass(PDFDataTransportStreamRangeReader, [{\n            key: \"_enqueue\",\n            value: function _enqueue(chunk) {\n              if (this._done) {\n                return;\n              }\n              if (this._requests.length === 0) {\n                this._queuedChunk = chunk;\n              } else {\n                var requestsCapability = this._requests.shift();\n                requestsCapability.resolve({\n                  value: chunk,\n                  done: false\n                });\n                var _iterator69 = _createForOfIteratorHelper(this._requests),\n                  _step69;\n                try {\n                  for (_iterator69.s(); !(_step69 = _iterator69.n()).done;) {\n                    var requestCapability = _step69.value;\n                    requestCapability.resolve({\n                      value: undefined,\n                      done: true\n                    });\n                  }\n                } catch (err) {\n                  _iterator69.e(err);\n                } finally {\n                  _iterator69.f();\n                }\n                this._requests.length = 0;\n              }\n              this._done = true;\n              this._stream._removeRangeReader(this);\n            }\n          }, {\n            key: \"isStreamingSupported\",\n            get: function get() {\n              return false;\n            }\n          }, {\n            key: \"read\",\n            value: function () {\n              var _read2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n                var chunk, requestCapability;\n                return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n                  while (1) switch (_context13.prev = _context13.next) {\n                    case 0:\n                      if (!this._queuedChunk) {\n                        _context13.next = 4;\n                        break;\n                      }\n                      chunk = this._queuedChunk;\n                      this._queuedChunk = null;\n                      return _context13.abrupt(\"return\", {\n                        value: chunk,\n                        done: false\n                      });\n                    case 4:\n                      if (!this._done) {\n                        _context13.next = 6;\n                        break;\n                      }\n                      return _context13.abrupt(\"return\", {\n                        value: undefined,\n                        done: true\n                      });\n                    case 6:\n                      requestCapability = new _util.PromiseCapability();\n                      this._requests.push(requestCapability);\n                      return _context13.abrupt(\"return\", requestCapability.promise);\n                    case 9:\n                    case \"end\":\n                      return _context13.stop();\n                  }\n                }, _callee13, this);\n              }));\n              function read() {\n                return _read2.apply(this, arguments);\n              }\n              return read;\n            }()\n          }, {\n            key: \"cancel\",\n            value: function cancel(reason) {\n              this._done = true;\n              var _iterator70 = _createForOfIteratorHelper(this._requests),\n                _step70;\n              try {\n                for (_iterator70.s(); !(_step70 = _iterator70.n()).done;) {\n                  var requestCapability = _step70.value;\n                  requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                  });\n                }\n              } catch (err) {\n                _iterator70.e(err);\n              } finally {\n                _iterator70.f();\n              }\n              this._requests.length = 0;\n              this._stream._removeRangeReader(this);\n            }\n          }]);\n          return PDFDataTransportStreamRangeReader;\n        }();\n        /***/\n      }, /* 19 */\n      /***/function (__unused_webpack_module, exports) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.XfaText = void 0;\n        var XfaText = /*#__PURE__*/function () {\n          function XfaText() {\n            _classCallCheck(this, XfaText);\n          }\n          _createClass(XfaText, null, [{\n            key: \"textContent\",\n            value: function textContent(xfa) {\n              var items = [];\n              var output = {\n                items: items,\n                styles: Object.create(null)\n              };\n              function walk(node) {\n                var _node$attributes;\n                if (!node) {\n                  return;\n                }\n                var str = null;\n                var name = node.name;\n                if (name === \"#text\") {\n                  str = node.value;\n                } else if (!XfaText.shouldBuildText(name)) {\n                  return;\n                } else if (node !== null && node !== void 0 && (_node$attributes = node.attributes) !== null && _node$attributes !== void 0 && _node$attributes.textContent) {\n                  str = node.attributes.textContent;\n                } else if (node.value) {\n                  str = node.value;\n                }\n                if (str !== null) {\n                  items.push({\n                    str: str\n                  });\n                }\n                if (!node.children) {\n                  return;\n                }\n                var _iterator71 = _createForOfIteratorHelper(node.children),\n                  _step71;\n                try {\n                  for (_iterator71.s(); !(_step71 = _iterator71.n()).done;) {\n                    var child = _step71.value;\n                    walk(child);\n                  }\n                } catch (err) {\n                  _iterator71.e(err);\n                } finally {\n                  _iterator71.f();\n                }\n              }\n              walk(xfa);\n              return output;\n            }\n          }, {\n            key: \"shouldBuildText\",\n            value: function shouldBuildText(name) {\n              return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n            }\n          }]);\n          return XfaText;\n        }();\n        exports.XfaText = XfaText;\n\n        /***/\n      }, /* 20 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.NodeStandardFontDataFactory = exports.NodeFilterFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;\n        var _base_factory = __w_pdfjs_require__(7);\n        ;\n        var fetchData = function fetchData(url) {\n          return new Promise(function (resolve, reject) {\n            var fs = require(\"fs\");\n            fs.readFile(url, function (error, data) {\n              if (error || !data) {\n                reject(new Error(error));\n                return;\n              }\n              resolve(new Uint8Array(data));\n            });\n          });\n        };\n        var NodeFilterFactory = /*#__PURE__*/function (_base_factory$BaseFil2) {\n          _inherits(NodeFilterFactory, _base_factory$BaseFil2);\n          var _super18 = _createSuper(NodeFilterFactory);\n          function NodeFilterFactory() {\n            _classCallCheck(this, NodeFilterFactory);\n            return _super18.apply(this, arguments);\n          }\n          return _createClass(NodeFilterFactory);\n        }(_base_factory.BaseFilterFactory);\n        exports.NodeFilterFactory = NodeFilterFactory;\n        var NodeCanvasFactory = /*#__PURE__*/function (_base_factory$BaseCan2) {\n          _inherits(NodeCanvasFactory, _base_factory$BaseCan2);\n          var _super19 = _createSuper(NodeCanvasFactory);\n          function NodeCanvasFactory() {\n            _classCallCheck(this, NodeCanvasFactory);\n            return _super19.apply(this, arguments);\n          }\n          _createClass(NodeCanvasFactory, [{\n            key: \"_createCanvas\",\n            value: function _createCanvas(width, height) {\n              var Canvas = require(\"canvas\");\n              return Canvas.createCanvas(width, height);\n            }\n          }]);\n          return NodeCanvasFactory;\n        }(_base_factory.BaseCanvasFactory);\n        exports.NodeCanvasFactory = NodeCanvasFactory;\n        var NodeCMapReaderFactory = /*#__PURE__*/function (_base_factory$BaseCMa2) {\n          _inherits(NodeCMapReaderFactory, _base_factory$BaseCMa2);\n          var _super20 = _createSuper(NodeCMapReaderFactory);\n          function NodeCMapReaderFactory() {\n            _classCallCheck(this, NodeCMapReaderFactory);\n            return _super20.apply(this, arguments);\n          }\n          _createClass(NodeCMapReaderFactory, [{\n            key: \"_fetchData\",\n            value: function _fetchData(url, compressionType) {\n              return fetchData(url).then(function (data) {\n                return {\n                  cMapData: data,\n                  compressionType: compressionType\n                };\n              });\n            }\n          }]);\n          return NodeCMapReaderFactory;\n        }(_base_factory.BaseCMapReaderFactory);\n        exports.NodeCMapReaderFactory = NodeCMapReaderFactory;\n        var NodeStandardFontDataFactory = /*#__PURE__*/function (_base_factory$BaseSta2) {\n          _inherits(NodeStandardFontDataFactory, _base_factory$BaseSta2);\n          var _super21 = _createSuper(NodeStandardFontDataFactory);\n          function NodeStandardFontDataFactory() {\n            _classCallCheck(this, NodeStandardFontDataFactory);\n            return _super21.apply(this, arguments);\n          }\n          _createClass(NodeStandardFontDataFactory, [{\n            key: \"_fetchData\",\n            value: function _fetchData(url) {\n              return fetchData(url);\n            }\n          }]);\n          return NodeStandardFontDataFactory;\n        }(_base_factory.BaseStandardFontDataFactory);\n        exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n\n        /***/\n      }, /* 21 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.PDFNodeStream = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _network_utils = __w_pdfjs_require__(22);\n        ;\n        var fs = require(\"fs\");\n        var http = require(\"http\");\n        var https = require(\"https\");\n        var url = require(\"url\");\n        var fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n        function parseUrl(sourceUrl) {\n          var parsedUrl = url.parse(sourceUrl);\n          if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n            return parsedUrl;\n          }\n          if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n            return url.parse(\"file:///\".concat(sourceUrl));\n          }\n          if (!parsedUrl.host) {\n            parsedUrl.protocol = \"file:\";\n          }\n          return parsedUrl;\n        }\n        var PDFNodeStream = /*#__PURE__*/function () {\n          function PDFNodeStream(source) {\n            _classCallCheck(this, PDFNodeStream);\n            this.source = source;\n            this.url = parseUrl(source.url);\n            this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n            this.isFsUrl = this.url.protocol === \"file:\";\n            this.httpHeaders = this.isHttp && source.httpHeaders || {};\n            this._fullRequestReader = null;\n            this._rangeRequestReaders = [];\n          }\n          _createClass(PDFNodeStream, [{\n            key: \"_progressiveDataLength\",\n            get: function get() {\n              var _this$_fullRequestRea7, _this$_fullRequestRea8;\n              return (_this$_fullRequestRea7 = (_this$_fullRequestRea8 = this._fullRequestReader) === null || _this$_fullRequestRea8 === void 0 ? void 0 : _this$_fullRequestRea8._loaded) !== null && _this$_fullRequestRea7 !== void 0 ? _this$_fullRequestRea7 : 0;\n            }\n          }, {\n            key: \"getFullReader\",\n            value: function getFullReader() {\n              (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n              this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n              return this._fullRequestReader;\n            }\n          }, {\n            key: \"getRangeReader\",\n            value: function getRangeReader(start, end) {\n              if (end <= this._progressiveDataLength) {\n                return null;\n              }\n              var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n              this._rangeRequestReaders.push(rangeReader);\n              return rangeReader;\n            }\n          }, {\n            key: \"cancelAllRequests\",\n            value: function cancelAllRequests(reason) {\n              var _this$_fullRequestRea9;\n              (_this$_fullRequestRea9 = this._fullRequestReader) === null || _this$_fullRequestRea9 === void 0 ? void 0 : _this$_fullRequestRea9.cancel(reason);\n              var _iterator72 = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),\n                _step72;\n              try {\n                for (_iterator72.s(); !(_step72 = _iterator72.n()).done;) {\n                  var reader = _step72.value;\n                  reader.cancel(reason);\n                }\n              } catch (err) {\n                _iterator72.e(err);\n              } finally {\n                _iterator72.f();\n              }\n            }\n          }]);\n          return PDFNodeStream;\n        }();\n        exports.PDFNodeStream = PDFNodeStream;\n        var BaseFullReader = /*#__PURE__*/function () {\n          function BaseFullReader(stream) {\n            _classCallCheck(this, BaseFullReader);\n            this._url = stream.url;\n            this._done = false;\n            this._storedError = null;\n            this.onProgress = null;\n            var source = stream.source;\n            this._contentLength = source.length;\n            this._loaded = 0;\n            this._filename = null;\n            this._disableRange = source.disableRange || false;\n            this._rangeChunkSize = source.rangeChunkSize;\n            if (!this._rangeChunkSize && !this._disableRange) {\n              this._disableRange = true;\n            }\n            this._isStreamingSupported = !source.disableStream;\n            this._isRangeSupported = !source.disableRange;\n            this._readableStream = null;\n            this._readCapability = new _util.PromiseCapability();\n            this._headersCapability = new _util.PromiseCapability();\n          }\n          _createClass(BaseFullReader, [{\n            key: \"headersReady\",\n            get: function get() {\n              return this._headersCapability.promise;\n            }\n          }, {\n            key: \"filename\",\n            get: function get() {\n              return this._filename;\n            }\n          }, {\n            key: \"contentLength\",\n            get: function get() {\n              return this._contentLength;\n            }\n          }, {\n            key: \"isRangeSupported\",\n            get: function get() {\n              return this._isRangeSupported;\n            }\n          }, {\n            key: \"isStreamingSupported\",\n            get: function get() {\n              return this._isStreamingSupported;\n            }\n          }, {\n            key: \"read\",\n            value: function () {\n              var _read3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n                var _this$onProgress;\n                var chunk, buffer;\n                return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n                  while (1) switch (_context14.prev = _context14.next) {\n                    case 0:\n                      _context14.next = 2;\n                      return this._readCapability.promise;\n                    case 2:\n                      if (!this._done) {\n                        _context14.next = 4;\n                        break;\n                      }\n                      return _context14.abrupt(\"return\", {\n                        value: undefined,\n                        done: true\n                      });\n                    case 4:\n                      if (!this._storedError) {\n                        _context14.next = 6;\n                        break;\n                      }\n                      throw this._storedError;\n                    case 6:\n                      chunk = this._readableStream.read();\n                      if (!(chunk === null)) {\n                        _context14.next = 10;\n                        break;\n                      }\n                      this._readCapability = new _util.PromiseCapability();\n                      return _context14.abrupt(\"return\", this.read());\n                    case 10:\n                      this._loaded += chunk.length;\n                      (_this$onProgress = this.onProgress) === null || _this$onProgress === void 0 ? void 0 : _this$onProgress.call(this, {\n                        loaded: this._loaded,\n                        total: this._contentLength\n                      });\n                      buffer = new Uint8Array(chunk).buffer;\n                      return _context14.abrupt(\"return\", {\n                        value: buffer,\n                        done: false\n                      });\n                    case 14:\n                    case \"end\":\n                      return _context14.stop();\n                  }\n                }, _callee14, this);\n              }));\n              function read() {\n                return _read3.apply(this, arguments);\n              }\n              return read;\n            }()\n          }, {\n            key: \"cancel\",\n            value: function cancel(reason) {\n              if (!this._readableStream) {\n                this._error(reason);\n                return;\n              }\n              this._readableStream.destroy(reason);\n            }\n          }, {\n            key: \"_error\",\n            value: function _error(reason) {\n              this._storedError = reason;\n              this._readCapability.resolve();\n            }\n          }, {\n            key: \"_setReadableStream\",\n            value: function _setReadableStream(readableStream) {\n              var _this37 = this;\n              this._readableStream = readableStream;\n              readableStream.on(\"readable\", function () {\n                _this37._readCapability.resolve();\n              });\n              readableStream.on(\"end\", function () {\n                readableStream.destroy();\n                _this37._done = true;\n                _this37._readCapability.resolve();\n              });\n              readableStream.on(\"error\", function (reason) {\n                _this37._error(reason);\n              });\n              if (!this._isStreamingSupported && this._isRangeSupported) {\n                this._error(new _util.AbortException(\"streaming is disabled\"));\n              }\n              if (this._storedError) {\n                this._readableStream.destroy(this._storedError);\n              }\n            }\n          }]);\n          return BaseFullReader;\n        }();\n        var BaseRangeReader = /*#__PURE__*/function () {\n          function BaseRangeReader(stream) {\n            _classCallCheck(this, BaseRangeReader);\n            this._url = stream.url;\n            this._done = false;\n            this._storedError = null;\n            this.onProgress = null;\n            this._loaded = 0;\n            this._readableStream = null;\n            this._readCapability = new _util.PromiseCapability();\n            var source = stream.source;\n            this._isStreamingSupported = !source.disableStream;\n          }\n          _createClass(BaseRangeReader, [{\n            key: \"isStreamingSupported\",\n            get: function get() {\n              return this._isStreamingSupported;\n            }\n          }, {\n            key: \"read\",\n            value: function () {\n              var _read4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n                var _this$onProgress2;\n                var chunk, buffer;\n                return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n                  while (1) switch (_context15.prev = _context15.next) {\n                    case 0:\n                      _context15.next = 2;\n                      return this._readCapability.promise;\n                    case 2:\n                      if (!this._done) {\n                        _context15.next = 4;\n                        break;\n                      }\n                      return _context15.abrupt(\"return\", {\n                        value: undefined,\n                        done: true\n                      });\n                    case 4:\n                      if (!this._storedError) {\n                        _context15.next = 6;\n                        break;\n                      }\n                      throw this._storedError;\n                    case 6:\n                      chunk = this._readableStream.read();\n                      if (!(chunk === null)) {\n                        _context15.next = 10;\n                        break;\n                      }\n                      this._readCapability = new _util.PromiseCapability();\n                      return _context15.abrupt(\"return\", this.read());\n                    case 10:\n                      this._loaded += chunk.length;\n                      (_this$onProgress2 = this.onProgress) === null || _this$onProgress2 === void 0 ? void 0 : _this$onProgress2.call(this, {\n                        loaded: this._loaded\n                      });\n                      buffer = new Uint8Array(chunk).buffer;\n                      return _context15.abrupt(\"return\", {\n                        value: buffer,\n                        done: false\n                      });\n                    case 14:\n                    case \"end\":\n                      return _context15.stop();\n                  }\n                }, _callee15, this);\n              }));\n              function read() {\n                return _read4.apply(this, arguments);\n              }\n              return read;\n            }()\n          }, {\n            key: \"cancel\",\n            value: function cancel(reason) {\n              if (!this._readableStream) {\n                this._error(reason);\n                return;\n              }\n              this._readableStream.destroy(reason);\n            }\n          }, {\n            key: \"_error\",\n            value: function _error(reason) {\n              this._storedError = reason;\n              this._readCapability.resolve();\n            }\n          }, {\n            key: \"_setReadableStream\",\n            value: function _setReadableStream(readableStream) {\n              var _this38 = this;\n              this._readableStream = readableStream;\n              readableStream.on(\"readable\", function () {\n                _this38._readCapability.resolve();\n              });\n              readableStream.on(\"end\", function () {\n                readableStream.destroy();\n                _this38._done = true;\n                _this38._readCapability.resolve();\n              });\n              readableStream.on(\"error\", function (reason) {\n                _this38._error(reason);\n              });\n              if (this._storedError) {\n                this._readableStream.destroy(this._storedError);\n              }\n            }\n          }]);\n          return BaseRangeReader;\n        }();\n        function createRequestOptions(parsedUrl, headers) {\n          return {\n            protocol: parsedUrl.protocol,\n            auth: parsedUrl.auth,\n            host: parsedUrl.hostname,\n            port: parsedUrl.port,\n            path: parsedUrl.path,\n            method: \"GET\",\n            headers: headers\n          };\n        }\n        var PDFNodeStreamFullReader = /*#__PURE__*/function (_BaseFullReader) {\n          _inherits(PDFNodeStreamFullReader, _BaseFullReader);\n          var _super22 = _createSuper(PDFNodeStreamFullReader);\n          function PDFNodeStreamFullReader(stream) {\n            var _this39;\n            _classCallCheck(this, PDFNodeStreamFullReader);\n            _this39 = _super22.call(this, stream);\n            var handleResponse = function handleResponse(response) {\n              if (response.statusCode === 404) {\n                var error = new _util.MissingPDFException(\"Missing PDF \\\"\".concat(_this39._url, \"\\\".\"));\n                _this39._storedError = error;\n                _this39._headersCapability.reject(error);\n                return;\n              }\n              _this39._headersCapability.resolve();\n              _this39._setReadableStream(response);\n              var getResponseHeader = function getResponseHeader(name) {\n                return _this39._readableStream.headers[name.toLowerCase()];\n              };\n              var _ref55 = (0, _network_utils.validateRangeRequestCapabilities)({\n                  getResponseHeader: getResponseHeader,\n                  isHttp: stream.isHttp,\n                  rangeChunkSize: _this39._rangeChunkSize,\n                  disableRange: _this39._disableRange\n                }),\n                allowRangeRequests = _ref55.allowRangeRequests,\n                suggestedLength = _ref55.suggestedLength;\n              _this39._isRangeSupported = allowRangeRequests;\n              _this39._contentLength = suggestedLength || _this39._contentLength;\n              _this39._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n            };\n            _this39._request = null;\n            if (_this39._url.protocol === \"http:\") {\n              _this39._request = http.request(createRequestOptions(_this39._url, stream.httpHeaders), handleResponse);\n            } else {\n              _this39._request = https.request(createRequestOptions(_this39._url, stream.httpHeaders), handleResponse);\n            }\n            _this39._request.on(\"error\", function (reason) {\n              _this39._storedError = reason;\n              _this39._headersCapability.reject(reason);\n            });\n            _this39._request.end();\n            return _this39;\n          }\n          return _createClass(PDFNodeStreamFullReader);\n        }(BaseFullReader);\n        var PDFNodeStreamRangeReader = /*#__PURE__*/function (_BaseRangeReader) {\n          _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);\n          var _super23 = _createSuper(PDFNodeStreamRangeReader);\n          function PDFNodeStreamRangeReader(stream, start, end) {\n            var _this40;\n            _classCallCheck(this, PDFNodeStreamRangeReader);\n            _this40 = _super23.call(this, stream);\n            _this40._httpHeaders = {};\n            for (var property in stream.httpHeaders) {\n              var value = stream.httpHeaders[property];\n              if (value === undefined) {\n                continue;\n              }\n              _this40._httpHeaders[property] = value;\n            }\n            _this40._httpHeaders.Range = \"bytes=\".concat(start, \"-\").concat(end - 1);\n            var handleResponse = function handleResponse(response) {\n              if (response.statusCode === 404) {\n                var error = new _util.MissingPDFException(\"Missing PDF \\\"\".concat(_this40._url, \"\\\".\"));\n                _this40._storedError = error;\n                return;\n              }\n              _this40._setReadableStream(response);\n            };\n            _this40._request = null;\n            if (_this40._url.protocol === \"http:\") {\n              _this40._request = http.request(createRequestOptions(_this40._url, _this40._httpHeaders), handleResponse);\n            } else {\n              _this40._request = https.request(createRequestOptions(_this40._url, _this40._httpHeaders), handleResponse);\n            }\n            _this40._request.on(\"error\", function (reason) {\n              _this40._storedError = reason;\n            });\n            _this40._request.end();\n            return _this40;\n          }\n          return _createClass(PDFNodeStreamRangeReader);\n        }(BaseRangeReader);\n        var PDFNodeStreamFsFullReader = /*#__PURE__*/function (_BaseFullReader2) {\n          _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);\n          var _super24 = _createSuper(PDFNodeStreamFsFullReader);\n          function PDFNodeStreamFsFullReader(stream) {\n            var _this41;\n            _classCallCheck(this, PDFNodeStreamFsFullReader);\n            _this41 = _super24.call(this, stream);\n            var path = decodeURIComponent(_this41._url.path);\n            if (fileUriRegex.test(_this41._url.href)) {\n              path = path.replace(/^\\//, \"\");\n            }\n            fs.lstat(path, function (error, stat) {\n              if (error) {\n                if (error.code === \"ENOENT\") {\n                  error = new _util.MissingPDFException(\"Missing PDF \\\"\".concat(path, \"\\\".\"));\n                }\n                _this41._storedError = error;\n                _this41._headersCapability.reject(error);\n                return;\n              }\n              _this41._contentLength = stat.size;\n              _this41._setReadableStream(fs.createReadStream(path));\n              _this41._headersCapability.resolve();\n            });\n            return _this41;\n          }\n          return _createClass(PDFNodeStreamFsFullReader);\n        }(BaseFullReader);\n        var PDFNodeStreamFsRangeReader = /*#__PURE__*/function (_BaseRangeReader2) {\n          _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);\n          var _super25 = _createSuper(PDFNodeStreamFsRangeReader);\n          function PDFNodeStreamFsRangeReader(stream, start, end) {\n            var _this42;\n            _classCallCheck(this, PDFNodeStreamFsRangeReader);\n            _this42 = _super25.call(this, stream);\n            var path = decodeURIComponent(_this42._url.path);\n            if (fileUriRegex.test(_this42._url.href)) {\n              path = path.replace(/^\\//, \"\");\n            }\n            _this42._setReadableStream(fs.createReadStream(path, {\n              start: start,\n              end: end - 1\n            }));\n            return _this42;\n          }\n          return _createClass(PDFNodeStreamFsRangeReader);\n        }(BaseRangeReader);\n        /***/\n      }, /* 22 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.createResponseStatusError = createResponseStatusError;\n        exports.extractFilenameFromHeader = extractFilenameFromHeader;\n        exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\n        exports.validateResponseStatus = validateResponseStatus;\n        var _util = __w_pdfjs_require__(1);\n        var _content_disposition = __w_pdfjs_require__(23);\n        var _display_utils = __w_pdfjs_require__(6);\n        function validateRangeRequestCapabilities(_ref56) {\n          var getResponseHeader = _ref56.getResponseHeader,\n            isHttp = _ref56.isHttp,\n            rangeChunkSize = _ref56.rangeChunkSize,\n            disableRange = _ref56.disableRange;\n          var returnValues = {\n            allowRangeRequests: false,\n            suggestedLength: undefined\n          };\n          var length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n          if (!Number.isInteger(length)) {\n            return returnValues;\n          }\n          returnValues.suggestedLength = length;\n          if (length <= 2 * rangeChunkSize) {\n            return returnValues;\n          }\n          if (disableRange || !isHttp) {\n            return returnValues;\n          }\n          if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n            return returnValues;\n          }\n          var contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n          if (contentEncoding !== \"identity\") {\n            return returnValues;\n          }\n          returnValues.allowRangeRequests = true;\n          return returnValues;\n        }\n        function extractFilenameFromHeader(getResponseHeader) {\n          var contentDisposition = getResponseHeader(\"Content-Disposition\");\n          if (contentDisposition) {\n            var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n            if (filename.includes(\"%\")) {\n              try {\n                filename = decodeURIComponent(filename);\n              } catch (ex) {}\n            }\n            if ((0, _display_utils.isPdfFile)(filename)) {\n              return filename;\n            }\n          }\n          return null;\n        }\n        function createResponseStatusError(status, url) {\n          if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n            return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n          }\n          return new _util.UnexpectedResponseException(\"Unexpected server response (\".concat(status, \") while retrieving PDF \\\"\").concat(url, \"\\\".\"), status);\n        }\n        function validateResponseStatus(status) {\n          return status === 200 || status === 206;\n        }\n\n        /***/\n      }, /* 23 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n        var _util = __w_pdfjs_require__(1);\n        function getFilenameFromContentDispositionHeader(contentDisposition) {\n          var needsEncodingFixup = true;\n          var tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n          if (tmp) {\n            tmp = tmp[1];\n            var filename = rfc2616unquote(tmp);\n            filename = unescape(filename);\n            filename = rfc5987decode(filename);\n            filename = rfc2047decode(filename);\n            return fixupEncoding(filename);\n          }\n          tmp = rfc2231getparam(contentDisposition);\n          if (tmp) {\n            var _filename = rfc2047decode(tmp);\n            return fixupEncoding(_filename);\n          }\n          tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n          if (tmp) {\n            tmp = tmp[1];\n            var _filename2 = rfc2616unquote(tmp);\n            _filename2 = rfc2047decode(_filename2);\n            return fixupEncoding(_filename2);\n          }\n          function toParamRegExp(attributePattern, flags) {\n            return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n          }\n          function textdecode(encoding, value) {\n            if (encoding) {\n              if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                return value;\n              }\n              try {\n                var decoder = new TextDecoder(encoding, {\n                  fatal: true\n                });\n                var buffer = (0, _util.stringToBytes)(value);\n                value = decoder.decode(buffer);\n                needsEncodingFixup = false;\n              } catch (e) {}\n            }\n            return value;\n          }\n          function fixupEncoding(value) {\n            if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n              value = textdecode(\"utf-8\", value);\n              if (needsEncodingFixup) {\n                value = textdecode(\"iso-8859-1\", value);\n              }\n            }\n            return value;\n          }\n          function rfc2231getparam(contentDispositionStr) {\n            var matches = [];\n            var match;\n            var iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n            while ((match = iter.exec(contentDispositionStr)) !== null) {\n              var _match = match,\n                _match2 = _slicedToArray(_match, 4),\n                n = _match2[1],\n                quot = _match2[2],\n                part = _match2[3];\n              n = parseInt(n, 10);\n              if (n in matches) {\n                if (n === 0) {\n                  break;\n                }\n                continue;\n              }\n              matches[n] = [quot, part];\n            }\n            var parts = [];\n            for (var _n = 0; _n < matches.length; ++_n) {\n              if (!(_n in matches)) {\n                break;\n              }\n              var _matches$_n = _slicedToArray(matches[_n], 2),\n                _quot = _matches$_n[0],\n                _part = _matches$_n[1];\n              _part = rfc2616unquote(_part);\n              if (_quot) {\n                _part = unescape(_part);\n                if (_n === 0) {\n                  _part = rfc5987decode(_part);\n                }\n              }\n              parts.push(_part);\n            }\n            return parts.join(\"\");\n          }\n          function rfc2616unquote(value) {\n            if (value.startsWith('\"')) {\n              var parts = value.slice(1).split('\\\\\"');\n              for (var i = 0; i < parts.length; ++i) {\n                var quotindex = parts[i].indexOf('\"');\n                if (quotindex !== -1) {\n                  parts[i] = parts[i].slice(0, quotindex);\n                  parts.length = i + 1;\n                }\n                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n              }\n              value = parts.join('\"');\n            }\n            return value;\n          }\n          function rfc5987decode(extvalue) {\n            var encodingend = extvalue.indexOf(\"'\");\n            if (encodingend === -1) {\n              return extvalue;\n            }\n            var encoding = extvalue.slice(0, encodingend);\n            var langvalue = extvalue.slice(encodingend + 1);\n            var value = langvalue.replace(/^[^']*'/, \"\");\n            return textdecode(encoding, value);\n          }\n          function rfc2047decode(value) {\n            if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n              return value;\n            }\n            return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n              if (encoding === \"q\" || encoding === \"Q\") {\n                text = text.replaceAll(\"_\", \" \");\n                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n                  return String.fromCharCode(parseInt(hex, 16));\n                });\n                return textdecode(charset, text);\n              }\n              try {\n                text = atob(text);\n              } catch (e) {}\n              return textdecode(charset, text);\n            });\n          }\n          return \"\";\n        }\n\n        /***/\n      }, /* 24 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.PDFNetworkStream = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _network_utils = __w_pdfjs_require__(22);\n        ;\n        var OK_RESPONSE = 200;\n        var PARTIAL_CONTENT_RESPONSE = 206;\n        function getArrayBuffer(xhr) {\n          var data = xhr.response;\n          if (typeof data !== \"string\") {\n            return data;\n          }\n          return (0, _util.stringToBytes)(data).buffer;\n        }\n        var NetworkManager = /*#__PURE__*/function () {\n          function NetworkManager(url) {\n            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            _classCallCheck(this, NetworkManager);\n            this.url = url;\n            this.isHttp = /^https?:/i.test(url);\n            this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n            this.withCredentials = args.withCredentials || false;\n            this.currXhrId = 0;\n            this.pendingRequests = Object.create(null);\n          }\n          _createClass(NetworkManager, [{\n            key: \"requestRange\",\n            value: function requestRange(begin, end, listeners) {\n              var args = {\n                begin: begin,\n                end: end\n              };\n              for (var prop in listeners) {\n                args[prop] = listeners[prop];\n              }\n              return this.request(args);\n            }\n          }, {\n            key: \"requestFull\",\n            value: function requestFull(listeners) {\n              return this.request(listeners);\n            }\n          }, {\n            key: \"request\",\n            value: function request(args) {\n              var xhr = new XMLHttpRequest();\n              var xhrId = this.currXhrId++;\n              var pendingRequest = this.pendingRequests[xhrId] = {\n                xhr: xhr\n              };\n              xhr.open(\"GET\", this.url);\n              xhr.withCredentials = this.withCredentials;\n              for (var property in this.httpHeaders) {\n                var value = this.httpHeaders[property];\n                if (value === undefined) {\n                  continue;\n                }\n                xhr.setRequestHeader(property, value);\n              }\n              if (this.isHttp && \"begin\" in args && \"end\" in args) {\n                xhr.setRequestHeader(\"Range\", \"bytes=\".concat(args.begin, \"-\").concat(args.end - 1));\n                pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n              } else {\n                pendingRequest.expectedStatus = OK_RESPONSE;\n              }\n              xhr.responseType = \"arraybuffer\";\n              if (args.onError) {\n                xhr.onerror = function (evt) {\n                  args.onError(xhr.status);\n                };\n              }\n              xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n              xhr.onprogress = this.onProgress.bind(this, xhrId);\n              pendingRequest.onHeadersReceived = args.onHeadersReceived;\n              pendingRequest.onDone = args.onDone;\n              pendingRequest.onError = args.onError;\n              pendingRequest.onProgress = args.onProgress;\n              xhr.send(null);\n              return xhrId;\n            }\n          }, {\n            key: \"onProgress\",\n            value: function onProgress(xhrId, evt) {\n              var _pendingRequest$onPro;\n              var pendingRequest = this.pendingRequests[xhrId];\n              if (!pendingRequest) {\n                return;\n              }\n              (_pendingRequest$onPro = pendingRequest.onProgress) === null || _pendingRequest$onPro === void 0 ? void 0 : _pendingRequest$onPro.call(pendingRequest, evt);\n            }\n          }, {\n            key: \"onStateChange\",\n            value: function onStateChange(xhrId, evt) {\n              var pendingRequest = this.pendingRequests[xhrId];\n              if (!pendingRequest) {\n                return;\n              }\n              var xhr = pendingRequest.xhr;\n              if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n                pendingRequest.onHeadersReceived();\n                delete pendingRequest.onHeadersReceived;\n              }\n              if (xhr.readyState !== 4) {\n                return;\n              }\n              if (!(xhrId in this.pendingRequests)) {\n                return;\n              }\n              delete this.pendingRequests[xhrId];\n              if (xhr.status === 0 && this.isHttp) {\n                var _pendingRequest$onErr;\n                (_pendingRequest$onErr = pendingRequest.onError) === null || _pendingRequest$onErr === void 0 ? void 0 : _pendingRequest$onErr.call(pendingRequest, xhr.status);\n                return;\n              }\n              var xhrStatus = xhr.status || OK_RESPONSE;\n              var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n              if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n                var _pendingRequest$onErr2;\n                (_pendingRequest$onErr2 = pendingRequest.onError) === null || _pendingRequest$onErr2 === void 0 ? void 0 : _pendingRequest$onErr2.call(pendingRequest, xhr.status);\n                return;\n              }\n              var chunk = getArrayBuffer(xhr);\n              if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n                var rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n                var matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n                pendingRequest.onDone({\n                  begin: parseInt(matches[1], 10),\n                  chunk: chunk\n                });\n              } else if (chunk) {\n                pendingRequest.onDone({\n                  begin: 0,\n                  chunk: chunk\n                });\n              } else {\n                var _pendingRequest$onErr3;\n                (_pendingRequest$onErr3 = pendingRequest.onError) === null || _pendingRequest$onErr3 === void 0 ? void 0 : _pendingRequest$onErr3.call(pendingRequest, xhr.status);\n              }\n            }\n          }, {\n            key: \"getRequestXhr\",\n            value: function getRequestXhr(xhrId) {\n              return this.pendingRequests[xhrId].xhr;\n            }\n          }, {\n            key: \"isPendingRequest\",\n            value: function isPendingRequest(xhrId) {\n              return xhrId in this.pendingRequests;\n            }\n          }, {\n            key: \"abortRequest\",\n            value: function abortRequest(xhrId) {\n              var xhr = this.pendingRequests[xhrId].xhr;\n              delete this.pendingRequests[xhrId];\n              xhr.abort();\n            }\n          }]);\n          return NetworkManager;\n        }();\n        var PDFNetworkStream = /*#__PURE__*/function () {\n          function PDFNetworkStream(source) {\n            _classCallCheck(this, PDFNetworkStream);\n            this._source = source;\n            this._manager = new NetworkManager(source.url, {\n              httpHeaders: source.httpHeaders,\n              withCredentials: source.withCredentials\n            });\n            this._rangeChunkSize = source.rangeChunkSize;\n            this._fullRequestReader = null;\n            this._rangeRequestReaders = [];\n          }\n          _createClass(PDFNetworkStream, [{\n            key: \"_onRangeRequestReaderClosed\",\n            value: function _onRangeRequestReaderClosed(reader) {\n              var i = this._rangeRequestReaders.indexOf(reader);\n              if (i >= 0) {\n                this._rangeRequestReaders.splice(i, 1);\n              }\n            }\n          }, {\n            key: \"getFullReader\",\n            value: function getFullReader() {\n              (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n              this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n              return this._fullRequestReader;\n            }\n          }, {\n            key: \"getRangeReader\",\n            value: function getRangeReader(begin, end) {\n              var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n              reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n              this._rangeRequestReaders.push(reader);\n              return reader;\n            }\n          }, {\n            key: \"cancelAllRequests\",\n            value: function cancelAllRequests(reason) {\n              var _this$_fullRequestRea10;\n              (_this$_fullRequestRea10 = this._fullRequestReader) === null || _this$_fullRequestRea10 === void 0 ? void 0 : _this$_fullRequestRea10.cancel(reason);\n              var _iterator73 = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),\n                _step73;\n              try {\n                for (_iterator73.s(); !(_step73 = _iterator73.n()).done;) {\n                  var reader = _step73.value;\n                  reader.cancel(reason);\n                }\n              } catch (err) {\n                _iterator73.e(err);\n              } finally {\n                _iterator73.f();\n              }\n            }\n          }]);\n          return PDFNetworkStream;\n        }();\n        exports.PDFNetworkStream = PDFNetworkStream;\n        var PDFNetworkStreamFullRequestReader = /*#__PURE__*/function () {\n          function PDFNetworkStreamFullRequestReader(manager, source) {\n            _classCallCheck(this, PDFNetworkStreamFullRequestReader);\n            this._manager = manager;\n            var args = {\n              onHeadersReceived: this._onHeadersReceived.bind(this),\n              onDone: this._onDone.bind(this),\n              onError: this._onError.bind(this),\n              onProgress: this._onProgress.bind(this)\n            };\n            this._url = source.url;\n            this._fullRequestId = manager.requestFull(args);\n            this._headersReceivedCapability = new _util.PromiseCapability();\n            this._disableRange = source.disableRange || false;\n            this._contentLength = source.length;\n            this._rangeChunkSize = source.rangeChunkSize;\n            if (!this._rangeChunkSize && !this._disableRange) {\n              this._disableRange = true;\n            }\n            this._isStreamingSupported = false;\n            this._isRangeSupported = false;\n            this._cachedChunks = [];\n            this._requests = [];\n            this._done = false;\n            this._storedError = undefined;\n            this._filename = null;\n            this.onProgress = null;\n          }\n          _createClass(PDFNetworkStreamFullRequestReader, [{\n            key: \"_onHeadersReceived\",\n            value: function _onHeadersReceived() {\n              var fullRequestXhrId = this._fullRequestId;\n              var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n              var getResponseHeader = function getResponseHeader(name) {\n                return fullRequestXhr.getResponseHeader(name);\n              };\n              var _ref57 = (0, _network_utils.validateRangeRequestCapabilities)({\n                  getResponseHeader: getResponseHeader,\n                  isHttp: this._manager.isHttp,\n                  rangeChunkSize: this._rangeChunkSize,\n                  disableRange: this._disableRange\n                }),\n                allowRangeRequests = _ref57.allowRangeRequests,\n                suggestedLength = _ref57.suggestedLength;\n              if (allowRangeRequests) {\n                this._isRangeSupported = true;\n              }\n              this._contentLength = suggestedLength || this._contentLength;\n              this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n              if (this._isRangeSupported) {\n                this._manager.abortRequest(fullRequestXhrId);\n              }\n              this._headersReceivedCapability.resolve();\n            }\n          }, {\n            key: \"_onDone\",\n            value: function _onDone(data) {\n              if (data) {\n                if (this._requests.length > 0) {\n                  var requestCapability = this._requests.shift();\n                  requestCapability.resolve({\n                    value: data.chunk,\n                    done: false\n                  });\n                } else {\n                  this._cachedChunks.push(data.chunk);\n                }\n              }\n              this._done = true;\n              if (this._cachedChunks.length > 0) {\n                return;\n              }\n              var _iterator74 = _createForOfIteratorHelper(this._requests),\n                _step74;\n              try {\n                for (_iterator74.s(); !(_step74 = _iterator74.n()).done;) {\n                  var _requestCapability = _step74.value;\n                  _requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                  });\n                }\n              } catch (err) {\n                _iterator74.e(err);\n              } finally {\n                _iterator74.f();\n              }\n              this._requests.length = 0;\n            }\n          }, {\n            key: \"_onError\",\n            value: function _onError(status) {\n              this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n              this._headersReceivedCapability.reject(this._storedError);\n              var _iterator75 = _createForOfIteratorHelper(this._requests),\n                _step75;\n              try {\n                for (_iterator75.s(); !(_step75 = _iterator75.n()).done;) {\n                  var requestCapability = _step75.value;\n                  requestCapability.reject(this._storedError);\n                }\n              } catch (err) {\n                _iterator75.e(err);\n              } finally {\n                _iterator75.f();\n              }\n              this._requests.length = 0;\n              this._cachedChunks.length = 0;\n            }\n          }, {\n            key: \"_onProgress\",\n            value: function _onProgress(evt) {\n              var _this$onProgress3;\n              (_this$onProgress3 = this.onProgress) === null || _this$onProgress3 === void 0 ? void 0 : _this$onProgress3.call(this, {\n                loaded: evt.loaded,\n                total: evt.lengthComputable ? evt.total : this._contentLength\n              });\n            }\n          }, {\n            key: \"filename\",\n            get: function get() {\n              return this._filename;\n            }\n          }, {\n            key: \"isRangeSupported\",\n            get: function get() {\n              return this._isRangeSupported;\n            }\n          }, {\n            key: \"isStreamingSupported\",\n            get: function get() {\n              return this._isStreamingSupported;\n            }\n          }, {\n            key: \"contentLength\",\n            get: function get() {\n              return this._contentLength;\n            }\n          }, {\n            key: \"headersReady\",\n            get: function get() {\n              return this._headersReceivedCapability.promise;\n            }\n          }, {\n            key: \"read\",\n            value: function () {\n              var _read5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n                var chunk, requestCapability;\n                return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n                  while (1) switch (_context16.prev = _context16.next) {\n                    case 0:\n                      if (!this._storedError) {\n                        _context16.next = 2;\n                        break;\n                      }\n                      throw this._storedError;\n                    case 2:\n                      if (!(this._cachedChunks.length > 0)) {\n                        _context16.next = 5;\n                        break;\n                      }\n                      chunk = this._cachedChunks.shift();\n                      return _context16.abrupt(\"return\", {\n                        value: chunk,\n                        done: false\n                      });\n                    case 5:\n                      if (!this._done) {\n                        _context16.next = 7;\n                        break;\n                      }\n                      return _context16.abrupt(\"return\", {\n                        value: undefined,\n                        done: true\n                      });\n                    case 7:\n                      requestCapability = new _util.PromiseCapability();\n                      this._requests.push(requestCapability);\n                      return _context16.abrupt(\"return\", requestCapability.promise);\n                    case 10:\n                    case \"end\":\n                      return _context16.stop();\n                  }\n                }, _callee16, this);\n              }));\n              function read() {\n                return _read5.apply(this, arguments);\n              }\n              return read;\n            }()\n          }, {\n            key: \"cancel\",\n            value: function cancel(reason) {\n              this._done = true;\n              this._headersReceivedCapability.reject(reason);\n              var _iterator76 = _createForOfIteratorHelper(this._requests),\n                _step76;\n              try {\n                for (_iterator76.s(); !(_step76 = _iterator76.n()).done;) {\n                  var requestCapability = _step76.value;\n                  requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                  });\n                }\n              } catch (err) {\n                _iterator76.e(err);\n              } finally {\n                _iterator76.f();\n              }\n              this._requests.length = 0;\n              if (this._manager.isPendingRequest(this._fullRequestId)) {\n                this._manager.abortRequest(this._fullRequestId);\n              }\n              this._fullRequestReader = null;\n            }\n          }]);\n          return PDFNetworkStreamFullRequestReader;\n        }();\n        var PDFNetworkStreamRangeRequestReader = /*#__PURE__*/function () {\n          function PDFNetworkStreamRangeRequestReader(manager, begin, end) {\n            _classCallCheck(this, PDFNetworkStreamRangeRequestReader);\n            this._manager = manager;\n            var args = {\n              onDone: this._onDone.bind(this),\n              onError: this._onError.bind(this),\n              onProgress: this._onProgress.bind(this)\n            };\n            this._url = manager.url;\n            this._requestId = manager.requestRange(begin, end, args);\n            this._requests = [];\n            this._queuedChunk = null;\n            this._done = false;\n            this._storedError = undefined;\n            this.onProgress = null;\n            this.onClosed = null;\n          }\n          _createClass(PDFNetworkStreamRangeRequestReader, [{\n            key: \"_close\",\n            value: function _close() {\n              var _this$onClosed;\n              (_this$onClosed = this.onClosed) === null || _this$onClosed === void 0 ? void 0 : _this$onClosed.call(this, this);\n            }\n          }, {\n            key: \"_onDone\",\n            value: function _onDone(data) {\n              var chunk = data.chunk;\n              if (this._requests.length > 0) {\n                var requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                  value: chunk,\n                  done: false\n                });\n              } else {\n                this._queuedChunk = chunk;\n              }\n              this._done = true;\n              var _iterator77 = _createForOfIteratorHelper(this._requests),\n                _step77;\n              try {\n                for (_iterator77.s(); !(_step77 = _iterator77.n()).done;) {\n                  var _requestCapability2 = _step77.value;\n                  _requestCapability2.resolve({\n                    value: undefined,\n                    done: true\n                  });\n                }\n              } catch (err) {\n                _iterator77.e(err);\n              } finally {\n                _iterator77.f();\n              }\n              this._requests.length = 0;\n              this._close();\n            }\n          }, {\n            key: \"_onError\",\n            value: function _onError(status) {\n              this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n              var _iterator78 = _createForOfIteratorHelper(this._requests),\n                _step78;\n              try {\n                for (_iterator78.s(); !(_step78 = _iterator78.n()).done;) {\n                  var requestCapability = _step78.value;\n                  requestCapability.reject(this._storedError);\n                }\n              } catch (err) {\n                _iterator78.e(err);\n              } finally {\n                _iterator78.f();\n              }\n              this._requests.length = 0;\n              this._queuedChunk = null;\n            }\n          }, {\n            key: \"_onProgress\",\n            value: function _onProgress(evt) {\n              if (!this.isStreamingSupported) {\n                var _this$onProgress4;\n                (_this$onProgress4 = this.onProgress) === null || _this$onProgress4 === void 0 ? void 0 : _this$onProgress4.call(this, {\n                  loaded: evt.loaded\n                });\n              }\n            }\n          }, {\n            key: \"isStreamingSupported\",\n            get: function get() {\n              return false;\n            }\n          }, {\n            key: \"read\",\n            value: function () {\n              var _read6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n                var chunk, requestCapability;\n                return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n                  while (1) switch (_context17.prev = _context17.next) {\n                    case 0:\n                      if (!this._storedError) {\n                        _context17.next = 2;\n                        break;\n                      }\n                      throw this._storedError;\n                    case 2:\n                      if (!(this._queuedChunk !== null)) {\n                        _context17.next = 6;\n                        break;\n                      }\n                      chunk = this._queuedChunk;\n                      this._queuedChunk = null;\n                      return _context17.abrupt(\"return\", {\n                        value: chunk,\n                        done: false\n                      });\n                    case 6:\n                      if (!this._done) {\n                        _context17.next = 8;\n                        break;\n                      }\n                      return _context17.abrupt(\"return\", {\n                        value: undefined,\n                        done: true\n                      });\n                    case 8:\n                      requestCapability = new _util.PromiseCapability();\n                      this._requests.push(requestCapability);\n                      return _context17.abrupt(\"return\", requestCapability.promise);\n                    case 11:\n                    case \"end\":\n                      return _context17.stop();\n                  }\n                }, _callee17, this);\n              }));\n              function read() {\n                return _read6.apply(this, arguments);\n              }\n              return read;\n            }()\n          }, {\n            key: \"cancel\",\n            value: function cancel(reason) {\n              this._done = true;\n              var _iterator79 = _createForOfIteratorHelper(this._requests),\n                _step79;\n              try {\n                for (_iterator79.s(); !(_step79 = _iterator79.n()).done;) {\n                  var requestCapability = _step79.value;\n                  requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                  });\n                }\n              } catch (err) {\n                _iterator79.e(err);\n              } finally {\n                _iterator79.f();\n              }\n              this._requests.length = 0;\n              if (this._manager.isPendingRequest(this._requestId)) {\n                this._manager.abortRequest(this._requestId);\n              }\n              this._close();\n            }\n          }]);\n          return PDFNetworkStreamRangeRequestReader;\n        }();\n        /***/\n      }, /* 25 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.PDFFetchStream = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _network_utils = __w_pdfjs_require__(22);\n        ;\n        function createFetchOptions(headers, withCredentials, abortController) {\n          return {\n            method: \"GET\",\n            headers: headers,\n            signal: abortController.signal,\n            mode: \"cors\",\n            credentials: withCredentials ? \"include\" : \"same-origin\",\n            redirect: \"follow\"\n          };\n        }\n        function createHeaders(httpHeaders) {\n          var headers = new Headers();\n          for (var property in httpHeaders) {\n            var value = httpHeaders[property];\n            if (value === undefined) {\n              continue;\n            }\n            headers.append(property, value);\n          }\n          return headers;\n        }\n        function getArrayBuffer(val) {\n          if (val instanceof Uint8Array) {\n            return val.buffer;\n          }\n          if (val instanceof ArrayBuffer) {\n            return val;\n          }\n          (0, _util.warn)(\"getArrayBuffer - unexpected data format: \".concat(val));\n          return new Uint8Array(val).buffer;\n        }\n        var PDFFetchStream = /*#__PURE__*/function () {\n          function PDFFetchStream(source) {\n            _classCallCheck(this, PDFFetchStream);\n            this.source = source;\n            this.isHttp = /^https?:/i.test(source.url);\n            this.httpHeaders = this.isHttp && source.httpHeaders || {};\n            this._fullRequestReader = null;\n            this._rangeRequestReaders = [];\n          }\n          _createClass(PDFFetchStream, [{\n            key: \"_progressiveDataLength\",\n            get: function get() {\n              var _this$_fullRequestRea11, _this$_fullRequestRea12;\n              return (_this$_fullRequestRea11 = (_this$_fullRequestRea12 = this._fullRequestReader) === null || _this$_fullRequestRea12 === void 0 ? void 0 : _this$_fullRequestRea12._loaded) !== null && _this$_fullRequestRea11 !== void 0 ? _this$_fullRequestRea11 : 0;\n            }\n          }, {\n            key: \"getFullReader\",\n            value: function getFullReader() {\n              (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n              this._fullRequestReader = new PDFFetchStreamReader(this);\n              return this._fullRequestReader;\n            }\n          }, {\n            key: \"getRangeReader\",\n            value: function getRangeReader(begin, end) {\n              if (end <= this._progressiveDataLength) {\n                return null;\n              }\n              var reader = new PDFFetchStreamRangeReader(this, begin, end);\n              this._rangeRequestReaders.push(reader);\n              return reader;\n            }\n          }, {\n            key: \"cancelAllRequests\",\n            value: function cancelAllRequests(reason) {\n              var _this$_fullRequestRea13;\n              (_this$_fullRequestRea13 = this._fullRequestReader) === null || _this$_fullRequestRea13 === void 0 ? void 0 : _this$_fullRequestRea13.cancel(reason);\n              var _iterator80 = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),\n                _step80;\n              try {\n                for (_iterator80.s(); !(_step80 = _iterator80.n()).done;) {\n                  var reader = _step80.value;\n                  reader.cancel(reason);\n                }\n              } catch (err) {\n                _iterator80.e(err);\n              } finally {\n                _iterator80.f();\n              }\n            }\n          }]);\n          return PDFFetchStream;\n        }();\n        exports.PDFFetchStream = PDFFetchStream;\n        var PDFFetchStreamReader = /*#__PURE__*/function () {\n          function PDFFetchStreamReader(stream) {\n            var _this43 = this;\n            _classCallCheck(this, PDFFetchStreamReader);\n            this._stream = stream;\n            this._reader = null;\n            this._loaded = 0;\n            this._filename = null;\n            var source = stream.source;\n            this._withCredentials = source.withCredentials || false;\n            this._contentLength = source.length;\n            this._headersCapability = new _util.PromiseCapability();\n            this._disableRange = source.disableRange || false;\n            this._rangeChunkSize = source.rangeChunkSize;\n            if (!this._rangeChunkSize && !this._disableRange) {\n              this._disableRange = true;\n            }\n            this._abortController = new AbortController();\n            this._isStreamingSupported = !source.disableStream;\n            this._isRangeSupported = !source.disableRange;\n            this._headers = createHeaders(this._stream.httpHeaders);\n            var url = source.url;\n            fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {\n              if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n                throw (0, _network_utils.createResponseStatusError)(response.status, url);\n              }\n              _this43._reader = response.body.getReader();\n              _this43._headersCapability.resolve();\n              var getResponseHeader = function getResponseHeader(name) {\n                return response.headers.get(name);\n              };\n              var _ref58 = (0, _network_utils.validateRangeRequestCapabilities)({\n                  getResponseHeader: getResponseHeader,\n                  isHttp: _this43._stream.isHttp,\n                  rangeChunkSize: _this43._rangeChunkSize,\n                  disableRange: _this43._disableRange\n                }),\n                allowRangeRequests = _ref58.allowRangeRequests,\n                suggestedLength = _ref58.suggestedLength;\n              _this43._isRangeSupported = allowRangeRequests;\n              _this43._contentLength = suggestedLength || _this43._contentLength;\n              _this43._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n              if (!_this43._isStreamingSupported && _this43._isRangeSupported) {\n                _this43.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n              }\n            }).catch(this._headersCapability.reject);\n            this.onProgress = null;\n          }\n          _createClass(PDFFetchStreamReader, [{\n            key: \"headersReady\",\n            get: function get() {\n              return this._headersCapability.promise;\n            }\n          }, {\n            key: \"filename\",\n            get: function get() {\n              return this._filename;\n            }\n          }, {\n            key: \"contentLength\",\n            get: function get() {\n              return this._contentLength;\n            }\n          }, {\n            key: \"isRangeSupported\",\n            get: function get() {\n              return this._isRangeSupported;\n            }\n          }, {\n            key: \"isStreamingSupported\",\n            get: function get() {\n              return this._isStreamingSupported;\n            }\n          }, {\n            key: \"read\",\n            value: function () {\n              var _read7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n                var _this$onProgress5;\n                var _yield$this$_reader$r, value, done;\n                return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n                  while (1) switch (_context18.prev = _context18.next) {\n                    case 0:\n                      _context18.next = 2;\n                      return this._headersCapability.promise;\n                    case 2:\n                      _context18.next = 4;\n                      return this._reader.read();\n                    case 4:\n                      _yield$this$_reader$r = _context18.sent;\n                      value = _yield$this$_reader$r.value;\n                      done = _yield$this$_reader$r.done;\n                      if (!done) {\n                        _context18.next = 9;\n                        break;\n                      }\n                      return _context18.abrupt(\"return\", {\n                        value: value,\n                        done: done\n                      });\n                    case 9:\n                      this._loaded += value.byteLength;\n                      (_this$onProgress5 = this.onProgress) === null || _this$onProgress5 === void 0 ? void 0 : _this$onProgress5.call(this, {\n                        loaded: this._loaded,\n                        total: this._contentLength\n                      });\n                      return _context18.abrupt(\"return\", {\n                        value: getArrayBuffer(value),\n                        done: false\n                      });\n                    case 12:\n                    case \"end\":\n                      return _context18.stop();\n                  }\n                }, _callee18, this);\n              }));\n              function read() {\n                return _read7.apply(this, arguments);\n              }\n              return read;\n            }()\n          }, {\n            key: \"cancel\",\n            value: function cancel(reason) {\n              var _this$_reader;\n              (_this$_reader = this._reader) === null || _this$_reader === void 0 ? void 0 : _this$_reader.cancel(reason);\n              this._abortController.abort();\n            }\n          }]);\n          return PDFFetchStreamReader;\n        }();\n        var PDFFetchStreamRangeReader = /*#__PURE__*/function () {\n          function PDFFetchStreamRangeReader(stream, begin, end) {\n            var _this44 = this;\n            _classCallCheck(this, PDFFetchStreamRangeReader);\n            this._stream = stream;\n            this._reader = null;\n            this._loaded = 0;\n            var source = stream.source;\n            this._withCredentials = source.withCredentials || false;\n            this._readCapability = new _util.PromiseCapability();\n            this._isStreamingSupported = !source.disableStream;\n            this._abortController = new AbortController();\n            this._headers = createHeaders(this._stream.httpHeaders);\n            this._headers.append(\"Range\", \"bytes=\".concat(begin, \"-\").concat(end - 1));\n            var url = source.url;\n            fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {\n              if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n                throw (0, _network_utils.createResponseStatusError)(response.status, url);\n              }\n              _this44._readCapability.resolve();\n              _this44._reader = response.body.getReader();\n            }).catch(this._readCapability.reject);\n            this.onProgress = null;\n          }\n          _createClass(PDFFetchStreamRangeReader, [{\n            key: \"isStreamingSupported\",\n            get: function get() {\n              return this._isStreamingSupported;\n            }\n          }, {\n            key: \"read\",\n            value: function () {\n              var _read8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n                var _this$onProgress6;\n                var _yield$this$_reader$r2, value, done;\n                return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n                  while (1) switch (_context19.prev = _context19.next) {\n                    case 0:\n                      _context19.next = 2;\n                      return this._readCapability.promise;\n                    case 2:\n                      _context19.next = 4;\n                      return this._reader.read();\n                    case 4:\n                      _yield$this$_reader$r2 = _context19.sent;\n                      value = _yield$this$_reader$r2.value;\n                      done = _yield$this$_reader$r2.done;\n                      if (!done) {\n                        _context19.next = 9;\n                        break;\n                      }\n                      return _context19.abrupt(\"return\", {\n                        value: value,\n                        done: done\n                      });\n                    case 9:\n                      this._loaded += value.byteLength;\n                      (_this$onProgress6 = this.onProgress) === null || _this$onProgress6 === void 0 ? void 0 : _this$onProgress6.call(this, {\n                        loaded: this._loaded\n                      });\n                      return _context19.abrupt(\"return\", {\n                        value: getArrayBuffer(value),\n                        done: false\n                      });\n                    case 12:\n                    case \"end\":\n                      return _context19.stop();\n                  }\n                }, _callee19, this);\n              }));\n              function read() {\n                return _read8.apply(this, arguments);\n              }\n              return read;\n            }()\n          }, {\n            key: \"cancel\",\n            value: function cancel(reason) {\n              var _this$_reader2;\n              (_this$_reader2 = this._reader) === null || _this$_reader2 === void 0 ? void 0 : _this$_reader2.cancel(reason);\n              this._abortController.abort();\n            }\n          }]);\n          return PDFFetchStreamRangeReader;\n        }();\n        /***/\n      }, /* 26 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.TextLayerRenderTask = void 0;\n        exports.renderTextLayer = renderTextLayer;\n        exports.updateTextLayer = updateTextLayer;\n        var _util = __w_pdfjs_require__(1);\n        var _display_utils = __w_pdfjs_require__(6);\n        var MAX_TEXT_DIVS_TO_RENDER = 100000;\n        var DEFAULT_FONT_SIZE = 30;\n        var DEFAULT_FONT_ASCENT = 0.8;\n        var ascentCache = new Map();\n        function getCtx(size, isOffscreenCanvasSupported) {\n          var ctx;\n          if (isOffscreenCanvasSupported && _util.FeatureTest.isOffscreenCanvasSupported) {\n            ctx = new OffscreenCanvas(size, size).getContext(\"2d\", {\n              alpha: false\n            });\n          } else {\n            var canvas = document.createElement(\"canvas\");\n            canvas.width = canvas.height = size;\n            ctx = canvas.getContext(\"2d\", {\n              alpha: false\n            });\n          }\n          return ctx;\n        }\n        function getAscent(fontFamily, isOffscreenCanvasSupported) {\n          var cachedAscent = ascentCache.get(fontFamily);\n          if (cachedAscent) {\n            return cachedAscent;\n          }\n          var ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);\n          ctx.font = \"\".concat(DEFAULT_FONT_SIZE, \"px \").concat(fontFamily);\n          var metrics = ctx.measureText(\"\");\n          var ascent = metrics.fontBoundingBoxAscent;\n          var descent = Math.abs(metrics.fontBoundingBoxDescent);\n          if (ascent) {\n            var ratio = ascent / (ascent + descent);\n            ascentCache.set(fontFamily, ratio);\n            ctx.canvas.width = ctx.canvas.height = 0;\n            return ratio;\n          }\n          ctx.strokeStyle = \"red\";\n          ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n          ctx.strokeText(\"g\", 0, 0);\n          var pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n          descent = 0;\n          for (var i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n            if (pixels[i] > 0) {\n              descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n              break;\n            }\n          }\n          ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n          ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n          pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n          ascent = 0;\n          for (var _i11 = 0, ii = pixels.length; _i11 < ii; _i11 += 4) {\n            if (pixels[_i11] > 0) {\n              ascent = DEFAULT_FONT_SIZE - Math.floor(_i11 / 4 / DEFAULT_FONT_SIZE);\n              break;\n            }\n          }\n          ctx.canvas.width = ctx.canvas.height = 0;\n          if (ascent) {\n            var _ratio = ascent / (ascent + descent);\n            ascentCache.set(fontFamily, _ratio);\n            return _ratio;\n          }\n          ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n          return DEFAULT_FONT_ASCENT;\n        }\n        function appendText(task, geom, styles) {\n          var textDiv = document.createElement(\"span\");\n          var textDivProperties = {\n            angle: 0,\n            canvasWidth: 0,\n            hasText: geom.str !== \"\",\n            hasEOL: geom.hasEOL,\n            fontSize: 0\n          };\n          task._textDivs.push(textDiv);\n          var tx = _util.Util.transform(task._transform, geom.transform);\n          var angle = Math.atan2(tx[1], tx[0]);\n          var style = styles[geom.fontName];\n          if (style.vertical) {\n            angle += Math.PI / 2;\n          }\n          var fontHeight = Math.hypot(tx[2], tx[3]);\n          var fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);\n          var left, top;\n          if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n          } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n          }\n          var scaleFactorStr = \"calc(var(--scale-factor)*\";\n          var divStyle = textDiv.style;\n          if (task._container === task._rootContainer) {\n            divStyle.left = \"\".concat((100 * left / task._pageWidth).toFixed(2), \"%\");\n            divStyle.top = \"\".concat((100 * top / task._pageHeight).toFixed(2), \"%\");\n          } else {\n            divStyle.left = \"\".concat(scaleFactorStr).concat(left.toFixed(2), \"px)\");\n            divStyle.top = \"\".concat(scaleFactorStr).concat(top.toFixed(2), \"px)\");\n          }\n          divStyle.fontSize = \"\".concat(scaleFactorStr).concat(fontHeight.toFixed(2), \"px)\");\n          divStyle.fontFamily = style.fontFamily;\n          textDivProperties.fontSize = fontHeight;\n          textDiv.setAttribute(\"role\", \"presentation\");\n          textDiv.textContent = geom.str;\n          textDiv.dir = geom.dir;\n          if (task._fontInspectorEnabled) {\n            textDiv.dataset.fontName = geom.fontName;\n          }\n          if (angle !== 0) {\n            textDivProperties.angle = angle * (180 / Math.PI);\n          }\n          var shouldScaleText = false;\n          if (geom.str.length > 1) {\n            shouldScaleText = true;\n          } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n            var absScaleX = Math.abs(geom.transform[0]),\n              absScaleY = Math.abs(geom.transform[3]);\n            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n              shouldScaleText = true;\n            }\n          }\n          if (shouldScaleText) {\n            textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n          }\n          task._textDivProperties.set(textDiv, textDivProperties);\n          if (task._isReadableStream) {\n            task._layoutText(textDiv);\n          }\n        }\n        function layout(params) {\n          var div = params.div,\n            scale = params.scale,\n            properties = params.properties,\n            ctx = params.ctx,\n            prevFontSize = params.prevFontSize,\n            prevFontFamily = params.prevFontFamily;\n          var style = div.style;\n          var transform = \"\";\n          if (properties.canvasWidth !== 0 && properties.hasText) {\n            var fontFamily = style.fontFamily;\n            var canvasWidth = properties.canvasWidth,\n              fontSize = properties.fontSize;\n            if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {\n              ctx.font = \"\".concat(fontSize * scale, \"px \").concat(fontFamily);\n              params.prevFontSize = fontSize;\n              params.prevFontFamily = fontFamily;\n            }\n            var _ctx$measureText = ctx.measureText(div.textContent),\n              width = _ctx$measureText.width;\n            if (width > 0) {\n              transform = \"scaleX(\".concat(canvasWidth * scale / width, \")\");\n            }\n          }\n          if (properties.angle !== 0) {\n            transform = \"rotate(\".concat(properties.angle, \"deg) \").concat(transform);\n          }\n          if (transform.length > 0) {\n            style.transform = transform;\n          }\n        }\n        function render(task) {\n          if (task._canceled) {\n            return;\n          }\n          var textDivs = task._textDivs;\n          var capability = task._capability;\n          var textDivsLength = textDivs.length;\n          if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n            capability.resolve();\n            return;\n          }\n          if (!task._isReadableStream) {\n            var _iterator81 = _createForOfIteratorHelper(textDivs),\n              _step81;\n            try {\n              for (_iterator81.s(); !(_step81 = _iterator81.n()).done;) {\n                var textDiv = _step81.value;\n                task._layoutText(textDiv);\n              }\n            } catch (err) {\n              _iterator81.e(err);\n            } finally {\n              _iterator81.f();\n            }\n          }\n          capability.resolve();\n        }\n        var TextLayerRenderTask = /*#__PURE__*/function () {\n          function TextLayerRenderTask(_ref59) {\n            var _globalThis$FontInspe2,\n              _this45 = this;\n            var textContentSource = _ref59.textContentSource,\n              container = _ref59.container,\n              viewport = _ref59.viewport,\n              textDivs = _ref59.textDivs,\n              textDivProperties = _ref59.textDivProperties,\n              textContentItemsStr = _ref59.textContentItemsStr,\n              isOffscreenCanvasSupported = _ref59.isOffscreenCanvasSupported;\n            _classCallCheck(this, TextLayerRenderTask);\n            this._textContentSource = textContentSource;\n            this._isReadableStream = textContentSource instanceof ReadableStream;\n            this._container = this._rootContainer = container;\n            this._textDivs = textDivs || [];\n            this._textContentItemsStr = textContentItemsStr || [];\n            this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;\n            this._fontInspectorEnabled = !!((_globalThis$FontInspe2 = globalThis.FontInspector) !== null && _globalThis$FontInspe2 !== void 0 && _globalThis$FontInspe2.enabled);\n            this._reader = null;\n            this._textDivProperties = textDivProperties || new WeakMap();\n            this._canceled = false;\n            this._capability = new _util.PromiseCapability();\n            this._layoutTextParams = {\n              prevFontSize: null,\n              prevFontFamily: null,\n              div: null,\n              scale: viewport.scale * (globalThis.devicePixelRatio || 1),\n              properties: null,\n              ctx: getCtx(0, isOffscreenCanvasSupported)\n            };\n            var _viewport$rawDims2 = viewport.rawDims,\n              pageWidth = _viewport$rawDims2.pageWidth,\n              pageHeight = _viewport$rawDims2.pageHeight,\n              pageX = _viewport$rawDims2.pageX,\n              pageY = _viewport$rawDims2.pageY;\n            this._transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];\n            this._pageWidth = pageWidth;\n            this._pageHeight = pageHeight;\n            (0, _display_utils.setLayerDimensions)(container, viewport);\n            this._capability.promise.finally(function () {\n              _this45._layoutTextParams = null;\n            }).catch(function () {});\n          }\n          _createClass(TextLayerRenderTask, [{\n            key: \"promise\",\n            get: function get() {\n              return this._capability.promise;\n            }\n          }, {\n            key: \"cancel\",\n            value: function cancel() {\n              this._canceled = true;\n              if (this._reader) {\n                this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(function () {});\n                this._reader = null;\n              }\n              this._capability.reject(new _util.AbortException(\"TextLayer task cancelled.\"));\n            }\n          }, {\n            key: \"_processItems\",\n            value: function _processItems(items, styleCache) {\n              var _iterator82 = _createForOfIteratorHelper(items),\n                _step82;\n              try {\n                for (_iterator82.s(); !(_step82 = _iterator82.n()).done;) {\n                  var item = _step82.value;\n                  if (item.str === undefined) {\n                    if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                      var parent = this._container;\n                      this._container = document.createElement(\"span\");\n                      this._container.classList.add(\"markedContent\");\n                      if (item.id !== null) {\n                        this._container.setAttribute(\"id\", \"\".concat(item.id));\n                      }\n                      parent.append(this._container);\n                    } else if (item.type === \"endMarkedContent\") {\n                      this._container = this._container.parentNode;\n                    }\n                    continue;\n                  }\n                  this._textContentItemsStr.push(item.str);\n                  appendText(this, item, styleCache);\n                }\n              } catch (err) {\n                _iterator82.e(err);\n              } finally {\n                _iterator82.f();\n              }\n            }\n          }, {\n            key: \"_layoutText\",\n            value: function _layoutText(textDiv) {\n              var textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);\n              this._layoutTextParams.div = textDiv;\n              layout(this._layoutTextParams);\n              if (textDivProperties.hasText) {\n                this._container.append(textDiv);\n              }\n              if (textDivProperties.hasEOL) {\n                var br = document.createElement(\"br\");\n                br.setAttribute(\"role\", \"presentation\");\n                this._container.append(br);\n              }\n            }\n          }, {\n            key: \"_render\",\n            value: function _render() {\n              var _this46 = this;\n              var capability = new _util.PromiseCapability();\n              var styleCache = Object.create(null);\n              if (this._isReadableStream) {\n                var pump = function pump() {\n                  _this46._reader.read().then(function (_ref60) {\n                    var value = _ref60.value,\n                      done = _ref60.done;\n                    if (done) {\n                      capability.resolve();\n                      return;\n                    }\n                    Object.assign(styleCache, value.styles);\n                    _this46._processItems(value.items, styleCache);\n                    pump();\n                  }, capability.reject);\n                };\n                this._reader = this._textContentSource.getReader();\n                pump();\n              } else if (this._textContentSource) {\n                var _this$_textContentSou = this._textContentSource,\n                  items = _this$_textContentSou.items,\n                  styles = _this$_textContentSou.styles;\n                this._processItems(items, styles);\n                capability.resolve();\n              } else {\n                throw new Error('No \"textContentSource\" parameter specified.');\n              }\n              capability.promise.then(function () {\n                styleCache = null;\n                render(_this46);\n              }, this._capability.reject);\n            }\n          }]);\n          return TextLayerRenderTask;\n        }();\n        exports.TextLayerRenderTask = TextLayerRenderTask;\n        function renderTextLayer(params) {\n          if (!params.textContentSource && (params.textContent || params.textContentStream)) {\n            (0, _display_utils.deprecated)(\"The TextLayerRender `textContent`/`textContentStream` parameters \" + \"will be removed in the future, please use `textContentSource` instead.\");\n            params.textContentSource = params.textContent || params.textContentStream;\n          }\n          var container = params.container,\n            viewport = params.viewport;\n          var style = getComputedStyle(container);\n          var visibility = style.getPropertyValue(\"visibility\");\n          var scaleFactor = parseFloat(style.getPropertyValue(\"--scale-factor\"));\n          if (visibility === \"visible\" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {\n            console.error(\"The `--scale-factor` CSS-variable must be set, \" + \"to the same value as `viewport.scale`, \" + \"either on the `container`-element itself or higher up in the DOM.\");\n          }\n          var task = new TextLayerRenderTask(params);\n          task._render();\n          return task;\n        }\n        function updateTextLayer(_ref61) {\n          var container = _ref61.container,\n            viewport = _ref61.viewport,\n            textDivs = _ref61.textDivs,\n            textDivProperties = _ref61.textDivProperties,\n            isOffscreenCanvasSupported = _ref61.isOffscreenCanvasSupported,\n            _ref61$mustRotate = _ref61.mustRotate,\n            mustRotate = _ref61$mustRotate === void 0 ? true : _ref61$mustRotate,\n            _ref61$mustRescale = _ref61.mustRescale,\n            mustRescale = _ref61$mustRescale === void 0 ? true : _ref61$mustRescale;\n          if (mustRotate) {\n            (0, _display_utils.setLayerDimensions)(container, {\n              rotation: viewport.rotation\n            });\n          }\n          if (mustRescale) {\n            var ctx = getCtx(0, isOffscreenCanvasSupported);\n            var scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n            var params = {\n              prevFontSize: null,\n              prevFontFamily: null,\n              div: null,\n              scale: scale,\n              properties: null,\n              ctx: ctx\n            };\n            var _iterator83 = _createForOfIteratorHelper(textDivs),\n              _step83;\n            try {\n              for (_iterator83.s(); !(_step83 = _iterator83.n()).done;) {\n                var div = _step83.value;\n                params.properties = textDivProperties.get(div);\n                params.div = div;\n                layout(params);\n              }\n            } catch (err) {\n              _iterator83.e(err);\n            } finally {\n              _iterator83.f();\n            }\n          }\n        }\n\n        /***/\n      }, /* 27 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.AnnotationEditorLayer = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _tools = __w_pdfjs_require__(5);\n        var _freetext = __w_pdfjs_require__(28);\n        var _ink = __w_pdfjs_require__(29);\n        var _display_utils = __w_pdfjs_require__(6);\n        var _accessibilityManager = /*#__PURE__*/new WeakMap();\n        var _allowClick = /*#__PURE__*/new WeakMap();\n        var _boundPointerup = /*#__PURE__*/new WeakMap();\n        var _boundPointerdown = /*#__PURE__*/new WeakMap();\n        var _editors = /*#__PURE__*/new WeakMap();\n        var _hadPointerDown = /*#__PURE__*/new WeakMap();\n        var _isCleaningUp = /*#__PURE__*/new WeakMap();\n        var _uiManager = /*#__PURE__*/new WeakMap();\n        var _changeParent = /*#__PURE__*/new WeakSet();\n        var _createNewEditor = /*#__PURE__*/new WeakSet();\n        var _createAndAddNewEditor = /*#__PURE__*/new WeakSet();\n        var _cleanup = /*#__PURE__*/new WeakSet();\n        var AnnotationEditorLayer = /*#__PURE__*/function () {\n          function AnnotationEditorLayer(options) {\n            _classCallCheck(this, AnnotationEditorLayer);\n            _classPrivateMethodInitSpec(this, _cleanup);\n            _classPrivateMethodInitSpec(this, _createAndAddNewEditor);\n            _classPrivateMethodInitSpec(this, _createNewEditor);\n            _classPrivateMethodInitSpec(this, _changeParent);\n            _classPrivateFieldInitSpec(this, _accessibilityManager, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(this, _allowClick, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(this, _boundPointerup, {\n              writable: true,\n              value: this.pointerup.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _boundPointerdown, {\n              writable: true,\n              value: this.pointerdown.bind(this)\n            });\n            _classPrivateFieldInitSpec(this, _editors, {\n              writable: true,\n              value: new Map()\n            });\n            _classPrivateFieldInitSpec(this, _hadPointerDown, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(this, _isCleaningUp, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(this, _uiManager, {\n              writable: true,\n              value: void 0\n            });\n            if (!AnnotationEditorLayer._initialized) {\n              AnnotationEditorLayer._initialized = true;\n              _freetext.FreeTextEditor.initialize(options.l10n);\n              _ink.InkEditor.initialize(options.l10n);\n            }\n            options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);\n            _classPrivateFieldSet(this, _uiManager, options.uiManager);\n            this.pageIndex = options.pageIndex;\n            this.div = options.div;\n            _classPrivateFieldSet(this, _accessibilityManager, options.accessibilityManager);\n            _classPrivateFieldGet(this, _uiManager).addLayer(this);\n          }\n          _createClass(AnnotationEditorLayer, [{\n            key: \"isEmpty\",\n            get: function get() {\n              return _classPrivateFieldGet(this, _editors).size === 0;\n            }\n          }, {\n            key: \"updateToolbar\",\n            value: function updateToolbar(mode) {\n              _classPrivateFieldGet(this, _uiManager).updateToolbar(mode);\n            }\n          }, {\n            key: \"updateMode\",\n            value: function updateMode() {\n              var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _classPrivateFieldGet(this, _uiManager).getMode();\n              _classPrivateMethodGet(this, _cleanup, _cleanup2).call(this);\n              if (mode === _util.AnnotationEditorType.INK) {\n                this.addInkEditorIfNeeded(false);\n                this.disableClick();\n              } else {\n                this.enableClick();\n              }\n              _classPrivateFieldGet(this, _uiManager).unselectAll();\n              if (mode !== _util.AnnotationEditorType.NONE) {\n                this.div.classList.toggle(\"freeTextEditing\", mode === _util.AnnotationEditorType.FREETEXT);\n                this.div.classList.toggle(\"inkEditing\", mode === _util.AnnotationEditorType.INK);\n                this.div.hidden = false;\n              }\n            }\n          }, {\n            key: \"addInkEditorIfNeeded\",\n            value: function addInkEditorIfNeeded(isCommitting) {\n              if (!isCommitting && _classPrivateFieldGet(this, _uiManager).getMode() !== _util.AnnotationEditorType.INK) {\n                return;\n              }\n              if (!isCommitting) {\n                var _iterator84 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _editors).values()),\n                  _step84;\n                try {\n                  for (_iterator84.s(); !(_step84 = _iterator84.n()).done;) {\n                    var _editor2 = _step84.value;\n                    if (_editor2.isEmpty()) {\n                      _editor2.setInBackground();\n                      return;\n                    }\n                  }\n                } catch (err) {\n                  _iterator84.e(err);\n                } finally {\n                  _iterator84.f();\n                }\n              }\n              var editor = _classPrivateMethodGet(this, _createAndAddNewEditor, _createAndAddNewEditor2).call(this, {\n                offsetX: 0,\n                offsetY: 0\n              });\n              editor.setInBackground();\n            }\n          }, {\n            key: \"setEditingState\",\n            value: function setEditingState(isEditing) {\n              _classPrivateFieldGet(this, _uiManager).setEditingState(isEditing);\n            }\n          }, {\n            key: \"addCommands\",\n            value: function addCommands(params) {\n              _classPrivateFieldGet(this, _uiManager).addCommands(params);\n            }\n          }, {\n            key: \"enable\",\n            value: function enable() {\n              this.div.style.pointerEvents = \"auto\";\n              var _iterator85 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _editors).values()),\n                _step85;\n              try {\n                for (_iterator85.s(); !(_step85 = _iterator85.n()).done;) {\n                  var editor = _step85.value;\n                  editor.enableEditing();\n                }\n              } catch (err) {\n                _iterator85.e(err);\n              } finally {\n                _iterator85.f();\n              }\n            }\n          }, {\n            key: \"disable\",\n            value: function disable() {\n              this.div.style.pointerEvents = \"none\";\n              var _iterator86 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _editors).values()),\n                _step86;\n              try {\n                for (_iterator86.s(); !(_step86 = _iterator86.n()).done;) {\n                  var editor = _step86.value;\n                  editor.disableEditing();\n                }\n              } catch (err) {\n                _iterator86.e(err);\n              } finally {\n                _iterator86.f();\n              }\n              _classPrivateMethodGet(this, _cleanup, _cleanup2).call(this);\n              if (this.isEmpty) {\n                this.div.hidden = true;\n              }\n            }\n          }, {\n            key: \"setActiveEditor\",\n            value: function setActiveEditor(editor) {\n              var currentActive = _classPrivateFieldGet(this, _uiManager).getActive();\n              if (currentActive === editor) {\n                return;\n              }\n              _classPrivateFieldGet(this, _uiManager).setActiveEditor(editor);\n            }\n          }, {\n            key: \"enableClick\",\n            value: function enableClick() {\n              this.div.addEventListener(\"pointerdown\", _classPrivateFieldGet(this, _boundPointerdown));\n              this.div.addEventListener(\"pointerup\", _classPrivateFieldGet(this, _boundPointerup));\n            }\n          }, {\n            key: \"disableClick\",\n            value: function disableClick() {\n              this.div.removeEventListener(\"pointerdown\", _classPrivateFieldGet(this, _boundPointerdown));\n              this.div.removeEventListener(\"pointerup\", _classPrivateFieldGet(this, _boundPointerup));\n            }\n          }, {\n            key: \"attach\",\n            value: function attach(editor) {\n              _classPrivateFieldGet(this, _editors).set(editor.id, editor);\n            }\n          }, {\n            key: \"detach\",\n            value: function detach(editor) {\n              var _classPrivateFieldGet7;\n              _classPrivateFieldGet(this, _editors).delete(editor.id);\n              (_classPrivateFieldGet7 = _classPrivateFieldGet(this, _accessibilityManager)) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.removePointerInTextLayer(editor.contentDiv);\n            }\n          }, {\n            key: \"remove\",\n            value: function remove(editor) {\n              var _this47 = this;\n              _classPrivateFieldGet(this, _uiManager).removeEditor(editor);\n              this.detach(editor);\n              editor.div.style.display = \"none\";\n              setTimeout(function () {\n                editor.div.style.display = \"\";\n                editor.div.remove();\n                editor.isAttachedToDOM = false;\n                if (document.activeElement === document.body) {\n                  _classPrivateFieldGet(_this47, _uiManager).focusMainContainer();\n                }\n              }, 0);\n              if (!_classPrivateFieldGet(this, _isCleaningUp)) {\n                this.addInkEditorIfNeeded(false);\n              }\n            }\n          }, {\n            key: \"add\",\n            value: function add(editor) {\n              _classPrivateMethodGet(this, _changeParent, _changeParent2).call(this, editor);\n              _classPrivateFieldGet(this, _uiManager).addEditor(editor);\n              this.attach(editor);\n              if (!editor.isAttachedToDOM) {\n                var div = editor.render();\n                this.div.append(div);\n                editor.isAttachedToDOM = true;\n              }\n              this.moveEditorInDOM(editor);\n              editor.onceAdded();\n              _classPrivateFieldGet(this, _uiManager).addToAnnotationStorage(editor);\n            }\n          }, {\n            key: \"moveEditorInDOM\",\n            value: function moveEditorInDOM(editor) {\n              var _classPrivateFieldGet8;\n              (_classPrivateFieldGet8 = _classPrivateFieldGet(this, _accessibilityManager)) === null || _classPrivateFieldGet8 === void 0 ? void 0 : _classPrivateFieldGet8.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n            }\n          }, {\n            key: \"addOrRebuild\",\n            value: function addOrRebuild(editor) {\n              if (editor.needsToBeRebuilt()) {\n                editor.rebuild();\n              } else {\n                this.add(editor);\n              }\n            }\n          }, {\n            key: \"addANewEditor\",\n            value: function addANewEditor(editor) {\n              var _this48 = this;\n              var cmd = function cmd() {\n                _this48.addOrRebuild(editor);\n              };\n              var undo = function undo() {\n                editor.remove();\n              };\n              this.addCommands({\n                cmd: cmd,\n                undo: undo,\n                mustExec: true\n              });\n            }\n          }, {\n            key: \"addUndoableEditor\",\n            value: function addUndoableEditor(editor) {\n              var _this49 = this;\n              var cmd = function cmd() {\n                _this49.addOrRebuild(editor);\n              };\n              var undo = function undo() {\n                editor.remove();\n              };\n              this.addCommands({\n                cmd: cmd,\n                undo: undo,\n                mustExec: false\n              });\n            }\n          }, {\n            key: \"getNextId\",\n            value: function getNextId() {\n              return _classPrivateFieldGet(this, _uiManager).getId();\n            }\n          }, {\n            key: \"deserialize\",\n            value: function deserialize(data) {\n              switch (data.annotationType) {\n                case _util.AnnotationEditorType.FREETEXT:\n                  return _freetext.FreeTextEditor.deserialize(data, this, _classPrivateFieldGet(this, _uiManager));\n                case _util.AnnotationEditorType.INK:\n                  return _ink.InkEditor.deserialize(data, this, _classPrivateFieldGet(this, _uiManager));\n              }\n              return null;\n            }\n          }, {\n            key: \"setSelected\",\n            value: function setSelected(editor) {\n              _classPrivateFieldGet(this, _uiManager).setSelected(editor);\n            }\n          }, {\n            key: \"toggleSelected\",\n            value: function toggleSelected(editor) {\n              _classPrivateFieldGet(this, _uiManager).toggleSelected(editor);\n            }\n          }, {\n            key: \"isSelected\",\n            value: function isSelected(editor) {\n              return _classPrivateFieldGet(this, _uiManager).isSelected(editor);\n            }\n          }, {\n            key: \"unselect\",\n            value: function unselect(editor) {\n              _classPrivateFieldGet(this, _uiManager).unselect(editor);\n            }\n          }, {\n            key: \"pointerup\",\n            value: function pointerup(event) {\n              var isMac = _util.FeatureTest.platform.isMac;\n              if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n              }\n              if (event.target !== this.div) {\n                return;\n              }\n              if (!_classPrivateFieldGet(this, _hadPointerDown)) {\n                return;\n              }\n              _classPrivateFieldSet(this, _hadPointerDown, false);\n              if (!_classPrivateFieldGet(this, _allowClick)) {\n                _classPrivateFieldSet(this, _allowClick, true);\n                return;\n              }\n              _classPrivateMethodGet(this, _createAndAddNewEditor, _createAndAddNewEditor2).call(this, event);\n            }\n          }, {\n            key: \"pointerdown\",\n            value: function pointerdown(event) {\n              var isMac = _util.FeatureTest.platform.isMac;\n              if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n              }\n              if (event.target !== this.div) {\n                return;\n              }\n              _classPrivateFieldSet(this, _hadPointerDown, true);\n              var editor = _classPrivateFieldGet(this, _uiManager).getActive();\n              _classPrivateFieldSet(this, _allowClick, !editor || editor.isEmpty());\n            }\n          }, {\n            key: \"drop\",\n            value: function drop(event) {\n              var id = event.dataTransfer.getData(\"text/plain\");\n              var editor = _classPrivateFieldGet(this, _uiManager).getEditor(id);\n              if (!editor) {\n                return;\n              }\n              event.preventDefault();\n              event.dataTransfer.dropEffect = \"move\";\n              _classPrivateMethodGet(this, _changeParent, _changeParent2).call(this, editor);\n              var rect = this.div.getBoundingClientRect();\n              var endX = event.clientX - rect.x;\n              var endY = event.clientY - rect.y;\n              editor.translate(endX - editor.startX, endY - editor.startY);\n              this.moveEditorInDOM(editor);\n              editor.div.focus();\n            }\n          }, {\n            key: \"dragover\",\n            value: function dragover(event) {\n              event.preventDefault();\n            }\n          }, {\n            key: \"destroy\",\n            value: function destroy() {\n              var _classPrivateFieldGet9;\n              if (((_classPrivateFieldGet9 = _classPrivateFieldGet(this, _uiManager).getActive()) === null || _classPrivateFieldGet9 === void 0 ? void 0 : _classPrivateFieldGet9.parent) === this) {\n                _classPrivateFieldGet(this, _uiManager).setActiveEditor(null);\n              }\n              var _iterator87 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _editors).values()),\n                _step87;\n              try {\n                for (_iterator87.s(); !(_step87 = _iterator87.n()).done;) {\n                  var _classPrivateFieldGet10;\n                  var editor = _step87.value;\n                  (_classPrivateFieldGet10 = _classPrivateFieldGet(this, _accessibilityManager)) === null || _classPrivateFieldGet10 === void 0 ? void 0 : _classPrivateFieldGet10.removePointerInTextLayer(editor.contentDiv);\n                  editor.setParent(null);\n                  editor.isAttachedToDOM = false;\n                  editor.div.remove();\n                }\n              } catch (err) {\n                _iterator87.e(err);\n              } finally {\n                _iterator87.f();\n              }\n              this.div = null;\n              _classPrivateFieldGet(this, _editors).clear();\n              _classPrivateFieldGet(this, _uiManager).removeLayer(this);\n            }\n          }, {\n            key: \"render\",\n            value: function render(_ref62) {\n              var viewport = _ref62.viewport;\n              this.viewport = viewport;\n              (0, _display_utils.setLayerDimensions)(this.div, viewport);\n              (0, _tools.bindEvents)(this, this.div, [\"dragover\", \"drop\"]);\n              var _iterator88 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _uiManager).getEditors(this.pageIndex)),\n                _step88;\n              try {\n                for (_iterator88.s(); !(_step88 = _iterator88.n()).done;) {\n                  var editor = _step88.value;\n                  this.add(editor);\n                }\n              } catch (err) {\n                _iterator88.e(err);\n              } finally {\n                _iterator88.f();\n              }\n              this.updateMode();\n            }\n          }, {\n            key: \"update\",\n            value: function update(_ref63) {\n              var viewport = _ref63.viewport;\n              _classPrivateFieldGet(this, _uiManager).commitOrRemove();\n              this.viewport = viewport;\n              (0, _display_utils.setLayerDimensions)(this.div, {\n                rotation: viewport.rotation\n              });\n              this.updateMode();\n            }\n          }, {\n            key: \"pageDimensions\",\n            get: function get() {\n              var _this$viewport$rawDim = this.viewport.rawDims,\n                pageWidth = _this$viewport$rawDim.pageWidth,\n                pageHeight = _this$viewport$rawDim.pageHeight;\n              return [pageWidth, pageHeight];\n            }\n          }]);\n          return AnnotationEditorLayer;\n        }();\n        function _changeParent2(editor) {\n          var _editor$parent;\n          if (editor.parent === this) {\n            return;\n          }\n          this.attach(editor);\n          (_editor$parent = editor.parent) === null || _editor$parent === void 0 ? void 0 : _editor$parent.detach(editor);\n          editor.setParent(this);\n          if (editor.div && editor.isAttachedToDOM) {\n            editor.div.remove();\n            this.div.append(editor.div);\n          }\n        }\n        function _createNewEditor2(params) {\n          switch (_classPrivateFieldGet(this, _uiManager).getMode()) {\n            case _util.AnnotationEditorType.FREETEXT:\n              return new _freetext.FreeTextEditor(params);\n            case _util.AnnotationEditorType.INK:\n              return new _ink.InkEditor(params);\n          }\n          return null;\n        }\n        function _createAndAddNewEditor2(event) {\n          var id = this.getNextId();\n          var editor = _classPrivateMethodGet(this, _createNewEditor, _createNewEditor2).call(this, {\n            parent: this,\n            id: id,\n            x: event.offsetX,\n            y: event.offsetY,\n            uiManager: _classPrivateFieldGet(this, _uiManager)\n          });\n          if (editor) {\n            this.add(editor);\n          }\n          return editor;\n        }\n        function _cleanup2() {\n          _classPrivateFieldSet(this, _isCleaningUp, true);\n          var _iterator89 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _editors).values()),\n            _step89;\n          try {\n            for (_iterator89.s(); !(_step89 = _iterator89.n()).done;) {\n              var editor = _step89.value;\n              if (editor.isEmpty()) {\n                editor.remove();\n              }\n            }\n          } catch (err) {\n            _iterator89.e(err);\n          } finally {\n            _iterator89.f();\n          }\n          _classPrivateFieldSet(this, _isCleaningUp, false);\n        }\n        _defineProperty(AnnotationEditorLayer, \"_initialized\", false);\n        exports.AnnotationEditorLayer = AnnotationEditorLayer;\n\n        /***/\n      }, /* 28 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.FreeTextEditor = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _tools = __w_pdfjs_require__(5);\n        var _editor = __w_pdfjs_require__(4);\n        var _boundEditorDivBlur = /*#__PURE__*/new WeakMap();\n        var _boundEditorDivFocus = /*#__PURE__*/new WeakMap();\n        var _boundEditorDivInput = /*#__PURE__*/new WeakMap();\n        var _boundEditorDivKeydown = /*#__PURE__*/new WeakMap();\n        var _color = /*#__PURE__*/new WeakMap();\n        var _content = /*#__PURE__*/new WeakMap();\n        var _editorDivId = /*#__PURE__*/new WeakMap();\n        var _hasAlreadyBeenCommitted = /*#__PURE__*/new WeakMap();\n        var _fontSize = /*#__PURE__*/new WeakMap();\n        var _updateFontSize = /*#__PURE__*/new WeakSet();\n        var _updateColor = /*#__PURE__*/new WeakSet();\n        var _extractText = /*#__PURE__*/new WeakSet();\n        var _setEditorDimensions = /*#__PURE__*/new WeakSet();\n        var FreeTextEditor = /*#__PURE__*/function (_editor$AnnotationEdi) {\n          _inherits(FreeTextEditor, _editor$AnnotationEdi);\n          var _super26 = _createSuper(FreeTextEditor);\n          function FreeTextEditor(params) {\n            var _this50;\n            _classCallCheck(this, FreeTextEditor);\n            _this50 = _super26.call(this, _objectSpread(_objectSpread({}, params), {}, {\n              name: \"freeTextEditor\"\n            }));\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this50), _setEditorDimensions);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this50), _extractText);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this50), _updateColor);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this50), _updateFontSize);\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this50), _boundEditorDivBlur, {\n              writable: true,\n              value: _this50.editorDivBlur.bind(_assertThisInitialized(_this50))\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this50), _boundEditorDivFocus, {\n              writable: true,\n              value: _this50.editorDivFocus.bind(_assertThisInitialized(_this50))\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this50), _boundEditorDivInput, {\n              writable: true,\n              value: _this50.editorDivInput.bind(_assertThisInitialized(_this50))\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this50), _boundEditorDivKeydown, {\n              writable: true,\n              value: _this50.editorDivKeydown.bind(_assertThisInitialized(_this50))\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this50), _color, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this50), _content, {\n              writable: true,\n              value: \"\"\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this50), _editorDivId, {\n              writable: true,\n              value: \"\".concat(_this50.id, \"-editor\")\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this50), _hasAlreadyBeenCommitted, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this50), _fontSize, {\n              writable: true,\n              value: void 0\n            });\n            _classPrivateFieldSet(_assertThisInitialized(_this50), _color, params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);\n            _classPrivateFieldSet(_assertThisInitialized(_this50), _fontSize, params.fontSize || FreeTextEditor._defaultFontSize);\n            return _this50;\n          }\n          _createClass(FreeTextEditor, [{\n            key: \"updateParams\",\n            value: function updateParams(type, value) {\n              switch (type) {\n                case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n                  _classPrivateMethodGet(this, _updateFontSize, _updateFontSize2).call(this, value);\n                  break;\n                case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n                  _classPrivateMethodGet(this, _updateColor, _updateColor2).call(this, value);\n                  break;\n              }\n            }\n          }, {\n            key: \"propertiesToUpdate\",\n            get: function get() {\n              return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, _classPrivateFieldGet(this, _fontSize)], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, _classPrivateFieldGet(this, _color)]];\n            }\n          }, {\n            key: \"getInitialTranslation\",\n            value: function getInitialTranslation() {\n              var scale = this.parentScale;\n              return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + _classPrivateFieldGet(this, _fontSize)) * scale];\n            }\n          }, {\n            key: \"rebuild\",\n            value: function rebuild() {\n              _get(_getPrototypeOf(FreeTextEditor.prototype), \"rebuild\", this).call(this);\n              if (this.div === null) {\n                return;\n              }\n              if (!this.isAttachedToDOM) {\n                this.parent.add(this);\n              }\n            }\n          }, {\n            key: \"enableEditMode\",\n            value: function enableEditMode() {\n              if (this.isInEditMode()) {\n                return;\n              }\n              this.parent.setEditingState(false);\n              this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);\n              _get(_getPrototypeOf(FreeTextEditor.prototype), \"enableEditMode\", this).call(this);\n              this.overlayDiv.classList.remove(\"enabled\");\n              this.editorDiv.contentEditable = true;\n              this.div.draggable = false;\n              this.div.removeAttribute(\"aria-activedescendant\");\n              this.editorDiv.addEventListener(\"keydown\", _classPrivateFieldGet(this, _boundEditorDivKeydown));\n              this.editorDiv.addEventListener(\"focus\", _classPrivateFieldGet(this, _boundEditorDivFocus));\n              this.editorDiv.addEventListener(\"blur\", _classPrivateFieldGet(this, _boundEditorDivBlur));\n              this.editorDiv.addEventListener(\"input\", _classPrivateFieldGet(this, _boundEditorDivInput));\n            }\n          }, {\n            key: \"disableEditMode\",\n            value: function disableEditMode() {\n              if (!this.isInEditMode()) {\n                return;\n              }\n              this.parent.setEditingState(true);\n              _get(_getPrototypeOf(FreeTextEditor.prototype), \"disableEditMode\", this).call(this);\n              this.overlayDiv.classList.add(\"enabled\");\n              this.editorDiv.contentEditable = false;\n              this.div.setAttribute(\"aria-activedescendant\", _classPrivateFieldGet(this, _editorDivId));\n              this.div.draggable = true;\n              this.editorDiv.removeEventListener(\"keydown\", _classPrivateFieldGet(this, _boundEditorDivKeydown));\n              this.editorDiv.removeEventListener(\"focus\", _classPrivateFieldGet(this, _boundEditorDivFocus));\n              this.editorDiv.removeEventListener(\"blur\", _classPrivateFieldGet(this, _boundEditorDivBlur));\n              this.editorDiv.removeEventListener(\"input\", _classPrivateFieldGet(this, _boundEditorDivInput));\n              this.div.focus({\n                preventScroll: true\n              });\n              this.isEditing = false;\n              this.parent.div.classList.add(\"freeTextEditing\");\n            }\n          }, {\n            key: \"focusin\",\n            value: function focusin(event) {\n              _get(_getPrototypeOf(FreeTextEditor.prototype), \"focusin\", this).call(this, event);\n              if (event.target !== this.editorDiv) {\n                this.editorDiv.focus();\n              }\n            }\n          }, {\n            key: \"onceAdded\",\n            value: function onceAdded() {\n              if (this.width) {\n                return;\n              }\n              this.enableEditMode();\n              this.editorDiv.focus();\n            }\n          }, {\n            key: \"isEmpty\",\n            value: function isEmpty() {\n              return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n            }\n          }, {\n            key: \"remove\",\n            value: function remove() {\n              this.isEditing = false;\n              this.parent.setEditingState(true);\n              this.parent.div.classList.add(\"freeTextEditing\");\n              _get(_getPrototypeOf(FreeTextEditor.prototype), \"remove\", this).call(this);\n            }\n          }, {\n            key: \"commit\",\n            value: function commit() {\n              if (!this.isInEditMode()) {\n                return;\n              }\n              _get(_getPrototypeOf(FreeTextEditor.prototype), \"commit\", this).call(this);\n              if (!_classPrivateFieldGet(this, _hasAlreadyBeenCommitted)) {\n                _classPrivateFieldSet(this, _hasAlreadyBeenCommitted, true);\n                this.parent.addUndoableEditor(this);\n              }\n              this.disableEditMode();\n              _classPrivateFieldSet(this, _content, _classPrivateMethodGet(this, _extractText, _extractText2).call(this).trimEnd());\n              _classPrivateMethodGet(this, _setEditorDimensions, _setEditorDimensions2).call(this);\n            }\n          }, {\n            key: \"shouldGetKeyboardEvents\",\n            value: function shouldGetKeyboardEvents() {\n              return this.isInEditMode();\n            }\n          }, {\n            key: \"dblclick\",\n            value: function dblclick(event) {\n              this.enableEditMode();\n              this.editorDiv.focus();\n            }\n          }, {\n            key: \"keydown\",\n            value: function keydown(event) {\n              if (event.target === this.div && event.key === \"Enter\") {\n                this.enableEditMode();\n                this.editorDiv.focus();\n              }\n            }\n          }, {\n            key: \"editorDivKeydown\",\n            value: function editorDivKeydown(event) {\n              FreeTextEditor._keyboardManager.exec(this, event);\n            }\n          }, {\n            key: \"editorDivFocus\",\n            value: function editorDivFocus(event) {\n              this.isEditing = true;\n            }\n          }, {\n            key: \"editorDivBlur\",\n            value: function editorDivBlur(event) {\n              this.isEditing = false;\n            }\n          }, {\n            key: \"editorDivInput\",\n            value: function editorDivInput(event) {\n              this.parent.div.classList.toggle(\"freeTextEditing\", this.isEmpty());\n            }\n          }, {\n            key: \"disableEditing\",\n            value: function disableEditing() {\n              this.editorDiv.setAttribute(\"role\", \"comment\");\n              this.editorDiv.removeAttribute(\"aria-multiline\");\n            }\n          }, {\n            key: \"enableEditing\",\n            value: function enableEditing() {\n              this.editorDiv.setAttribute(\"role\", \"textbox\");\n              this.editorDiv.setAttribute(\"aria-multiline\", true);\n            }\n          }, {\n            key: \"render\",\n            value: function render() {\n              var _this51 = this;\n              if (this.div) {\n                return this.div;\n              }\n              var baseX, baseY;\n              if (this.width) {\n                baseX = this.x;\n                baseY = this.y;\n              }\n              _get(_getPrototypeOf(FreeTextEditor.prototype), \"render\", this).call(this);\n              this.editorDiv = document.createElement(\"div\");\n              this.editorDiv.className = \"internal\";\n              this.editorDiv.setAttribute(\"id\", _classPrivateFieldGet(this, _editorDivId));\n              this.enableEditing();\n              FreeTextEditor._l10nPromise.get(\"editor_free_text2_aria_label\").then(function (msg) {\n                var _this51$editorDiv;\n                return (_this51$editorDiv = _this51.editorDiv) === null || _this51$editorDiv === void 0 ? void 0 : _this51$editorDiv.setAttribute(\"aria-label\", msg);\n              });\n              FreeTextEditor._l10nPromise.get(\"free_text2_default_content\").then(function (msg) {\n                var _this51$editorDiv2;\n                return (_this51$editorDiv2 = _this51.editorDiv) === null || _this51$editorDiv2 === void 0 ? void 0 : _this51$editorDiv2.setAttribute(\"default-content\", msg);\n              });\n              this.editorDiv.contentEditable = true;\n              var style = this.editorDiv.style;\n              style.fontSize = \"calc(\".concat(_classPrivateFieldGet(this, _fontSize), \"px * var(--scale-factor))\");\n              style.color = _classPrivateFieldGet(this, _color);\n              this.div.append(this.editorDiv);\n              this.overlayDiv = document.createElement(\"div\");\n              this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n              this.div.append(this.overlayDiv);\n              (0, _tools.bindEvents)(this, this.div, [\"dblclick\", \"keydown\"]);\n              if (this.width) {\n                var _this$parentDimension6 = _slicedToArray(this.parentDimensions, 2),\n                  parentWidth = _this$parentDimension6[0],\n                  parentHeight = _this$parentDimension6[1];\n                this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                var _iterator90 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _content).split(\"\\n\")),\n                  _step90;\n                try {\n                  for (_iterator90.s(); !(_step90 = _iterator90.n()).done;) {\n                    var line = _step90.value;\n                    var div = document.createElement(\"div\");\n                    div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n                    this.editorDiv.append(div);\n                  }\n                } catch (err) {\n                  _iterator90.e(err);\n                } finally {\n                  _iterator90.f();\n                }\n                this.div.draggable = true;\n                this.editorDiv.contentEditable = false;\n              } else {\n                this.div.draggable = false;\n                this.editorDiv.contentEditable = true;\n              }\n              return this.div;\n            }\n          }, {\n            key: \"contentDiv\",\n            get: function get() {\n              return this.editorDiv;\n            }\n          }, {\n            key: \"serialize\",\n            value: function serialize() {\n              if (this.isEmpty()) {\n                return null;\n              }\n              var padding = FreeTextEditor._internalPadding * this.parentScale;\n              var rect = this.getRect(padding, padding);\n              var color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : _classPrivateFieldGet(this, _color));\n              return {\n                annotationType: _util.AnnotationEditorType.FREETEXT,\n                color: color,\n                fontSize: _classPrivateFieldGet(this, _fontSize),\n                value: _classPrivateFieldGet(this, _content),\n                pageIndex: this.pageIndex,\n                rect: rect,\n                rotation: this.rotation\n              };\n            }\n          }], [{\n            key: \"initialize\",\n            value: function initialize(l10n) {\n              this._l10nPromise = new Map([\"free_text2_default_content\", \"editor_free_text2_aria_label\"].map(function (str) {\n                return [str, l10n.get(str)];\n              }));\n              var style = getComputedStyle(document.documentElement);\n              this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n            }\n          }, {\n            key: \"updateDefaultParams\",\n            value: function updateDefaultParams(type, value) {\n              switch (type) {\n                case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n                  FreeTextEditor._defaultFontSize = value;\n                  break;\n                case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n                  FreeTextEditor._defaultColor = value;\n                  break;\n              }\n            }\n          }, {\n            key: \"defaultPropertiesToUpdate\",\n            get: function get() {\n              return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];\n            }\n          }, {\n            key: \"deserialize\",\n            value: function deserialize(data, parent, uiManager) {\n              var _util$Util4;\n              var editor = _get(_getPrototypeOf(FreeTextEditor), \"deserialize\", this).call(this, data, parent, uiManager);\n              _classPrivateFieldSet(editor, _fontSize, data.fontSize);\n              _classPrivateFieldSet(editor, _color, (_util$Util4 = _util.Util).makeHexColor.apply(_util$Util4, _toConsumableArray(data.color)));\n              _classPrivateFieldSet(editor, _content, data.value);\n              return editor;\n            }\n          }]);\n          return FreeTextEditor;\n        }(_editor.AnnotationEditor);\n        function _updateFontSize2(fontSize) {\n          var _this52 = this;\n          var setFontsize = function setFontsize(size) {\n            _this52.editorDiv.style.fontSize = \"calc(\".concat(size, \"px * var(--scale-factor))\");\n            _this52.translate(0, -(size - _classPrivateFieldGet(_this52, _fontSize)) * _this52.parentScale);\n            _classPrivateFieldSet(_this52, _fontSize, size);\n            _classPrivateMethodGet(_this52, _setEditorDimensions, _setEditorDimensions2).call(_this52);\n          };\n          var savedFontsize = _classPrivateFieldGet(this, _fontSize);\n          this.addCommands({\n            cmd: function cmd() {\n              setFontsize(fontSize);\n            },\n            undo: function undo() {\n              setFontsize(savedFontsize);\n            },\n            mustExec: true,\n            type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n            overwriteIfSameType: true,\n            keepUndo: true\n          });\n        }\n        function _updateColor2(color) {\n          var _this53 = this;\n          var savedColor = _classPrivateFieldGet(this, _color);\n          this.addCommands({\n            cmd: function cmd() {\n              _classPrivateFieldSet(_this53, _color, _this53.editorDiv.style.color = color);\n            },\n            undo: function undo() {\n              _classPrivateFieldSet(_this53, _color, _this53.editorDiv.style.color = savedColor);\n            },\n            mustExec: true,\n            type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n          });\n        }\n        function _extractText2() {\n          var divs = this.editorDiv.getElementsByTagName(\"div\");\n          if (divs.length === 0) {\n            return this.editorDiv.innerText;\n          }\n          var buffer = [];\n          var _iterator91 = _createForOfIteratorHelper(divs),\n            _step91;\n          try {\n            for (_iterator91.s(); !(_step91 = _iterator91.n()).done;) {\n              var div = _step91.value;\n              buffer.push(div.innerText.replace(/\\r\\n?|\\n/, \"\"));\n            }\n          } catch (err) {\n            _iterator91.e(err);\n          } finally {\n            _iterator91.f();\n          }\n          return buffer.join(\"\\n\");\n        }\n        function _setEditorDimensions2() {\n          var _this$parentDimension7 = _slicedToArray(this.parentDimensions, 2),\n            parentWidth = _this$parentDimension7[0],\n            parentHeight = _this$parentDimension7[1];\n          var rect;\n          if (this.isAttachedToDOM) {\n            rect = this.div.getBoundingClientRect();\n          } else {\n            var currentLayer = this.currentLayer,\n              div = this.div;\n            var savedDisplay = div.style.display;\n            div.style.display = \"hidden\";\n            currentLayer.div.append(this.div);\n            rect = div.getBoundingClientRect();\n            div.remove();\n            div.style.display = savedDisplay;\n          }\n          this.width = rect.width / parentWidth;\n          this.height = rect.height / parentHeight;\n        }\n        _defineProperty(FreeTextEditor, \"_freeTextDefaultContent\", \"\");\n        _defineProperty(FreeTextEditor, \"_l10nPromise\", void 0);\n        _defineProperty(FreeTextEditor, \"_internalPadding\", 0);\n        _defineProperty(FreeTextEditor, \"_defaultColor\", null);\n        _defineProperty(FreeTextEditor, \"_defaultFontSize\", 10);\n        _defineProperty(FreeTextEditor, \"_keyboardManager\", new _tools.KeyboardManager([[[\"ctrl+Enter\", \"mac+meta+Enter\", \"Escape\", \"mac+Escape\"], FreeTextEditor.prototype.commitOrRemove]]));\n        _defineProperty(FreeTextEditor, \"_type\", \"freetext\");\n        exports.FreeTextEditor = FreeTextEditor;\n\n        /***/\n      }, /* 29 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.InkEditor = void 0;\n        Object.defineProperty(exports, \"fitCurve\", {\n          enumerable: true,\n          get: function get() {\n            return _pdfjsFitCurve.fitCurve;\n          }\n        });\n        var _util = __w_pdfjs_require__(1);\n        var _editor = __w_pdfjs_require__(4);\n        var _pdfjsFitCurve = __w_pdfjs_require__(30);\n        var _tools = __w_pdfjs_require__(5);\n        var RESIZER_SIZE = 16;\n        var _aspectRatio = /*#__PURE__*/new WeakMap();\n        var _baseHeight = /*#__PURE__*/new WeakMap();\n        var _baseWidth = /*#__PURE__*/new WeakMap();\n        var _boundCanvasPointermove = /*#__PURE__*/new WeakMap();\n        var _boundCanvasPointerleave = /*#__PURE__*/new WeakMap();\n        var _boundCanvasPointerup = /*#__PURE__*/new WeakMap();\n        var _boundCanvasPointerdown = /*#__PURE__*/new WeakMap();\n        var _disableEditing = /*#__PURE__*/new WeakMap();\n        var _isCanvasInitialized = /*#__PURE__*/new WeakMap();\n        var _lastPoint = /*#__PURE__*/new WeakMap();\n        var _observer = /*#__PURE__*/new WeakMap();\n        var _realWidth = /*#__PURE__*/new WeakMap();\n        var _realHeight = /*#__PURE__*/new WeakMap();\n        var _requestFrameCallback = /*#__PURE__*/new WeakMap();\n        var _updateThickness = /*#__PURE__*/new WeakSet();\n        var _updateColor3 = /*#__PURE__*/new WeakSet();\n        var _updateOpacity = /*#__PURE__*/new WeakSet();\n        var _getInitialBBox = /*#__PURE__*/new WeakSet();\n        var _setStroke = /*#__PURE__*/new WeakSet();\n        var _startDrawing = /*#__PURE__*/new WeakSet();\n        var _draw = /*#__PURE__*/new WeakSet();\n        var _stopDrawing = /*#__PURE__*/new WeakSet();\n        var _redraw = /*#__PURE__*/new WeakSet();\n        var _endDrawing = /*#__PURE__*/new WeakSet();\n        var _createCanvas2 = /*#__PURE__*/new WeakSet();\n        var _createObserver = /*#__PURE__*/new WeakSet();\n        var _setCanvasDims = /*#__PURE__*/new WeakSet();\n        var _setScaleFactor = /*#__PURE__*/new WeakSet();\n        var _updateTransform = /*#__PURE__*/new WeakSet();\n        var _serializePaths = /*#__PURE__*/new WeakSet();\n        var _extractPointsOnBezier = /*#__PURE__*/new WeakSet();\n        var _isAlmostFlat = /*#__PURE__*/new WeakSet();\n        var _getBbox = /*#__PURE__*/new WeakSet();\n        var _getPadding = /*#__PURE__*/new WeakSet();\n        var _fitToContent = /*#__PURE__*/new WeakSet();\n        var _setMinDims = /*#__PURE__*/new WeakSet();\n        var InkEditor = /*#__PURE__*/function (_editor$AnnotationEdi2) {\n          _inherits(InkEditor, _editor$AnnotationEdi2);\n          var _super27 = _createSuper(InkEditor);\n          function InkEditor(params) {\n            var _this54;\n            _classCallCheck(this, InkEditor);\n            _this54 = _super27.call(this, _objectSpread(_objectSpread({}, params), {}, {\n              name: \"inkEditor\"\n            }));\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _setMinDims);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _fitToContent);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _getPadding);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _getBbox);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _isAlmostFlat);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _extractPointsOnBezier);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _serializePaths);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _updateTransform);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _setScaleFactor);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _setCanvasDims);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _createObserver);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _createCanvas2);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _endDrawing);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _redraw);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _stopDrawing);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _draw);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _startDrawing);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _setStroke);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _getInitialBBox);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _updateOpacity);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _updateColor3);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this54), _updateThickness);\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _aspectRatio, {\n              writable: true,\n              value: 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _baseHeight, {\n              writable: true,\n              value: 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _baseWidth, {\n              writable: true,\n              value: 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _boundCanvasPointermove, {\n              writable: true,\n              value: _this54.canvasPointermove.bind(_assertThisInitialized(_this54))\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _boundCanvasPointerleave, {\n              writable: true,\n              value: _this54.canvasPointerleave.bind(_assertThisInitialized(_this54))\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _boundCanvasPointerup, {\n              writable: true,\n              value: _this54.canvasPointerup.bind(_assertThisInitialized(_this54))\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _boundCanvasPointerdown, {\n              writable: true,\n              value: _this54.canvasPointerdown.bind(_assertThisInitialized(_this54))\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _disableEditing, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _isCanvasInitialized, {\n              writable: true,\n              value: false\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _lastPoint, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _observer, {\n              writable: true,\n              value: null\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _realWidth, {\n              writable: true,\n              value: 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _realHeight, {\n              writable: true,\n              value: 0\n            });\n            _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _requestFrameCallback, {\n              writable: true,\n              value: null\n            });\n            _this54.color = params.color || null;\n            _this54.thickness = params.thickness || null;\n            _this54.opacity = params.opacity || null;\n            _this54.paths = [];\n            _this54.bezierPath2D = [];\n            _this54.currentPath = [];\n            _this54.scaleFactor = 1;\n            _this54.translationX = _this54.translationY = 0;\n            _this54.x = 0;\n            _this54.y = 0;\n            return _this54;\n          }\n          _createClass(InkEditor, [{\n            key: \"updateParams\",\n            value: function updateParams(type, value) {\n              switch (type) {\n                case _util.AnnotationEditorParamsType.INK_THICKNESS:\n                  _classPrivateMethodGet(this, _updateThickness, _updateThickness2).call(this, value);\n                  break;\n                case _util.AnnotationEditorParamsType.INK_COLOR:\n                  _classPrivateMethodGet(this, _updateColor3, _updateColor4).call(this, value);\n                  break;\n                case _util.AnnotationEditorParamsType.INK_OPACITY:\n                  _classPrivateMethodGet(this, _updateOpacity, _updateOpacity2).call(this, value);\n                  break;\n              }\n            }\n          }, {\n            key: \"propertiesToUpdate\",\n            get: function get() {\n              var _this$opacity;\n              return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * ((_this$opacity = this.opacity) !== null && _this$opacity !== void 0 ? _this$opacity : InkEditor._defaultOpacity))]];\n            }\n          }, {\n            key: \"rebuild\",\n            value: function rebuild() {\n              _get(_getPrototypeOf(InkEditor.prototype), \"rebuild\", this).call(this);\n              if (this.div === null) {\n                return;\n              }\n              if (!this.canvas) {\n                _classPrivateMethodGet(this, _createCanvas2, _createCanvas3).call(this);\n                _classPrivateMethodGet(this, _createObserver, _createObserver2).call(this);\n              }\n              if (!this.isAttachedToDOM) {\n                this.parent.add(this);\n                _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);\n              }\n              _classPrivateMethodGet(this, _fitToContent, _fitToContent2).call(this);\n            }\n          }, {\n            key: \"remove\",\n            value: function remove() {\n              if (this.canvas === null) {\n                return;\n              }\n              if (!this.isEmpty()) {\n                this.commit();\n              }\n              this.canvas.width = this.canvas.height = 0;\n              this.canvas.remove();\n              this.canvas = null;\n              _classPrivateFieldGet(this, _observer).disconnect();\n              _classPrivateFieldSet(this, _observer, null);\n              _get(_getPrototypeOf(InkEditor.prototype), \"remove\", this).call(this);\n            }\n          }, {\n            key: \"setParent\",\n            value: function setParent(parent) {\n              if (!this.parent && parent) {\n                this._uiManager.removeShouldRescale(this);\n              } else if (this.parent && parent === null) {\n                this._uiManager.addShouldRescale(this);\n              }\n              _get(_getPrototypeOf(InkEditor.prototype), \"setParent\", this).call(this, parent);\n            }\n          }, {\n            key: \"onScaleChanging\",\n            value: function onScaleChanging() {\n              var _this$parentDimension8 = _slicedToArray(this.parentDimensions, 2),\n                parentWidth = _this$parentDimension8[0],\n                parentHeight = _this$parentDimension8[1];\n              var width = this.width * parentWidth;\n              var height = this.height * parentHeight;\n              this.setDimensions(width, height);\n            }\n          }, {\n            key: \"enableEditMode\",\n            value: function enableEditMode() {\n              if (_classPrivateFieldGet(this, _disableEditing) || this.canvas === null) {\n                return;\n              }\n              _get(_getPrototypeOf(InkEditor.prototype), \"enableEditMode\", this).call(this);\n              this.div.draggable = false;\n              this.canvas.addEventListener(\"pointerdown\", _classPrivateFieldGet(this, _boundCanvasPointerdown));\n              this.canvas.addEventListener(\"pointerup\", _classPrivateFieldGet(this, _boundCanvasPointerup));\n            }\n          }, {\n            key: \"disableEditMode\",\n            value: function disableEditMode() {\n              if (!this.isInEditMode() || this.canvas === null) {\n                return;\n              }\n              _get(_getPrototypeOf(InkEditor.prototype), \"disableEditMode\", this).call(this);\n              this.div.draggable = !this.isEmpty();\n              this.div.classList.remove(\"editing\");\n              this.canvas.removeEventListener(\"pointerdown\", _classPrivateFieldGet(this, _boundCanvasPointerdown));\n              this.canvas.removeEventListener(\"pointerup\", _classPrivateFieldGet(this, _boundCanvasPointerup));\n            }\n          }, {\n            key: \"onceAdded\",\n            value: function onceAdded() {\n              this.div.draggable = !this.isEmpty();\n            }\n          }, {\n            key: \"isEmpty\",\n            value: function isEmpty() {\n              return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n            }\n          }, {\n            key: \"commit\",\n            value: function commit() {\n              if (_classPrivateFieldGet(this, _disableEditing)) {\n                return;\n              }\n              _get(_getPrototypeOf(InkEditor.prototype), \"commit\", this).call(this);\n              this.isEditing = false;\n              this.disableEditMode();\n              this.setInForeground();\n              _classPrivateFieldSet(this, _disableEditing, true);\n              this.div.classList.add(\"disabled\");\n              _classPrivateMethodGet(this, _fitToContent, _fitToContent2).call(this, true);\n              this.parent.addInkEditorIfNeeded(true);\n              this.parent.moveEditorInDOM(this);\n              this.div.focus({\n                preventScroll: true\n              });\n            }\n          }, {\n            key: \"focusin\",\n            value: function focusin(event) {\n              _get(_getPrototypeOf(InkEditor.prototype), \"focusin\", this).call(this, event);\n              this.enableEditMode();\n            }\n          }, {\n            key: \"canvasPointerdown\",\n            value: function canvasPointerdown(event) {\n              if (event.button !== 0 || !this.isInEditMode() || _classPrivateFieldGet(this, _disableEditing)) {\n                return;\n              }\n              this.setInForeground();\n              if (event.type !== \"mouse\") {\n                this.div.focus();\n              }\n              event.stopPropagation();\n              this.canvas.addEventListener(\"pointerleave\", _classPrivateFieldGet(this, _boundCanvasPointerleave));\n              this.canvas.addEventListener(\"pointermove\", _classPrivateFieldGet(this, _boundCanvasPointermove));\n              _classPrivateMethodGet(this, _startDrawing, _startDrawing2).call(this, event.offsetX, event.offsetY);\n            }\n          }, {\n            key: \"canvasPointermove\",\n            value: function canvasPointermove(event) {\n              event.stopPropagation();\n              _classPrivateMethodGet(this, _draw, _draw2).call(this, event.offsetX, event.offsetY);\n            }\n          }, {\n            key: \"canvasPointerup\",\n            value: function canvasPointerup(event) {\n              if (event.button !== 0) {\n                return;\n              }\n              if (this.isInEditMode() && this.currentPath.length !== 0) {\n                event.stopPropagation();\n                _classPrivateMethodGet(this, _endDrawing, _endDrawing2).call(this, event);\n                this.setInBackground();\n              }\n            }\n          }, {\n            key: \"canvasPointerleave\",\n            value: function canvasPointerleave(event) {\n              _classPrivateMethodGet(this, _endDrawing, _endDrawing2).call(this, event);\n              this.setInBackground();\n            }\n          }, {\n            key: \"render\",\n            value: function render() {\n              var _this55 = this;\n              if (this.div) {\n                return this.div;\n              }\n              var baseX, baseY;\n              if (this.width) {\n                baseX = this.x;\n                baseY = this.y;\n              }\n              _get(_getPrototypeOf(InkEditor.prototype), \"render\", this).call(this);\n              InkEditor._l10nPromise.get(\"editor_ink2_aria_label\").then(function (msg) {\n                var _this55$div;\n                return (_this55$div = _this55.div) === null || _this55$div === void 0 ? void 0 : _this55$div.setAttribute(\"aria-label\", msg);\n              });\n              var _classPrivateMethodGe = _classPrivateMethodGet(this, _getInitialBBox, _getInitialBBox2).call(this),\n                _classPrivateMethodGe2 = _slicedToArray(_classPrivateMethodGe, 4),\n                x = _classPrivateMethodGe2[0],\n                y = _classPrivateMethodGe2[1],\n                w = _classPrivateMethodGe2[2],\n                h = _classPrivateMethodGe2[3];\n              this.setAt(x, y, 0, 0);\n              this.setDims(w, h);\n              _classPrivateMethodGet(this, _createCanvas2, _createCanvas3).call(this);\n              if (this.width) {\n                var _this$parentDimension9 = _slicedToArray(this.parentDimensions, 2),\n                  parentWidth = _this$parentDimension9[0],\n                  parentHeight = _this$parentDimension9[1];\n                this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                _classPrivateFieldSet(this, _isCanvasInitialized, true);\n                _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);\n                this.setDims(this.width * parentWidth, this.height * parentHeight);\n                _classPrivateMethodGet(this, _redraw, _redraw2).call(this);\n                _classPrivateMethodGet(this, _setMinDims, _setMinDims2).call(this);\n                this.div.classList.add(\"disabled\");\n              } else {\n                this.div.classList.add(\"editing\");\n                this.enableEditMode();\n              }\n              _classPrivateMethodGet(this, _createObserver, _createObserver2).call(this);\n              return this.div;\n            }\n          }, {\n            key: \"setDimensions\",\n            value: function setDimensions(width, height) {\n              var roundedWidth = Math.round(width);\n              var roundedHeight = Math.round(height);\n              if (_classPrivateFieldGet(this, _realWidth) === roundedWidth && _classPrivateFieldGet(this, _realHeight) === roundedHeight) {\n                return;\n              }\n              _classPrivateFieldSet(this, _realWidth, roundedWidth);\n              _classPrivateFieldSet(this, _realHeight, roundedHeight);\n              this.canvas.style.visibility = \"hidden\";\n              if (_classPrivateFieldGet(this, _aspectRatio) && Math.abs(_classPrivateFieldGet(this, _aspectRatio) - width / height) > 1e-2) {\n                height = Math.ceil(width / _classPrivateFieldGet(this, _aspectRatio));\n                this.setDims(width, height);\n              }\n              var _this$parentDimension10 = _slicedToArray(this.parentDimensions, 2),\n                parentWidth = _this$parentDimension10[0],\n                parentHeight = _this$parentDimension10[1];\n              this.width = width / parentWidth;\n              this.height = height / parentHeight;\n              if (_classPrivateFieldGet(this, _disableEditing)) {\n                _classPrivateMethodGet(this, _setScaleFactor, _setScaleFactor2).call(this, width, height);\n              }\n              _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);\n              _classPrivateMethodGet(this, _redraw, _redraw2).call(this);\n              this.canvas.style.visibility = \"visible\";\n              this.fixDims();\n            }\n          }, {\n            key: \"serialize\",\n            value: function serialize() {\n              if (this.isEmpty()) {\n                return null;\n              }\n              var rect = this.getRect(0, 0);\n              var height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0];\n              var color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n              return {\n                annotationType: _util.AnnotationEditorType.INK,\n                color: color,\n                thickness: this.thickness,\n                opacity: this.opacity,\n                paths: _classPrivateMethodGet(this, _serializePaths, _serializePaths2).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, height),\n                pageIndex: this.pageIndex,\n                rect: rect,\n                rotation: this.rotation\n              };\n            }\n          }], [{\n            key: \"initialize\",\n            value: function initialize(l10n) {\n              this._l10nPromise = new Map([\"editor_ink_canvas_aria_label\", \"editor_ink2_aria_label\"].map(function (str) {\n                return [str, l10n.get(str)];\n              }));\n            }\n          }, {\n            key: \"updateDefaultParams\",\n            value: function updateDefaultParams(type, value) {\n              switch (type) {\n                case _util.AnnotationEditorParamsType.INK_THICKNESS:\n                  InkEditor._defaultThickness = value;\n                  break;\n                case _util.AnnotationEditorParamsType.INK_COLOR:\n                  InkEditor._defaultColor = value;\n                  break;\n                case _util.AnnotationEditorParamsType.INK_OPACITY:\n                  InkEditor._defaultOpacity = value / 100;\n                  break;\n              }\n            }\n          }, {\n            key: \"defaultPropertiesToUpdate\",\n            get: function get() {\n              return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];\n            }\n          }, {\n            key: \"deserialize\",\n            value: function deserialize(data, parent, uiManager) {\n              var _util$Util5;\n              var editor = _get(_getPrototypeOf(InkEditor), \"deserialize\", this).call(this, data, parent, uiManager);\n              editor.thickness = data.thickness;\n              editor.color = (_util$Util5 = _util.Util).makeHexColor.apply(_util$Util5, _toConsumableArray(data.color));\n              editor.opacity = data.opacity;\n              var _editor$pageDimension2 = _slicedToArray(editor.pageDimensions, 2),\n                pageWidth = _editor$pageDimension2[0],\n                pageHeight = _editor$pageDimension2[1];\n              var width = editor.width * pageWidth;\n              var height = editor.height * pageHeight;\n              var scaleFactor = editor.parentScale;\n              var padding = data.thickness / 2;\n              _classPrivateFieldSet(editor, _aspectRatio, width / height);\n              _classPrivateFieldSet(editor, _disableEditing, true);\n              _classPrivateFieldSet(editor, _realWidth, Math.round(width));\n              _classPrivateFieldSet(editor, _realHeight, Math.round(height));\n              var _iterator92 = _createForOfIteratorHelper(data.paths),\n                _step92;\n              try {\n                for (_iterator92.s(); !(_step92 = _iterator92.n()).done;) {\n                  var bezier = _step92.value.bezier;\n                  var path = [];\n                  editor.paths.push(path);\n                  var p0 = scaleFactor * (bezier[0] - padding);\n                  var p1 = scaleFactor * (height - bezier[1] - padding);\n                  for (var i = 2, ii = bezier.length; i < ii; i += 6) {\n                    var p10 = scaleFactor * (bezier[i] - padding);\n                    var p11 = scaleFactor * (height - bezier[i + 1] - padding);\n                    var p20 = scaleFactor * (bezier[i + 2] - padding);\n                    var p21 = scaleFactor * (height - bezier[i + 3] - padding);\n                    var p30 = scaleFactor * (bezier[i + 4] - padding);\n                    var p31 = scaleFactor * (height - bezier[i + 5] - padding);\n                    path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);\n                    p0 = p30;\n                    p1 = p31;\n                  }\n                  var path2D = _classStaticPrivateMethodGet(this, InkEditor, _buildPath2D).call(this, path);\n                  editor.bezierPath2D.push(path2D);\n                }\n              } catch (err) {\n                _iterator92.e(err);\n              } finally {\n                _iterator92.f();\n              }\n              var bbox = _classPrivateMethodGet(editor, _getBbox, _getBbox2).call(editor);\n              _classPrivateFieldSet(editor, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));\n              _classPrivateFieldSet(editor, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));\n              _classPrivateMethodGet(editor, _setScaleFactor, _setScaleFactor2).call(editor, width, height);\n              return editor;\n            }\n          }]);\n          return InkEditor;\n        }(_editor.AnnotationEditor);\n        function _updateThickness2(thickness) {\n          var _this56 = this;\n          var savedThickness = this.thickness;\n          this.addCommands({\n            cmd: function cmd() {\n              _this56.thickness = thickness;\n              _classPrivateMethodGet(_this56, _fitToContent, _fitToContent2).call(_this56);\n            },\n            undo: function undo() {\n              _this56.thickness = savedThickness;\n              _classPrivateMethodGet(_this56, _fitToContent, _fitToContent2).call(_this56);\n            },\n            mustExec: true,\n            type: _util.AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n          });\n        }\n        function _updateColor4(color) {\n          var _this57 = this;\n          var savedColor = this.color;\n          this.addCommands({\n            cmd: function cmd() {\n              _this57.color = color;\n              _classPrivateMethodGet(_this57, _redraw, _redraw2).call(_this57);\n            },\n            undo: function undo() {\n              _this57.color = savedColor;\n              _classPrivateMethodGet(_this57, _redraw, _redraw2).call(_this57);\n            },\n            mustExec: true,\n            type: _util.AnnotationEditorParamsType.INK_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n          });\n        }\n        function _updateOpacity2(opacity) {\n          var _this58 = this;\n          opacity /= 100;\n          var savedOpacity = this.opacity;\n          this.addCommands({\n            cmd: function cmd() {\n              _this58.opacity = opacity;\n              _classPrivateMethodGet(_this58, _redraw, _redraw2).call(_this58);\n            },\n            undo: function undo() {\n              _this58.opacity = savedOpacity;\n              _classPrivateMethodGet(_this58, _redraw, _redraw2).call(_this58);\n            },\n            mustExec: true,\n            type: _util.AnnotationEditorParamsType.INK_OPACITY,\n            overwriteIfSameType: true,\n            keepUndo: true\n          });\n        }\n        function _getInitialBBox2() {\n          var parentRotation = this.parentRotation,\n            _this$parentDimension11 = _slicedToArray(this.parentDimensions, 2),\n            width = _this$parentDimension11[0],\n            height = _this$parentDimension11[1];\n          switch (parentRotation) {\n            case 90:\n              return [0, height, height, width];\n            case 180:\n              return [width, height, width, height];\n            case 270:\n              return [width, 0, height, width];\n            default:\n              return [0, 0, width, height];\n          }\n        }\n        function _setStroke2() {\n          var ctx = this.ctx,\n            color = this.color,\n            opacity = this.opacity,\n            thickness = this.thickness,\n            parentScale = this.parentScale,\n            scaleFactor = this.scaleFactor;\n          ctx.lineWidth = thickness * parentScale / scaleFactor;\n          ctx.lineCap = \"round\";\n          ctx.lineJoin = \"round\";\n          ctx.miterLimit = 10;\n          ctx.strokeStyle = \"\".concat(color).concat((0, _tools.opacityToHex)(opacity));\n        }\n        function _startDrawing2(x, y) {\n          var _this59 = this;\n          this.isEditing = true;\n          if (!_classPrivateFieldGet(this, _isCanvasInitialized)) {\n            var _this$opacity2;\n            _classPrivateFieldSet(this, _isCanvasInitialized, true);\n            _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);\n            this.thickness || (this.thickness = InkEditor._defaultThickness);\n            this.color || (this.color = InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);\n            (_this$opacity2 = this.opacity) !== null && _this$opacity2 !== void 0 ? _this$opacity2 : this.opacity = InkEditor._defaultOpacity;\n          }\n          this.currentPath.push([x, y]);\n          _classPrivateFieldSet(this, _lastPoint, null);\n          _classPrivateMethodGet(this, _setStroke, _setStroke2).call(this);\n          this.ctx.beginPath();\n          this.ctx.moveTo(x, y);\n          _classPrivateFieldSet(this, _requestFrameCallback, function () {\n            if (!_classPrivateFieldGet(_this59, _requestFrameCallback)) {\n              return;\n            }\n            if (_classPrivateFieldGet(_this59, _lastPoint)) {\n              var _this59$ctx;\n              if (_this59.isEmpty()) {\n                _this59.ctx.setTransform(1, 0, 0, 1, 0, 0);\n                _this59.ctx.clearRect(0, 0, _this59.canvas.width, _this59.canvas.height);\n              } else {\n                _classPrivateMethodGet(_this59, _redraw, _redraw2).call(_this59);\n              }\n              (_this59$ctx = _this59.ctx).lineTo.apply(_this59$ctx, _toConsumableArray(_classPrivateFieldGet(_this59, _lastPoint)));\n              _classPrivateFieldSet(_this59, _lastPoint, null);\n              _this59.ctx.stroke();\n            }\n            window.requestAnimationFrame(_classPrivateFieldGet(_this59, _requestFrameCallback));\n          });\n          window.requestAnimationFrame(_classPrivateFieldGet(this, _requestFrameCallback));\n        }\n        function _draw2(x, y) {\n          var _this$currentPath$at = this.currentPath.at(-1),\n            _this$currentPath$at2 = _slicedToArray(_this$currentPath$at, 2),\n            lastX = _this$currentPath$at2[0],\n            lastY = _this$currentPath$at2[1];\n          if (x === lastX && y === lastY) {\n            return;\n          }\n          this.currentPath.push([x, y]);\n          _classPrivateFieldSet(this, _lastPoint, [x, y]);\n        }\n        function _stopDrawing2(x, y) {\n          var _this60 = this;\n          this.ctx.closePath();\n          _classPrivateFieldSet(this, _requestFrameCallback, null);\n          x = Math.min(Math.max(x, 0), this.canvas.width);\n          y = Math.min(Math.max(y, 0), this.canvas.height);\n          var _this$currentPath$at3 = this.currentPath.at(-1),\n            _this$currentPath$at4 = _slicedToArray(_this$currentPath$at3, 2),\n            lastX = _this$currentPath$at4[0],\n            lastY = _this$currentPath$at4[1];\n          if (x !== lastX || y !== lastY) {\n            this.currentPath.push([x, y]);\n          }\n          var bezier;\n          if (this.currentPath.length !== 1) {\n            bezier = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null);\n          } else {\n            var xy = [x, y];\n            bezier = [[xy, xy.slice(), xy.slice(), xy]];\n          }\n          var path2D = _classStaticPrivateMethodGet(InkEditor, InkEditor, _buildPath2D).call(InkEditor, bezier);\n          this.currentPath.length = 0;\n          var cmd = function cmd() {\n            _this60.paths.push(bezier);\n            _this60.bezierPath2D.push(path2D);\n            _this60.rebuild();\n          };\n          var undo = function undo() {\n            _this60.paths.pop();\n            _this60.bezierPath2D.pop();\n            if (_this60.paths.length === 0) {\n              _this60.remove();\n            } else {\n              if (!_this60.canvas) {\n                _classPrivateMethodGet(_this60, _createCanvas2, _createCanvas3).call(_this60);\n                _classPrivateMethodGet(_this60, _createObserver, _createObserver2).call(_this60);\n              }\n              _classPrivateMethodGet(_this60, _fitToContent, _fitToContent2).call(_this60);\n            }\n          };\n          this.addCommands({\n            cmd: cmd,\n            undo: undo,\n            mustExec: true\n          });\n        }\n        function _redraw2() {\n          if (this.isEmpty()) {\n            _classPrivateMethodGet(this, _updateTransform, _updateTransform2).call(this);\n            return;\n          }\n          _classPrivateMethodGet(this, _setStroke, _setStroke2).call(this);\n          var canvas = this.canvas,\n            ctx = this.ctx;\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          _classPrivateMethodGet(this, _updateTransform, _updateTransform2).call(this);\n          var _iterator93 = _createForOfIteratorHelper(this.bezierPath2D),\n            _step93;\n          try {\n            for (_iterator93.s(); !(_step93 = _iterator93.n()).done;) {\n              var path = _step93.value;\n              ctx.stroke(path);\n            }\n          } catch (err) {\n            _iterator93.e(err);\n          } finally {\n            _iterator93.f();\n          }\n        }\n        function _endDrawing2(event) {\n          _classPrivateMethodGet(this, _stopDrawing, _stopDrawing2).call(this, event.offsetX, event.offsetY);\n          this.canvas.removeEventListener(\"pointerleave\", _classPrivateFieldGet(this, _boundCanvasPointerleave));\n          this.canvas.removeEventListener(\"pointermove\", _classPrivateFieldGet(this, _boundCanvasPointermove));\n          this.addToAnnotationStorage();\n        }\n        function _createCanvas3() {\n          var _this61 = this;\n          this.canvas = document.createElement(\"canvas\");\n          this.canvas.width = this.canvas.height = 0;\n          this.canvas.className = \"inkEditorCanvas\";\n          InkEditor._l10nPromise.get(\"editor_ink_canvas_aria_label\").then(function (msg) {\n            var _this61$canvas;\n            return (_this61$canvas = _this61.canvas) === null || _this61$canvas === void 0 ? void 0 : _this61$canvas.setAttribute(\"aria-label\", msg);\n          });\n          this.div.append(this.canvas);\n          this.ctx = this.canvas.getContext(\"2d\");\n        }\n        function _createObserver2() {\n          var _this62 = this;\n          _classPrivateFieldSet(this, _observer, new ResizeObserver(function (entries) {\n            var rect = entries[0].contentRect;\n            if (rect.width && rect.height) {\n              _this62.setDimensions(rect.width, rect.height);\n            }\n          }));\n          _classPrivateFieldGet(this, _observer).observe(this.div);\n        }\n        function _setCanvasDims2() {\n          if (!_classPrivateFieldGet(this, _isCanvasInitialized)) {\n            return;\n          }\n          var _this$parentDimension12 = _slicedToArray(this.parentDimensions, 2),\n            parentWidth = _this$parentDimension12[0],\n            parentHeight = _this$parentDimension12[1];\n          this.canvas.width = Math.ceil(this.width * parentWidth);\n          this.canvas.height = Math.ceil(this.height * parentHeight);\n          _classPrivateMethodGet(this, _updateTransform, _updateTransform2).call(this);\n        }\n        function _setScaleFactor2(width, height) {\n          var padding = _classPrivateMethodGet(this, _getPadding, _getPadding2).call(this);\n          var scaleFactorW = (width - padding) / _classPrivateFieldGet(this, _baseWidth);\n          var scaleFactorH = (height - padding) / _classPrivateFieldGet(this, _baseHeight);\n          this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n        }\n        function _updateTransform2() {\n          var padding = _classPrivateMethodGet(this, _getPadding, _getPadding2).call(this) / 2;\n          this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n        }\n        function _buildPath2D(bezier) {\n          var path2D = new Path2D();\n          for (var i = 0, ii = bezier.length; i < ii; i++) {\n            var _bezier$i = _slicedToArray(bezier[i], 4),\n              first = _bezier$i[0],\n              control1 = _bezier$i[1],\n              control2 = _bezier$i[2],\n              second = _bezier$i[3];\n            if (i === 0) {\n              path2D.moveTo.apply(path2D, _toConsumableArray(first));\n            }\n            path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n          }\n          return path2D;\n        }\n        function _serializePaths2(s, tx, ty, h) {\n          var NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4;\n          var paths = [];\n          var padding = this.thickness / 2;\n          var buffer, points;\n          var _iterator94 = _createForOfIteratorHelper(this.paths),\n            _step94;\n          try {\n            for (_iterator94.s(); !(_step94 = _iterator94.n()).done;) {\n              var bezier = _step94.value;\n              buffer = [];\n              points = [];\n              for (var i = 0, ii = bezier.length; i < ii; i++) {\n                var _bezier$i2 = _slicedToArray(bezier[i], 4),\n                  first = _bezier$i2[0],\n                  control1 = _bezier$i2[1],\n                  control2 = _bezier$i2[2],\n                  second = _bezier$i2[3];\n                var p10 = s * (first[0] + tx) + padding;\n                var p11 = h - s * (first[1] + ty) - padding;\n                var p20 = s * (control1[0] + tx) + padding;\n                var p21 = h - s * (control1[1] + ty) - padding;\n                var p30 = s * (control2[0] + tx) + padding;\n                var p31 = h - s * (control2[1] + ty) - padding;\n                var p40 = s * (second[0] + tx) + padding;\n                var p41 = h - s * (second[1] + ty) - padding;\n                if (i === 0) {\n                  buffer.push(p10, p11);\n                  points.push(p10, p11);\n                }\n                buffer.push(p20, p21, p30, p31, p40, p41);\n                _classPrivateMethodGet(this, _extractPointsOnBezier, _extractPointsOnBezier2).call(this, p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points);\n              }\n              paths.push({\n                bezier: buffer,\n                points: points\n              });\n            }\n          } catch (err) {\n            _iterator94.e(err);\n          } finally {\n            _iterator94.f();\n          }\n          return paths;\n        }\n        function _extractPointsOnBezier2(p10, p11, p20, p21, p30, p31, p40, p41, n, points) {\n          if (_classPrivateMethodGet(this, _isAlmostFlat, _isAlmostFlat2).call(this, p10, p11, p20, p21, p30, p31, p40, p41)) {\n            points.push(p40, p41);\n            return;\n          }\n          for (var i = 1; i < n - 1; i++) {\n            var t = i / n;\n            var mt = 1 - t;\n            var q10 = t * p10 + mt * p20;\n            var q11 = t * p11 + mt * p21;\n            var q20 = t * p20 + mt * p30;\n            var q21 = t * p21 + mt * p31;\n            var q30 = t * p30 + mt * p40;\n            var q31 = t * p31 + mt * p41;\n            q10 = t * q10 + mt * q20;\n            q11 = t * q11 + mt * q21;\n            q20 = t * q20 + mt * q30;\n            q21 = t * q21 + mt * q31;\n            q10 = t * q10 + mt * q20;\n            q11 = t * q11 + mt * q21;\n            points.push(q10, q11);\n          }\n          points.push(p40, p41);\n        }\n        function _isAlmostFlat2(p10, p11, p20, p21, p30, p31, p40, p41) {\n          var tol = 10;\n          var ax = Math.pow(3 * p20 - 2 * p10 - p40, 2);\n          var ay = Math.pow(3 * p21 - 2 * p11 - p41, 2);\n          var bx = Math.pow(3 * p30 - p10 - 2 * p40, 2);\n          var by = Math.pow(3 * p31 - p11 - 2 * p41, 2);\n          return Math.max(ax, bx) + Math.max(ay, by) <= tol;\n        }\n        function _getBbox2() {\n          var xMin = Infinity;\n          var xMax = -Infinity;\n          var yMin = Infinity;\n          var yMax = -Infinity;\n          var _iterator95 = _createForOfIteratorHelper(this.paths),\n            _step95;\n          try {\n            for (_iterator95.s(); !(_step95 = _iterator95.n()).done;) {\n              var path = _step95.value;\n              var _iterator96 = _createForOfIteratorHelper(path),\n                _step96;\n              try {\n                for (_iterator96.s(); !(_step96 = _iterator96.n()).done;) {\n                  var _util$Util6;\n                  var _step96$value = _slicedToArray(_step96.value, 4),\n                    first = _step96$value[0],\n                    control1 = _step96$value[1],\n                    control2 = _step96$value[2],\n                    second = _step96$value[3];\n                  var bbox = (_util$Util6 = _util.Util).bezierBoundingBox.apply(_util$Util6, _toConsumableArray(first).concat(_toConsumableArray(control1), _toConsumableArray(control2), _toConsumableArray(second)));\n                  xMin = Math.min(xMin, bbox[0]);\n                  yMin = Math.min(yMin, bbox[1]);\n                  xMax = Math.max(xMax, bbox[2]);\n                  yMax = Math.max(yMax, bbox[3]);\n                }\n              } catch (err) {\n                _iterator96.e(err);\n              } finally {\n                _iterator96.f();\n              }\n            }\n          } catch (err) {\n            _iterator95.e(err);\n          } finally {\n            _iterator95.f();\n          }\n          return [xMin, yMin, xMax, yMax];\n        }\n        function _getPadding2() {\n          return _classPrivateFieldGet(this, _disableEditing) ? Math.ceil(this.thickness * this.parentScale) : 0;\n        }\n        function _fitToContent2() {\n          var firstTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n          if (this.isEmpty()) {\n            return;\n          }\n          if (!_classPrivateFieldGet(this, _disableEditing)) {\n            _classPrivateMethodGet(this, _redraw, _redraw2).call(this);\n            return;\n          }\n          var bbox = _classPrivateMethodGet(this, _getBbox, _getBbox2).call(this);\n          var padding = _classPrivateMethodGet(this, _getPadding, _getPadding2).call(this);\n          _classPrivateFieldSet(this, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));\n          _classPrivateFieldSet(this, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));\n          var width = Math.ceil(padding + _classPrivateFieldGet(this, _baseWidth) * this.scaleFactor);\n          var height = Math.ceil(padding + _classPrivateFieldGet(this, _baseHeight) * this.scaleFactor);\n          var _this$parentDimension13 = _slicedToArray(this.parentDimensions, 2),\n            parentWidth = _this$parentDimension13[0],\n            parentHeight = _this$parentDimension13[1];\n          this.width = width / parentWidth;\n          this.height = height / parentHeight;\n          _classPrivateFieldSet(this, _aspectRatio, width / height);\n          _classPrivateMethodGet(this, _setMinDims, _setMinDims2).call(this);\n          var prevTranslationX = this.translationX;\n          var prevTranslationY = this.translationY;\n          this.translationX = -bbox[0];\n          this.translationY = -bbox[1];\n          _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);\n          _classPrivateMethodGet(this, _redraw, _redraw2).call(this);\n          _classPrivateFieldSet(this, _realWidth, width);\n          _classPrivateFieldSet(this, _realHeight, height);\n          this.setDims(width, height);\n          var unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n          this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n        }\n        function _setMinDims2() {\n          var style = this.div.style;\n          if (_classPrivateFieldGet(this, _aspectRatio) >= 1) {\n            style.minHeight = \"\".concat(RESIZER_SIZE, \"px\");\n            style.minWidth = \"\".concat(Math.round(_classPrivateFieldGet(this, _aspectRatio) * RESIZER_SIZE), \"px\");\n          } else {\n            style.minWidth = \"\".concat(RESIZER_SIZE, \"px\");\n            style.minHeight = \"\".concat(Math.round(RESIZER_SIZE / _classPrivateFieldGet(this, _aspectRatio)), \"px\");\n          }\n        }\n        _defineProperty(InkEditor, \"_defaultColor\", null);\n        _defineProperty(InkEditor, \"_defaultOpacity\", 1);\n        _defineProperty(InkEditor, \"_defaultThickness\", 1);\n        _defineProperty(InkEditor, \"_l10nPromise\", void 0);\n        _defineProperty(InkEditor, \"_type\", \"ink\");\n        exports.InkEditor = InkEditor;\n\n        /***/\n      }, /* 30 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.fitCurve = void 0;\n        var fitCurve = __w_pdfjs_require__(31);\n        exports.fitCurve = fitCurve;\n\n        /***/\n      }, /* 31 */\n      /***/function (module) {\n        function fitCurve(points, maxError, progressCallback) {\n          if (!Array.isArray(points)) {\n            throw new TypeError(\"First argument should be an array\");\n          }\n          points.forEach(function (point) {\n            if (!Array.isArray(point) || point.some(function (item) {\n              return typeof item !== 'number';\n            }) || point.length !== points[0].length) {\n              throw Error(\"Each point should be an array of numbers. Each point should have the same amount of numbers.\");\n            }\n          });\n          points = points.filter(function (point, i) {\n            return i === 0 || !point.every(function (val, j) {\n              return val === points[i - 1][j];\n            });\n          });\n          if (points.length < 2) {\n            return [];\n          }\n          var len = points.length;\n          var leftTangent = createTangent(points[1], points[0]);\n          var rightTangent = createTangent(points[len - 2], points[len - 1]);\n          return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);\n        }\n        function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {\n          var MaxIterations = 20;\n          var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist, i;\n          if (points.length === 2) {\n            dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0;\n            bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]];\n            return [bezCurve];\n          }\n          u = chordLengthParameterize(points);\n          var _generateAndReport = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);\n          var _generateAndReport2 = _slicedToArray(_generateAndReport, 3);\n          bezCurve = _generateAndReport2[0];\n          maxError = _generateAndReport2[1];\n          splitPoint = _generateAndReport2[2];\n          if (maxError === 0 || maxError < error) {\n            return [bezCurve];\n          }\n          if (maxError < error * error) {\n            uPrime = u;\n            prevErr = maxError;\n            prevSplit = splitPoint;\n            for (i = 0; i < MaxIterations; i++) {\n              uPrime = reparameterize(bezCurve, points, uPrime);\n              var _generateAndReport3 = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);\n              var _generateAndReport4 = _slicedToArray(_generateAndReport3, 3);\n              bezCurve = _generateAndReport4[0];\n              maxError = _generateAndReport4[1];\n              splitPoint = _generateAndReport4[2];\n              if (maxError < error) {\n                return [bezCurve];\n              } else if (splitPoint === prevSplit) {\n                var errChange = maxError / prevErr;\n                if (errChange > .9999 && errChange < 1.0001) {\n                  break;\n                }\n              }\n              prevErr = maxError;\n              prevSplit = splitPoint;\n            }\n          }\n          beziers = [];\n          centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);\n          if (centerVector.every(function (val) {\n            return val === 0;\n          })) {\n            centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);\n            var _ref64 = [-centerVector[1], centerVector[0]];\n            centerVector[0] = _ref64[0];\n            centerVector[1] = _ref64[1];\n          }\n          toCenterTangent = maths.normalize(centerVector);\n          fromCenterTangent = maths.mulItems(toCenterTangent, -1);\n          beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));\n          beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));\n          return beziers;\n        }\n        ;\n        function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {\n          var bezCurve, maxError, splitPoint;\n          bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);\n          var _computeMaxError = computeMaxError(points, bezCurve, paramsOrig);\n          var _computeMaxError2 = _slicedToArray(_computeMaxError, 2);\n          maxError = _computeMaxError2[0];\n          splitPoint = _computeMaxError2[1];\n          if (progressCallback) {\n            progressCallback({\n              bez: bezCurve,\n              points: points,\n              params: paramsOrig,\n              maxErr: maxError,\n              maxPoint: splitPoint\n            });\n          }\n          return [bezCurve, maxError, splitPoint];\n        }\n        function generateBezier(points, parameters, leftTangent, rightTangent) {\n          var bezCurve,\n            A,\n            a,\n            C,\n            X,\n            det_C0_C1,\n            det_C0_X,\n            det_X_C1,\n            alpha_l,\n            alpha_r,\n            epsilon,\n            segLength,\n            i,\n            len,\n            tmp,\n            u,\n            ux,\n            firstPoint = points[0],\n            lastPoint = points[points.length - 1];\n          bezCurve = [firstPoint, null, null, lastPoint];\n          A = maths.zeros_Xx2x2(parameters.length);\n          for (i = 0, len = parameters.length; i < len; i++) {\n            u = parameters[i];\n            ux = 1 - u;\n            a = A[i];\n            a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));\n            a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));\n          }\n          C = [[0, 0], [0, 0]];\n          X = [0, 0];\n          for (i = 0, len = points.length; i < len; i++) {\n            u = parameters[i];\n            a = A[i];\n            C[0][0] += maths.dot(a[0], a[0]);\n            C[0][1] += maths.dot(a[0], a[1]);\n            C[1][0] += maths.dot(a[0], a[1]);\n            C[1][1] += maths.dot(a[1], a[1]);\n            tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));\n            X[0] += maths.dot(a[0], tmp);\n            X[1] += maths.dot(a[1], tmp);\n          }\n          det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];\n          det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];\n          det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];\n          alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;\n          alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;\n          segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));\n          epsilon = 1.0e-6 * segLength;\n          if (alpha_l < epsilon || alpha_r < epsilon) {\n            bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0));\n            bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0));\n          } else {\n            bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));\n            bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));\n          }\n          return bezCurve;\n        }\n        ;\n        function reparameterize(bezier, points, parameters) {\n          return parameters.map(function (p, i) {\n            return newtonRaphsonRootFind(bezier, points[i], p);\n          });\n        }\n        ;\n        function newtonRaphsonRootFind(bez, point, u) {\n          var d = maths.subtract(bezier.q(bez, u), point),\n            qprime = bezier.qprime(bez, u),\n            numerator = maths.mulMatrix(d, qprime),\n            denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));\n          if (denominator === 0) {\n            return u;\n          } else {\n            return u - numerator / denominator;\n          }\n        }\n        ;\n        function chordLengthParameterize(points) {\n          var u = [],\n            currU,\n            prevU,\n            prevP;\n          points.forEach(function (p, i) {\n            currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;\n            u.push(currU);\n            prevU = currU;\n            prevP = p;\n          });\n          u = u.map(function (x) {\n            return x / prevU;\n          });\n          return u;\n        }\n        ;\n        function computeMaxError(points, bez, parameters) {\n          var dist, maxDist, splitPoint, v, i, count, point, t;\n          maxDist = 0;\n          splitPoint = Math.floor(points.length / 2);\n          var t_distMap = mapTtoRelativeDistances(bez, 10);\n          for (i = 0, count = points.length; i < count; i++) {\n            point = points[i];\n            t = find_t(bez, parameters[i], t_distMap, 10);\n            v = maths.subtract(bezier.q(bez, t), point);\n            dist = v[0] * v[0] + v[1] * v[1];\n            if (dist > maxDist) {\n              maxDist = dist;\n              splitPoint = i;\n            }\n          }\n          return [maxDist, splitPoint];\n        }\n        ;\n        var mapTtoRelativeDistances = function mapTtoRelativeDistances(bez, B_parts) {\n          var B_t_curr;\n          var B_t_dist = [0];\n          var B_t_prev = bez[0];\n          var sumLen = 0;\n          for (var i = 1; i <= B_parts; i++) {\n            B_t_curr = bezier.q(bez, i / B_parts);\n            sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));\n            B_t_dist.push(sumLen);\n            B_t_prev = B_t_curr;\n          }\n          B_t_dist = B_t_dist.map(function (x) {\n            return x / sumLen;\n          });\n          return B_t_dist;\n        };\n        function find_t(bez, param, t_distMap, B_parts) {\n          if (param < 0) {\n            return 0;\n          }\n          if (param > 1) {\n            return 1;\n          }\n          var lenMax, lenMin, tMax, tMin, t;\n          for (var i = 1; i <= B_parts; i++) {\n            if (param <= t_distMap[i]) {\n              tMin = (i - 1) / B_parts;\n              tMax = i / B_parts;\n              lenMin = t_distMap[i - 1];\n              lenMax = t_distMap[i];\n              t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;\n              break;\n            }\n          }\n          return t;\n        }\n        function createTangent(pointA, pointB) {\n          return maths.normalize(maths.subtract(pointA, pointB));\n        }\n        var maths = /*#__PURE__*/function () {\n          function maths() {\n            _classCallCheck(this, maths);\n          }\n          _createClass(maths, null, [{\n            key: \"zeros_Xx2x2\",\n            value: function zeros_Xx2x2(x) {\n              var zs = [];\n              while (x--) {\n                zs.push([0, 0]);\n              }\n              return zs;\n            }\n          }, {\n            key: \"mulItems\",\n            value: function mulItems(items, multiplier) {\n              return items.map(function (x) {\n                return x * multiplier;\n              });\n            }\n          }, {\n            key: \"mulMatrix\",\n            value: function mulMatrix(m1, m2) {\n              return m1.reduce(function (sum, x1, i) {\n                return sum + x1 * m2[i];\n              }, 0);\n            }\n          }, {\n            key: \"subtract\",\n            value: function subtract(arr1, arr2) {\n              return arr1.map(function (x1, i) {\n                return x1 - arr2[i];\n              });\n            }\n          }, {\n            key: \"addArrays\",\n            value: function addArrays(arr1, arr2) {\n              return arr1.map(function (x1, i) {\n                return x1 + arr2[i];\n              });\n            }\n          }, {\n            key: \"addItems\",\n            value: function addItems(items, addition) {\n              return items.map(function (x) {\n                return x + addition;\n              });\n            }\n          }, {\n            key: \"sum\",\n            value: function sum(items) {\n              return items.reduce(function (sum, x) {\n                return sum + x;\n              });\n            }\n          }, {\n            key: \"dot\",\n            value: function dot(m1, m2) {\n              return maths.mulMatrix(m1, m2);\n            }\n          }, {\n            key: \"vectorLen\",\n            value: function vectorLen(v) {\n              return Math.hypot.apply(Math, _toConsumableArray(v));\n            }\n          }, {\n            key: \"divItems\",\n            value: function divItems(items, divisor) {\n              return items.map(function (x) {\n                return x / divisor;\n              });\n            }\n          }, {\n            key: \"squareItems\",\n            value: function squareItems(items) {\n              return items.map(function (x) {\n                return x * x;\n              });\n            }\n          }, {\n            key: \"normalize\",\n            value: function normalize(v) {\n              return this.divItems(v, this.vectorLen(v));\n            }\n          }]);\n          return maths;\n        }();\n        var bezier = /*#__PURE__*/function () {\n          function bezier() {\n            _classCallCheck(this, bezier);\n          }\n          _createClass(bezier, null, [{\n            key: \"q\",\n            value: function q(ctrlPoly, t) {\n              var tx = 1.0 - t;\n              var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx),\n                pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t),\n                pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t),\n                pD = maths.mulItems(ctrlPoly[3], t * t * t);\n              return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));\n            }\n          }, {\n            key: \"qprime\",\n            value: function qprime(ctrlPoly, t) {\n              var tx = 1.0 - t;\n              var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx),\n                pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t),\n                pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);\n              return maths.addArrays(maths.addArrays(pA, pB), pC);\n            }\n          }, {\n            key: \"qprimeprime\",\n            value: function qprimeprime(ctrlPoly, t) {\n              return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));\n            }\n          }]);\n          return bezier;\n        }();\n        module.exports = fitCurve;\n        module.exports.fitCubic = fitCubic;\n        module.exports.createTangent = createTangent;\n\n        /***/\n      }, /* 32 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.AnnotationLayer = void 0;\n        var _util = __w_pdfjs_require__(1);\n        var _display_utils = __w_pdfjs_require__(6);\n        var _annotation_storage = __w_pdfjs_require__(3);\n        var _scripting_utils = __w_pdfjs_require__(33);\n        var _xfa_layer = __w_pdfjs_require__(34);\n        var DEFAULT_TAB_INDEX = 1000;\n        var DEFAULT_FONT_SIZE = 9;\n        var GetElementsByNameSet = new WeakSet();\n        function getRectDims(rect) {\n          return {\n            width: rect[2] - rect[0],\n            height: rect[3] - rect[1]\n          };\n        }\n        var AnnotationElementFactory = /*#__PURE__*/function () {\n          function AnnotationElementFactory() {\n            _classCallCheck(this, AnnotationElementFactory);\n          }\n          _createClass(AnnotationElementFactory, null, [{\n            key: \"create\",\n            value: function create(parameters) {\n              var subtype = parameters.data.annotationType;\n              switch (subtype) {\n                case _util.AnnotationType.LINK:\n                  return new LinkAnnotationElement(parameters);\n                case _util.AnnotationType.TEXT:\n                  return new TextAnnotationElement(parameters);\n                case _util.AnnotationType.WIDGET:\n                  var fieldType = parameters.data.fieldType;\n                  switch (fieldType) {\n                    case \"Tx\":\n                      return new TextWidgetAnnotationElement(parameters);\n                    case \"Btn\":\n                      if (parameters.data.radioButton) {\n                        return new RadioButtonWidgetAnnotationElement(parameters);\n                      } else if (parameters.data.checkBox) {\n                        return new CheckboxWidgetAnnotationElement(parameters);\n                      }\n                      return new PushButtonWidgetAnnotationElement(parameters);\n                    case \"Ch\":\n                      return new ChoiceWidgetAnnotationElement(parameters);\n                  }\n                  return new WidgetAnnotationElement(parameters);\n                case _util.AnnotationType.POPUP:\n                  return new PopupAnnotationElement(parameters);\n                case _util.AnnotationType.FREETEXT:\n                  return new FreeTextAnnotationElement(parameters);\n                case _util.AnnotationType.LINE:\n                  return new LineAnnotationElement(parameters);\n                case _util.AnnotationType.SQUARE:\n                  return new SquareAnnotationElement(parameters);\n                case _util.AnnotationType.CIRCLE:\n                  return new CircleAnnotationElement(parameters);\n                case _util.AnnotationType.POLYLINE:\n                  return new PolylineAnnotationElement(parameters);\n                case _util.AnnotationType.CARET:\n                  return new CaretAnnotationElement(parameters);\n                case _util.AnnotationType.INK:\n                  return new InkAnnotationElement(parameters);\n                case _util.AnnotationType.POLYGON:\n                  return new PolygonAnnotationElement(parameters);\n                case _util.AnnotationType.HIGHLIGHT:\n                  return new HighlightAnnotationElement(parameters);\n                case _util.AnnotationType.UNDERLINE:\n                  return new UnderlineAnnotationElement(parameters);\n                case _util.AnnotationType.SQUIGGLY:\n                  return new SquigglyAnnotationElement(parameters);\n                case _util.AnnotationType.STRIKEOUT:\n                  return new StrikeOutAnnotationElement(parameters);\n                case _util.AnnotationType.STAMP:\n                  return new StampAnnotationElement(parameters);\n                case _util.AnnotationType.FILEATTACHMENT:\n                  return new FileAttachmentAnnotationElement(parameters);\n                default:\n                  return new AnnotationElement(parameters);\n              }\n            }\n          }]);\n          return AnnotationElementFactory;\n        }();\n        var AnnotationElement = /*#__PURE__*/function () {\n          function AnnotationElement(parameters) {\n            var _ref65 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n              _ref65$isRenderable = _ref65.isRenderable,\n              isRenderable = _ref65$isRenderable === void 0 ? false : _ref65$isRenderable,\n              _ref65$ignoreBorder = _ref65.ignoreBorder,\n              ignoreBorder = _ref65$ignoreBorder === void 0 ? false : _ref65$ignoreBorder,\n              _ref65$createQuadrila = _ref65.createQuadrilaterals,\n              createQuadrilaterals = _ref65$createQuadrila === void 0 ? false : _ref65$createQuadrila;\n            _classCallCheck(this, AnnotationElement);\n            this.isRenderable = isRenderable;\n            this.data = parameters.data;\n            this.layer = parameters.layer;\n            this.page = parameters.page;\n            this.viewport = parameters.viewport;\n            this.linkService = parameters.linkService;\n            this.downloadManager = parameters.downloadManager;\n            this.imageResourcesPath = parameters.imageResourcesPath;\n            this.renderForms = parameters.renderForms;\n            this.svgFactory = parameters.svgFactory;\n            this.annotationStorage = parameters.annotationStorage;\n            this.enableScripting = parameters.enableScripting;\n            this.hasJSActions = parameters.hasJSActions;\n            this._fieldObjects = parameters.fieldObjects;\n            if (isRenderable) {\n              this.container = this._createContainer(ignoreBorder);\n            }\n            if (createQuadrilaterals) {\n              this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\n            }\n          }\n          _createClass(AnnotationElement, [{\n            key: \"_createContainer\",\n            value: function _createContainer() {\n              var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n              var data = this.data,\n                page = this.page,\n                viewport = this.viewport;\n              var container = document.createElement(\"section\");\n              container.setAttribute(\"data-annotation-id\", data.id);\n              if (data.noRotate) {\n                container.classList.add(\"norotate\");\n              }\n              var _viewport$rawDims3 = viewport.rawDims,\n                pageWidth = _viewport$rawDims3.pageWidth,\n                pageHeight = _viewport$rawDims3.pageHeight,\n                pageX = _viewport$rawDims3.pageX,\n                pageY = _viewport$rawDims3.pageY;\n              var _getRectDims = getRectDims(data.rect),\n                width = _getRectDims.width,\n                height = _getRectDims.height;\n              var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n              if (!ignoreBorder && data.borderStyle.width > 0) {\n                container.style.borderWidth = \"\".concat(data.borderStyle.width, \"px\");\n                var horizontalRadius = data.borderStyle.horizontalCornerRadius;\n                var verticalRadius = data.borderStyle.verticalCornerRadius;\n                if (horizontalRadius > 0 || verticalRadius > 0) {\n                  var radius = \"calc(\".concat(horizontalRadius, \"px * var(--scale-factor)) / calc(\").concat(verticalRadius, \"px * var(--scale-factor))\");\n                  container.style.borderRadius = radius;\n                } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                  var _radius = \"calc(\".concat(width, \"px * var(--scale-factor)) / calc(\").concat(height, \"px * var(--scale-factor))\");\n                  container.style.borderRadius = _radius;\n                }\n                switch (data.borderStyle.style) {\n                  case _util.AnnotationBorderStyleType.SOLID:\n                    container.style.borderStyle = \"solid\";\n                    break;\n                  case _util.AnnotationBorderStyleType.DASHED:\n                    container.style.borderStyle = \"dashed\";\n                    break;\n                  case _util.AnnotationBorderStyleType.BEVELED:\n                    (0, _util.warn)(\"Unimplemented border style: beveled\");\n                    break;\n                  case _util.AnnotationBorderStyleType.INSET:\n                    (0, _util.warn)(\"Unimplemented border style: inset\");\n                    break;\n                  case _util.AnnotationBorderStyleType.UNDERLINE:\n                    container.style.borderBottomStyle = \"solid\";\n                    break;\n                  default:\n                    break;\n                }\n                var borderColor = data.borderColor || null;\n                if (borderColor) {\n                  container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n                } else {\n                  container.style.borderWidth = 0;\n                }\n              }\n              container.style.left = \"\".concat(100 * (rect[0] - pageX) / pageWidth, \"%\");\n              container.style.top = \"\".concat(100 * (rect[1] - pageY) / pageHeight, \"%\");\n              var rotation = data.rotation;\n              if (data.hasOwnCanvas || rotation === 0) {\n                container.style.width = \"\".concat(100 * width / pageWidth, \"%\");\n                container.style.height = \"\".concat(100 * height / pageHeight, \"%\");\n              } else {\n                this.setRotation(rotation, container);\n              }\n              return container;\n            }\n          }, {\n            key: \"setRotation\",\n            value: function setRotation(angle) {\n              var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n              var _this$viewport$rawDim2 = this.viewport.rawDims,\n                pageWidth = _this$viewport$rawDim2.pageWidth,\n                pageHeight = _this$viewport$rawDim2.pageHeight;\n              var _getRectDims2 = getRectDims(this.data.rect),\n                width = _getRectDims2.width,\n                height = _getRectDims2.height;\n              var elementWidth, elementHeight;\n              if (angle % 180 === 0) {\n                elementWidth = 100 * width / pageWidth;\n                elementHeight = 100 * height / pageHeight;\n              } else {\n                elementWidth = 100 * height / pageWidth;\n                elementHeight = 100 * width / pageHeight;\n              }\n              container.style.width = \"\".concat(elementWidth, \"%\");\n              container.style.height = \"\".concat(elementHeight, \"%\");\n              container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n            }\n          }, {\n            key: \"_commonActions\",\n            get: function get() {\n              var _this63 = this;\n              var setColor = function setColor(jsName, styleName, event) {\n                var color = event.detail[jsName];\n                event.target.style[styleName] = _scripting_utils.ColorConverters[\"\".concat(color[0], \"_HTML\")](color.slice(1));\n              };\n              return (0, _util.shadow)(this, \"_commonActions\", {\n                display: function display(event) {\n                  var hidden = event.detail.display % 2 === 1;\n                  _this63.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                  _this63.annotationStorage.setValue(_this63.data.id, {\n                    hidden: hidden,\n                    print: event.detail.display === 0 || event.detail.display === 3\n                  });\n                },\n                print: function print(event) {\n                  _this63.annotationStorage.setValue(_this63.data.id, {\n                    print: event.detail.print\n                  });\n                },\n                hidden: function hidden(event) {\n                  _this63.container.style.visibility = event.detail.hidden ? \"hidden\" : \"visible\";\n                  _this63.annotationStorage.setValue(_this63.data.id, {\n                    hidden: event.detail.hidden\n                  });\n                },\n                focus: function focus(event) {\n                  setTimeout(function () {\n                    return event.target.focus({\n                      preventScroll: false\n                    });\n                  }, 0);\n                },\n                userName: function userName(event) {\n                  event.target.title = event.detail.userName;\n                },\n                readonly: function readonly(event) {\n                  if (event.detail.readonly) {\n                    event.target.setAttribute(\"readonly\", \"\");\n                  } else {\n                    event.target.removeAttribute(\"readonly\");\n                  }\n                },\n                required: function required(event) {\n                  _this63._setRequired(event.target, event.detail.required);\n                },\n                bgColor: function bgColor(event) {\n                  setColor(\"bgColor\", \"backgroundColor\", event);\n                },\n                fillColor: function fillColor(event) {\n                  setColor(\"fillColor\", \"backgroundColor\", event);\n                },\n                fgColor: function fgColor(event) {\n                  setColor(\"fgColor\", \"color\", event);\n                },\n                textColor: function textColor(event) {\n                  setColor(\"textColor\", \"color\", event);\n                },\n                borderColor: function borderColor(event) {\n                  setColor(\"borderColor\", \"borderColor\", event);\n                },\n                strokeColor: function strokeColor(event) {\n                  setColor(\"strokeColor\", \"borderColor\", event);\n                },\n                rotation: function rotation(event) {\n                  var angle = event.detail.rotation;\n                  _this63.setRotation(angle);\n                  _this63.annotationStorage.setValue(_this63.data.id, {\n                    rotation: angle\n                  });\n                }\n              });\n            }\n          }, {\n            key: \"_dispatchEventFromSandbox\",\n            value: function _dispatchEventFromSandbox(actions, jsEvent) {\n              var commonActions = this._commonActions;\n              for (var _i12 = 0, _Object$keys = Object.keys(jsEvent.detail); _i12 < _Object$keys.length; _i12++) {\n                var name = _Object$keys[_i12];\n                var action = actions[name] || commonActions[name];\n                action === null || action === void 0 ? void 0 : action(jsEvent);\n              }\n            }\n          }, {\n            key: \"_setDefaultPropertiesFromJS\",\n            value: function _setDefaultPropertiesFromJS(element) {\n              if (!this.enableScripting) {\n                return;\n              }\n              var storedData = this.annotationStorage.getRawValue(this.data.id);\n              if (!storedData) {\n                return;\n              }\n              var commonActions = this._commonActions;\n              for (var _i13 = 0, _Object$entries3 = Object.entries(storedData); _i13 < _Object$entries3.length; _i13++) {\n                var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i13], 2),\n                  actionName = _Object$entries3$_i[0],\n                  detail = _Object$entries3$_i[1];\n                var action = commonActions[actionName];\n                if (action) {\n                  var eventProxy = {\n                    detail: _defineProperty({}, actionName, detail),\n                    target: element\n                  };\n                  action(eventProxy);\n                  delete storedData[actionName];\n                }\n              }\n            }\n          }, {\n            key: \"_createQuadrilaterals\",\n            value: function _createQuadrilaterals() {\n              var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n              if (!this.data.quadPoints) {\n                return null;\n              }\n              var quadrilaterals = [];\n              var savedRect = this.data.rect;\n              var _iterator97 = _createForOfIteratorHelper(this.data.quadPoints),\n                _step97;\n              try {\n                for (_iterator97.s(); !(_step97 = _iterator97.n()).done;) {\n                  var quadPoint = _step97.value;\n                  this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];\n                  quadrilaterals.push(this._createContainer(ignoreBorder));\n                }\n              } catch (err) {\n                _iterator97.e(err);\n              } finally {\n                _iterator97.f();\n              }\n              this.data.rect = savedRect;\n              return quadrilaterals;\n            }\n          }, {\n            key: \"_createPopup\",\n            value: function _createPopup(trigger, data) {\n              var container = this.container;\n              if (this.quadrilaterals) {\n                trigger || (trigger = this.quadrilaterals);\n                container = this.quadrilaterals[0];\n              }\n              if (!trigger) {\n                trigger = document.createElement(\"div\");\n                trigger.classList.add(\"popupTriggerArea\");\n                container.append(trigger);\n              }\n              var popupElement = new PopupElement({\n                container: container,\n                trigger: trigger,\n                color: data.color,\n                titleObj: data.titleObj,\n                modificationDate: data.modificationDate,\n                contentsObj: data.contentsObj,\n                richText: data.richText,\n                hideWrapper: true\n              });\n              var popup = popupElement.render();\n              popup.style.left = \"100%\";\n              container.append(popup);\n            }\n          }, {\n            key: \"_renderQuadrilaterals\",\n            value: function _renderQuadrilaterals(className) {\n              var _iterator98 = _createForOfIteratorHelper(this.quadrilaterals),\n                _step98;\n              try {\n                for (_iterator98.s(); !(_step98 = _iterator98.n()).done;) {\n                  var quadrilateral = _step98.value;\n                  quadrilateral.classList.add(className);\n                }\n              } catch (err) {\n                _iterator98.e(err);\n              } finally {\n                _iterator98.f();\n              }\n              return this.quadrilaterals;\n            }\n          }, {\n            key: \"render\",\n            value: function render() {\n              (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n            }\n          }, {\n            key: \"_getElementsByName\",\n            value: function _getElementsByName(name) {\n              var skipId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n              var fields = [];\n              if (this._fieldObjects) {\n                var fieldObj = this._fieldObjects[name];\n                if (fieldObj) {\n                  var _iterator99 = _createForOfIteratorHelper(fieldObj),\n                    _step99;\n                  try {\n                    for (_iterator99.s(); !(_step99 = _iterator99.n()).done;) {\n                      var _step99$value = _step99.value,\n                        page = _step99$value.page,\n                        id = _step99$value.id,\n                        exportValues = _step99$value.exportValues;\n                      if (page === -1) {\n                        continue;\n                      }\n                      if (id === skipId) {\n                        continue;\n                      }\n                      var exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                      var domElement = document.querySelector(\"[data-element-id=\\\"\".concat(id, \"\\\"]\"));\n                      if (domElement && !GetElementsByNameSet.has(domElement)) {\n                        (0, _util.warn)(\"_getElementsByName - element not allowed: \".concat(id));\n                        continue;\n                      }\n                      fields.push({\n                        id: id,\n                        exportValue: exportValue,\n                        domElement: domElement\n                      });\n                    }\n                  } catch (err) {\n                    _iterator99.e(err);\n                  } finally {\n                    _iterator99.f();\n                  }\n                }\n                return fields;\n              }\n              var _iterator100 = _createForOfIteratorHelper(document.getElementsByName(name)),\n                _step100;\n              try {\n                for (_iterator100.s(); !(_step100 = _iterator100.n()).done;) {\n                  var _domElement = _step100.value;\n                  var _exportValue = _domElement.exportValue;\n                  var _id6 = _domElement.getAttribute(\"data-element-id\");\n                  if (_id6 === skipId) {\n                    continue;\n                  }\n                  if (!GetElementsByNameSet.has(_domElement)) {\n                    continue;\n                  }\n                  fields.push({\n                    id: _id6,\n                    exportValue: _exportValue,\n                    domElement: _domElement\n                  });\n                }\n              } catch (err) {\n                _iterator100.e(err);\n              } finally {\n                _iterator100.f();\n              }\n              return fields;\n            }\n          }]);\n          return AnnotationElement;\n        }();\n        var _setInternalLink = /*#__PURE__*/new WeakSet();\n        var _bindSetOCGState = /*#__PURE__*/new WeakSet();\n        var LinkAnnotationElement = /*#__PURE__*/function (_AnnotationElement) {\n          _inherits(LinkAnnotationElement, _AnnotationElement);\n          var _super28 = _createSuper(LinkAnnotationElement);\n          function LinkAnnotationElement(parameters) {\n            var _this64;\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            _classCallCheck(this, LinkAnnotationElement);\n            _this64 = _super28.call(this, parameters, {\n              isRenderable: true,\n              ignoreBorder: !!(options !== null && options !== void 0 && options.ignoreBorder),\n              createQuadrilaterals: true\n            });\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this64), _bindSetOCGState);\n            _classPrivateMethodInitSpec(_assertThisInitialized(_this64), _setInternalLink);\n            _this64.isTooltipOnly = parameters.data.isTooltipOnly;\n            return _this64;\n          }\n          _createClass(LinkAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              var data = this.data,\n                linkService = this.linkService;\n              var link = document.createElement(\"a\");\n              link.setAttribute(\"data-element-id\", data.id);\n              var isBound = false;\n              if (data.url) {\n                linkService.addLinkAttributes(link, data.url, data.newWindow);\n                isBound = true;\n              } else if (data.action) {\n                this._bindNamedAction(link, data.action);\n                isBound = true;\n              } else if (data.attachment) {\n                this._bindAttachment(link, data.attachment);\n                isBound = true;\n              } else if (data.setOCGState) {\n                _classPrivateMethodGet(this, _bindSetOCGState, _bindSetOCGState2).call(this, link, data.setOCGState);\n                isBound = true;\n              } else if (data.dest) {\n                this._bindLink(link, data.dest);\n                isBound = true;\n              } else {\n                if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                  this._bindJSAction(link, data);\n                  isBound = true;\n                }\n                if (data.resetForm) {\n                  this._bindResetFormAction(link, data.resetForm);\n                  isBound = true;\n                } else if (this.isTooltipOnly && !isBound) {\n                  this._bindLink(link, \"\");\n                  isBound = true;\n                }\n              }\n              if (this.quadrilaterals) {\n                return this._renderQuadrilaterals(\"linkAnnotation\").map(function (quadrilateral, index) {\n                  var linkElement = index === 0 ? link : link.cloneNode();\n                  quadrilateral.append(linkElement);\n                  return quadrilateral;\n                });\n              }\n              this.container.classList.add(\"linkAnnotation\");\n              if (isBound) {\n                this.container.append(link);\n              }\n              return this.container;\n            }\n          }, {\n            key: \"_bindLink\",\n            value: function _bindLink(link, destination) {\n              var _this65 = this;\n              link.href = this.linkService.getDestinationHash(destination);\n              link.onclick = function () {\n                if (destination) {\n                  _this65.linkService.goToDestination(destination);\n                }\n                return false;\n              };\n              if (destination || destination === \"\") {\n                _classPrivateMethodGet(this, _setInternalLink, _setInternalLink2).call(this);\n              }\n            }\n          }, {\n            key: \"_bindNamedAction\",\n            value: function _bindNamedAction(link, action) {\n              var _this66 = this;\n              link.href = this.linkService.getAnchorUrl(\"\");\n              link.onclick = function () {\n                _this66.linkService.executeNamedAction(action);\n                return false;\n              };\n              _classPrivateMethodGet(this, _setInternalLink, _setInternalLink2).call(this);\n            }\n          }, {\n            key: \"_bindAttachment\",\n            value: function _bindAttachment(link, attachment) {\n              var _this67 = this;\n              link.href = this.linkService.getAnchorUrl(\"\");\n              link.onclick = function () {\n                var _this67$downloadManag;\n                (_this67$downloadManag = _this67.downloadManager) === null || _this67$downloadManag === void 0 ? void 0 : _this67$downloadManag.openOrDownloadData(_this67.container, attachment.content, attachment.filename);\n                return false;\n              };\n              _classPrivateMethodGet(this, _setInternalLink, _setInternalLink2).call(this);\n            }\n          }, {\n            key: \"_bindJSAction\",\n            value: function _bindJSAction(link, data) {\n              var _this68 = this;\n              link.href = this.linkService.getAnchorUrl(\"\");\n              var map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n              var _loop = function _loop() {\n                var name = _Object$keys2[_i14];\n                var jsName = map.get(name);\n                if (!jsName) {\n                  return \"continue\";\n                }\n                link[jsName] = function () {\n                  var _this68$linkService$e;\n                  (_this68$linkService$e = _this68.linkService.eventBus) === null || _this68$linkService$e === void 0 ? void 0 : _this68$linkService$e.dispatch(\"dispatcheventinsandbox\", {\n                    source: _this68,\n                    detail: {\n                      id: data.id,\n                      name: name\n                    }\n                  });\n                  return false;\n                };\n              };\n              for (var _i14 = 0, _Object$keys2 = Object.keys(data.actions); _i14 < _Object$keys2.length; _i14++) {\n                var _ret = _loop();\n                if (_ret === \"continue\") continue;\n              }\n              if (!link.onclick) {\n                link.onclick = function () {\n                  return false;\n                };\n              }\n              _classPrivateMethodGet(this, _setInternalLink, _setInternalLink2).call(this);\n            }\n          }, {\n            key: \"_bindResetFormAction\",\n            value: function _bindResetFormAction(link, resetForm) {\n              var _this69 = this;\n              var otherClickAction = link.onclick;\n              if (!otherClickAction) {\n                link.href = this.linkService.getAnchorUrl(\"\");\n              }\n              _classPrivateMethodGet(this, _setInternalLink, _setInternalLink2).call(this);\n              if (!this._fieldObjects) {\n                (0, _util.warn)(\"_bindResetFormAction - \\\"resetForm\\\" action not supported, \" + \"ensure that the `fieldObjects` parameter is provided.\");\n                if (!otherClickAction) {\n                  link.onclick = function () {\n                    return false;\n                  };\n                }\n                return;\n              }\n              link.onclick = function () {\n                otherClickAction === null || otherClickAction === void 0 ? void 0 : otherClickAction();\n                var resetFormFields = resetForm.fields,\n                  resetFormRefs = resetForm.refs,\n                  include = resetForm.include;\n                var allFields = [];\n                if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                  var fieldIds = new Set(resetFormRefs);\n                  var _iterator101 = _createForOfIteratorHelper(resetFormFields),\n                    _step101;\n                  try {\n                    for (_iterator101.s(); !(_step101 = _iterator101.n()).done;) {\n                      var fieldName = _step101.value;\n                      var _fields = _this69._fieldObjects[fieldName] || [];\n                      var _iterator103 = _createForOfIteratorHelper(_fields),\n                        _step103;\n                      try {\n                        for (_iterator103.s(); !(_step103 = _iterator103.n()).done;) {\n                          var id = _step103.value.id;\n                          fieldIds.add(id);\n                        }\n                      } catch (err) {\n                        _iterator103.e(err);\n                      } finally {\n                        _iterator103.f();\n                      }\n                    }\n                  } catch (err) {\n                    _iterator101.e(err);\n                  } finally {\n                    _iterator101.f();\n                  }\n                  for (var _i15 = 0, _Object$values = Object.values(_this69._fieldObjects); _i15 < _Object$values.length; _i15++) {\n                    var fields = _Object$values[_i15];\n                    var _iterator102 = _createForOfIteratorHelper(fields),\n                      _step102;\n                    try {\n                      for (_iterator102.s(); !(_step102 = _iterator102.n()).done;) {\n                        var field = _step102.value;\n                        if (fieldIds.has(field.id) === include) {\n                          allFields.push(field);\n                        }\n                      }\n                    } catch (err) {\n                      _iterator102.e(err);\n                    } finally {\n                      _iterator102.f();\n                    }\n                  }\n                } else {\n                  for (var _i16 = 0, _Object$values2 = Object.values(_this69._fieldObjects); _i16 < _Object$values2.length; _i16++) {\n                    var _fields2 = _Object$values2[_i16];\n                    allFields.push.apply(allFields, _toConsumableArray(_fields2));\n                  }\n                }\n                var storage = _this69.annotationStorage;\n                var allIds = [];\n                for (var _i17 = 0, _allFields = allFields; _i17 < _allFields.length; _i17++) {\n                  var _field = _allFields[_i17];\n                  var _id7 = _field.id;\n                  allIds.push(_id7);\n                  switch (_field.type) {\n                    case \"text\":\n                      {\n                        var value = _field.defaultValue || \"\";\n                        storage.setValue(_id7, {\n                          value: value\n                        });\n                        break;\n                      }\n                    case \"checkbox\":\n                    case \"radiobutton\":\n                      {\n                        var _value = _field.defaultValue === _field.exportValues;\n                        storage.setValue(_id7, {\n                          value: _value\n                        });\n                        break;\n                      }\n                    case \"combobox\":\n                    case \"listbox\":\n                      {\n                        var _value2 = _field.defaultValue || \"\";\n                        storage.setValue(_id7, {\n                          value: _value2\n                        });\n                        break;\n                      }\n                    default:\n                      continue;\n                  }\n                  var domElement = document.querySelector(\"[data-element-id=\\\"\".concat(_id7, \"\\\"]\"));\n                  if (!domElement) {\n                    continue;\n                  } else if (!GetElementsByNameSet.has(domElement)) {\n                    (0, _util.warn)(\"_bindResetFormAction - element not allowed: \".concat(_id7));\n                    continue;\n                  }\n                  domElement.dispatchEvent(new Event(\"resetform\"));\n                }\n                if (_this69.enableScripting) {\n                  var _this69$linkService$e;\n                  (_this69$linkService$e = _this69.linkService.eventBus) === null || _this69$linkService$e === void 0 ? void 0 : _this69$linkService$e.dispatch(\"dispatcheventinsandbox\", {\n                    source: _this69,\n                    detail: {\n                      id: \"app\",\n                      ids: allIds,\n                      name: \"ResetForm\"\n                    }\n                  });\n                }\n                return false;\n              };\n            }\n          }]);\n          return LinkAnnotationElement;\n        }(AnnotationElement);\n        function _setInternalLink2() {\n          this.container.setAttribute(\"data-internal-link\", \"\");\n        }\n        function _bindSetOCGState2(link, action) {\n          var _this81 = this;\n          link.href = this.linkService.getAnchorUrl(\"\");\n          link.onclick = function () {\n            _this81.linkService.executeSetOCGState(action);\n            return false;\n          };\n          _classPrivateMethodGet(this, _setInternalLink, _setInternalLink2).call(this);\n        }\n        var TextAnnotationElement = /*#__PURE__*/function (_AnnotationElement2) {\n          _inherits(TextAnnotationElement, _AnnotationElement2);\n          var _super29 = _createSuper(TextAnnotationElement);\n          function TextAnnotationElement(parameters) {\n            var _parameters$data$titl, _parameters$data$cont, _parameters$data$rich;\n            _classCallCheck(this, TextAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl = parameters.data.titleObj) !== null && _parameters$data$titl !== void 0 && _parameters$data$titl.str || (_parameters$data$cont = parameters.data.contentsObj) !== null && _parameters$data$cont !== void 0 && _parameters$data$cont.str || (_parameters$data$rich = parameters.data.richText) !== null && _parameters$data$rich !== void 0 && _parameters$data$rich.str);\n            return _super29.call(this, parameters, {\n              isRenderable: isRenderable\n            });\n          }\n          _createClass(TextAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(\"textAnnotation\");\n              var image = document.createElement(\"img\");\n              image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n              image.alt = \"[{{type}} Annotation]\";\n              image.dataset.l10nId = \"text_annotation_type\";\n              image.dataset.l10nArgs = JSON.stringify({\n                type: this.data.name\n              });\n              if (!this.data.hasPopup) {\n                this._createPopup(image, this.data);\n              }\n              this.container.append(image);\n              return this.container;\n            }\n          }]);\n          return TextAnnotationElement;\n        }(AnnotationElement);\n        var WidgetAnnotationElement = /*#__PURE__*/function (_AnnotationElement3) {\n          _inherits(WidgetAnnotationElement, _AnnotationElement3);\n          var _super30 = _createSuper(WidgetAnnotationElement);\n          function WidgetAnnotationElement() {\n            _classCallCheck(this, WidgetAnnotationElement);\n            return _super30.apply(this, arguments);\n          }\n          _createClass(WidgetAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              if (this.data.alternativeText) {\n                this.container.title = this.data.alternativeText;\n              }\n              return this.container;\n            }\n          }, {\n            key: \"showElementAndHideCanvas\",\n            value: function showElementAndHideCanvas(element) {\n              if (this.data.hasOwnCanvas) {\n                var _element$previousSibl;\n                if (((_element$previousSibl = element.previousSibling) === null || _element$previousSibl === void 0 ? void 0 : _element$previousSibl.nodeName) === \"CANVAS\") {\n                  element.previousSibling.hidden = true;\n                }\n                element.hidden = false;\n              }\n            }\n          }, {\n            key: \"_getKeyModifier\",\n            value: function _getKeyModifier(event) {\n              var _util$FeatureTest$pla = _util.FeatureTest.platform,\n                isWin = _util$FeatureTest$pla.isWin,\n                isMac = _util$FeatureTest$pla.isMac;\n              return isWin && event.ctrlKey || isMac && event.metaKey;\n            }\n          }, {\n            key: \"_setEventListener\",\n            value: function _setEventListener(element, baseName, eventName, valueGetter) {\n              var _this70 = this;\n              if (baseName.includes(\"mouse\")) {\n                element.addEventListener(baseName, function (event) {\n                  var _this70$linkService$e;\n                  (_this70$linkService$e = _this70.linkService.eventBus) === null || _this70$linkService$e === void 0 ? void 0 : _this70$linkService$e.dispatch(\"dispatcheventinsandbox\", {\n                    source: _this70,\n                    detail: {\n                      id: _this70.data.id,\n                      name: eventName,\n                      value: valueGetter(event),\n                      shift: event.shiftKey,\n                      modifier: _this70._getKeyModifier(event)\n                    }\n                  });\n                });\n              } else {\n                element.addEventListener(baseName, function (event) {\n                  var _this70$linkService$e2;\n                  (_this70$linkService$e2 = _this70.linkService.eventBus) === null || _this70$linkService$e2 === void 0 ? void 0 : _this70$linkService$e2.dispatch(\"dispatcheventinsandbox\", {\n                    source: _this70,\n                    detail: {\n                      id: _this70.data.id,\n                      name: eventName,\n                      value: valueGetter(event)\n                    }\n                  });\n                });\n              }\n            }\n          }, {\n            key: \"_setEventListeners\",\n            value: function _setEventListeners(element, names, getter) {\n              var _iterator104 = _createForOfIteratorHelper(names),\n                _step104;\n              try {\n                for (_iterator104.s(); !(_step104 = _iterator104.n()).done;) {\n                  var _this$data$actions;\n                  var _step104$value = _slicedToArray(_step104.value, 2),\n                    baseName = _step104$value[0],\n                    eventName = _step104$value[1];\n                  if (eventName === \"Action\" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {\n                    this._setEventListener(element, baseName, eventName, getter);\n                  }\n                }\n              } catch (err) {\n                _iterator104.e(err);\n              } finally {\n                _iterator104.f();\n              }\n            }\n          }, {\n            key: \"_setBackgroundColor\",\n            value: function _setBackgroundColor(element) {\n              var color = this.data.backgroundColor || null;\n              element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n            }\n          }, {\n            key: \"_setTextStyle\",\n            value: function _setTextStyle(element) {\n              var TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n              var fontColor = this.data.defaultAppearanceData.fontColor;\n              var fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;\n              var style = element.style;\n              var computedFontSize;\n              var BORDER_SIZE = 2;\n              var roundToOneDecimal = function roundToOneDecimal(x) {\n                return Math.round(10 * x) / 10;\n              };\n              if (this.data.multiLine) {\n                var height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n                var numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;\n                var lineHeight = height / numberOfLines;\n                computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util.LINE_FACTOR));\n              } else {\n                var _height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n                computedFontSize = Math.min(fontSize, roundToOneDecimal(_height / _util.LINE_FACTOR));\n              }\n              style.fontSize = \"calc(\".concat(computedFontSize, \"px * var(--scale-factor))\");\n              style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n              if (this.data.textAlignment !== null) {\n                style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n              }\n            }\n          }, {\n            key: \"_setRequired\",\n            value: function _setRequired(element, isRequired) {\n              if (isRequired) {\n                element.setAttribute(\"required\", true);\n              } else {\n                element.removeAttribute(\"required\");\n              }\n              element.setAttribute(\"aria-required\", isRequired);\n            }\n          }]);\n          return WidgetAnnotationElement;\n        }(AnnotationElement);\n        var TextWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem) {\n          _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);\n          var _super31 = _createSuper(TextWidgetAnnotationElement);\n          function TextWidgetAnnotationElement(parameters) {\n            _classCallCheck(this, TextWidgetAnnotationElement);\n            var isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n            return _super31.call(this, parameters, {\n              isRenderable: isRenderable\n            });\n          }\n          _createClass(TextWidgetAnnotationElement, [{\n            key: \"setPropertyOnSiblings\",\n            value: function setPropertyOnSiblings(base, key, value, keyInStorage) {\n              var storage = this.annotationStorage;\n              var _iterator105 = _createForOfIteratorHelper(this._getElementsByName(base.name, base.id)),\n                _step105;\n              try {\n                for (_iterator105.s(); !(_step105 = _iterator105.n()).done;) {\n                  var element = _step105.value;\n                  if (element.domElement) {\n                    element.domElement[key] = value;\n                  }\n                  storage.setValue(element.id, _defineProperty({}, keyInStorage, value));\n                }\n              } catch (err) {\n                _iterator105.e(err);\n              } finally {\n                _iterator105.f();\n              }\n            }\n          }, {\n            key: \"render\",\n            value: function render() {\n              var _this71 = this;\n              var storage = this.annotationStorage;\n              var id = this.data.id;\n              this.container.classList.add(\"textWidgetAnnotation\");\n              var element = null;\n              if (this.renderForms) {\n                var storedData = storage.getValue(id, {\n                  value: this.data.fieldValue\n                });\n                var textContent = storedData.formattedValue || storedData.value || \"\";\n                var maxLen = storage.getValue(id, {\n                  charLimit: this.data.maxLen\n                }).charLimit;\n                if (maxLen && textContent.length > maxLen) {\n                  textContent = textContent.slice(0, maxLen);\n                }\n                var elementData = {\n                  userValue: textContent,\n                  formattedValue: null,\n                  lastCommittedValue: null,\n                  commitKey: 1\n                };\n                if (this.data.multiLine) {\n                  element = document.createElement(\"textarea\");\n                  element.textContent = textContent;\n                  if (this.data.doNotScroll) {\n                    element.style.overflowY = \"hidden\";\n                  }\n                } else {\n                  element = document.createElement(\"input\");\n                  element.type = \"text\";\n                  element.setAttribute(\"value\", textContent);\n                  if (this.data.doNotScroll) {\n                    element.style.overflowX = \"hidden\";\n                  }\n                }\n                if (this.data.hasOwnCanvas) {\n                  element.hidden = true;\n                }\n                GetElementsByNameSet.add(element);\n                element.setAttribute(\"data-element-id\", id);\n                element.disabled = this.data.readOnly;\n                element.name = this.data.fieldName;\n                element.tabIndex = DEFAULT_TAB_INDEX;\n                this._setRequired(element, this.data.required);\n                if (maxLen) {\n                  element.maxLength = maxLen;\n                }\n                element.addEventListener(\"input\", function (event) {\n                  storage.setValue(id, {\n                    value: event.target.value\n                  });\n                  _this71.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                });\n                element.addEventListener(\"resetform\", function (event) {\n                  var _this71$data$defaultF;\n                  var defaultValue = (_this71$data$defaultF = _this71.data.defaultFieldValue) !== null && _this71$data$defaultF !== void 0 ? _this71$data$defaultF : \"\";\n                  element.value = elementData.userValue = defaultValue;\n                  elementData.formattedValue = null;\n                });\n                var blurListener = function blurListener(event) {\n                  var formattedValue = elementData.formattedValue;\n                  if (formattedValue !== null && formattedValue !== undefined) {\n                    event.target.value = formattedValue;\n                  }\n                  event.target.scrollLeft = 0;\n                };\n                if (this.enableScripting && this.hasJSActions) {\n                  var _this$data$actions2;\n                  element.addEventListener(\"focus\", function (event) {\n                    var target = event.target;\n                    if (elementData.userValue) {\n                      target.value = elementData.userValue;\n                    }\n                    elementData.lastCommittedValue = target.value;\n                    elementData.commitKey = 1;\n                  });\n                  element.addEventListener(\"updatefromsandbox\", function (jsEvent) {\n                    _this71.showElementAndHideCanvas(jsEvent.target);\n                    var actions = {\n                      value: function value(event) {\n                        var _event$detail$value;\n                        elementData.userValue = (_event$detail$value = event.detail.value) !== null && _event$detail$value !== void 0 ? _event$detail$value : \"\";\n                        storage.setValue(id, {\n                          value: elementData.userValue.toString()\n                        });\n                        event.target.value = elementData.userValue;\n                      },\n                      formattedValue: function formattedValue(event) {\n                        var formattedValue = event.detail.formattedValue;\n                        elementData.formattedValue = formattedValue;\n                        if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                          event.target.value = formattedValue;\n                        }\n                        storage.setValue(id, {\n                          formattedValue: formattedValue\n                        });\n                      },\n                      selRange: function selRange(event) {\n                        var _event$target;\n                        (_event$target = event.target).setSelectionRange.apply(_event$target, _toConsumableArray(event.detail.selRange));\n                      },\n                      charLimit: function charLimit(event) {\n                        var _this71$linkService$e;\n                        var charLimit = event.detail.charLimit;\n                        var target = event.target;\n                        if (charLimit === 0) {\n                          target.removeAttribute(\"maxLength\");\n                          return;\n                        }\n                        target.setAttribute(\"maxLength\", charLimit);\n                        var value = elementData.userValue;\n                        if (!value || value.length <= charLimit) {\n                          return;\n                        }\n                        value = value.slice(0, charLimit);\n                        target.value = elementData.userValue = value;\n                        storage.setValue(id, {\n                          value: value\n                        });\n                        (_this71$linkService$e = _this71.linkService.eventBus) === null || _this71$linkService$e === void 0 ? void 0 : _this71$linkService$e.dispatch(\"dispatcheventinsandbox\", {\n                          source: _this71,\n                          detail: {\n                            id: id,\n                            name: \"Keystroke\",\n                            value: value,\n                            willCommit: true,\n                            commitKey: 1,\n                            selStart: target.selectionStart,\n                            selEnd: target.selectionEnd\n                          }\n                        });\n                      }\n                    };\n                    _this71._dispatchEventFromSandbox(actions, jsEvent);\n                  });\n                  element.addEventListener(\"keydown\", function (event) {\n                    var _this71$linkService$e2;\n                    elementData.commitKey = 1;\n                    var commitKey = -1;\n                    if (event.key === \"Escape\") {\n                      commitKey = 0;\n                    } else if (event.key === \"Enter\" && !_this71.data.multiLine) {\n                      commitKey = 2;\n                    } else if (event.key === \"Tab\") {\n                      elementData.commitKey = 3;\n                    }\n                    if (commitKey === -1) {\n                      return;\n                    }\n                    var value = event.target.value;\n                    if (elementData.lastCommittedValue === value) {\n                      return;\n                    }\n                    elementData.lastCommittedValue = value;\n                    elementData.userValue = value;\n                    (_this71$linkService$e2 = _this71.linkService.eventBus) === null || _this71$linkService$e2 === void 0 ? void 0 : _this71$linkService$e2.dispatch(\"dispatcheventinsandbox\", {\n                      source: _this71,\n                      detail: {\n                        id: id,\n                        name: \"Keystroke\",\n                        value: value,\n                        willCommit: true,\n                        commitKey: commitKey,\n                        selStart: event.target.selectionStart,\n                        selEnd: event.target.selectionEnd\n                      }\n                    });\n                  });\n                  var _blurListener = blurListener;\n                  blurListener = null;\n                  element.addEventListener(\"blur\", function (event) {\n                    if (!event.relatedTarget) {\n                      return;\n                    }\n                    var value = event.target.value;\n                    elementData.userValue = value;\n                    if (elementData.lastCommittedValue !== value) {\n                      var _this71$linkService$e3;\n                      (_this71$linkService$e3 = _this71.linkService.eventBus) === null || _this71$linkService$e3 === void 0 ? void 0 : _this71$linkService$e3.dispatch(\"dispatcheventinsandbox\", {\n                        source: _this71,\n                        detail: {\n                          id: id,\n                          name: \"Keystroke\",\n                          value: value,\n                          willCommit: true,\n                          commitKey: elementData.commitKey,\n                          selStart: event.target.selectionStart,\n                          selEnd: event.target.selectionEnd\n                        }\n                      });\n                    }\n                    _blurListener(event);\n                  });\n                  if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {\n                    element.addEventListener(\"beforeinput\", function (event) {\n                      var _this71$linkService$e4;\n                      elementData.lastCommittedValue = null;\n                      var data = event.data,\n                        target = event.target;\n                      var value = target.value,\n                        selectionStart = target.selectionStart,\n                        selectionEnd = target.selectionEnd;\n                      var selStart = selectionStart,\n                        selEnd = selectionEnd;\n                      switch (event.inputType) {\n                        case \"deleteWordBackward\":\n                          {\n                            var match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                            if (match) {\n                              selStart -= match[0].length;\n                            }\n                            break;\n                          }\n                        case \"deleteWordForward\":\n                          {\n                            var _match3 = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                            if (_match3) {\n                              selEnd += _match3[0].length;\n                            }\n                            break;\n                          }\n                        case \"deleteContentBackward\":\n                          if (selectionStart === selectionEnd) {\n                            selStart -= 1;\n                          }\n                          break;\n                        case \"deleteContentForward\":\n                          if (selectionStart === selectionEnd) {\n                            selEnd += 1;\n                          }\n                          break;\n                      }\n                      event.preventDefault();\n                      (_this71$linkService$e4 = _this71.linkService.eventBus) === null || _this71$linkService$e4 === void 0 ? void 0 : _this71$linkService$e4.dispatch(\"dispatcheventinsandbox\", {\n                        source: _this71,\n                        detail: {\n                          id: id,\n                          name: \"Keystroke\",\n                          value: value,\n                          change: data || \"\",\n                          willCommit: false,\n                          selStart: selStart,\n                          selEnd: selEnd\n                        }\n                      });\n                    });\n                  }\n                  this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], function (event) {\n                    return event.target.value;\n                  });\n                }\n                if (blurListener) {\n                  element.addEventListener(\"blur\", blurListener);\n                }\n                if (this.data.comb) {\n                  var fieldWidth = this.data.rect[2] - this.data.rect[0];\n                  var combWidth = fieldWidth / maxLen;\n                  element.classList.add(\"comb\");\n                  element.style.letterSpacing = \"calc(\".concat(combWidth, \"px * var(--scale-factor) - 1ch)\");\n                }\n              } else {\n                element = document.createElement(\"div\");\n                element.textContent = this.data.fieldValue;\n                element.style.verticalAlign = \"middle\";\n                element.style.display = \"table-cell\";\n              }\n              this._setTextStyle(element);\n              this._setBackgroundColor(element);\n              this._setDefaultPropertiesFromJS(element);\n              this.container.append(element);\n              return this.container;\n            }\n          }]);\n          return TextWidgetAnnotationElement;\n        }(WidgetAnnotationElement);\n        var CheckboxWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem2) {\n          _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2);\n          var _super32 = _createSuper(CheckboxWidgetAnnotationElement);\n          function CheckboxWidgetAnnotationElement(parameters) {\n            _classCallCheck(this, CheckboxWidgetAnnotationElement);\n            return _super32.call(this, parameters, {\n              isRenderable: parameters.renderForms\n            });\n          }\n          _createClass(CheckboxWidgetAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              var _this72 = this;\n              var storage = this.annotationStorage;\n              var data = this.data;\n              var id = data.id;\n              var value = storage.getValue(id, {\n                value: data.exportValue === data.fieldValue\n              }).value;\n              if (typeof value === \"string\") {\n                value = value !== \"Off\";\n                storage.setValue(id, {\n                  value: value\n                });\n              }\n              this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n              var element = document.createElement(\"input\");\n              GetElementsByNameSet.add(element);\n              element.setAttribute(\"data-element-id\", id);\n              element.disabled = data.readOnly;\n              this._setRequired(element, this.data.required);\n              element.type = \"checkbox\";\n              element.name = data.fieldName;\n              if (value) {\n                element.setAttribute(\"checked\", true);\n              }\n              element.setAttribute(\"exportValue\", data.exportValue);\n              element.tabIndex = DEFAULT_TAB_INDEX;\n              element.addEventListener(\"change\", function (event) {\n                var _event$target2 = event.target,\n                  name = _event$target2.name,\n                  checked = _event$target2.checked;\n                var _iterator106 = _createForOfIteratorHelper(_this72._getElementsByName(name, id)),\n                  _step106;\n                try {\n                  for (_iterator106.s(); !(_step106 = _iterator106.n()).done;) {\n                    var checkbox = _step106.value;\n                    var curChecked = checked && checkbox.exportValue === data.exportValue;\n                    if (checkbox.domElement) {\n                      checkbox.domElement.checked = curChecked;\n                    }\n                    storage.setValue(checkbox.id, {\n                      value: curChecked\n                    });\n                  }\n                } catch (err) {\n                  _iterator106.e(err);\n                } finally {\n                  _iterator106.f();\n                }\n                storage.setValue(id, {\n                  value: checked\n                });\n              });\n              element.addEventListener(\"resetform\", function (event) {\n                var defaultValue = data.defaultFieldValue || \"Off\";\n                event.target.checked = defaultValue === data.exportValue;\n              });\n              if (this.enableScripting && this.hasJSActions) {\n                element.addEventListener(\"updatefromsandbox\", function (jsEvent) {\n                  var actions = {\n                    value: function value(event) {\n                      event.target.checked = event.detail.value !== \"Off\";\n                      storage.setValue(id, {\n                        value: event.target.checked\n                      });\n                    }\n                  };\n                  _this72._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], function (event) {\n                  return event.target.checked;\n                });\n              }\n              this._setBackgroundColor(element);\n              this._setDefaultPropertiesFromJS(element);\n              this.container.append(element);\n              return this.container;\n            }\n          }]);\n          return CheckboxWidgetAnnotationElement;\n        }(WidgetAnnotationElement);\n        var RadioButtonWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem3) {\n          _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3);\n          var _super33 = _createSuper(RadioButtonWidgetAnnotationElement);\n          function RadioButtonWidgetAnnotationElement(parameters) {\n            _classCallCheck(this, RadioButtonWidgetAnnotationElement);\n            return _super33.call(this, parameters, {\n              isRenderable: parameters.renderForms\n            });\n          }\n          _createClass(RadioButtonWidgetAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              var _this73 = this;\n              this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n              var storage = this.annotationStorage;\n              var data = this.data;\n              var id = data.id;\n              var value = storage.getValue(id, {\n                value: data.fieldValue === data.buttonValue\n              }).value;\n              if (typeof value === \"string\") {\n                value = value !== data.buttonValue;\n                storage.setValue(id, {\n                  value: value\n                });\n              }\n              var element = document.createElement(\"input\");\n              GetElementsByNameSet.add(element);\n              element.setAttribute(\"data-element-id\", id);\n              element.disabled = data.readOnly;\n              this._setRequired(element, this.data.required);\n              element.type = \"radio\";\n              element.name = data.fieldName;\n              if (value) {\n                element.setAttribute(\"checked\", true);\n              }\n              element.tabIndex = DEFAULT_TAB_INDEX;\n              element.addEventListener(\"change\", function (event) {\n                var _event$target3 = event.target,\n                  name = _event$target3.name,\n                  checked = _event$target3.checked;\n                var _iterator107 = _createForOfIteratorHelper(_this73._getElementsByName(name, id)),\n                  _step107;\n                try {\n                  for (_iterator107.s(); !(_step107 = _iterator107.n()).done;) {\n                    var radio = _step107.value;\n                    storage.setValue(radio.id, {\n                      value: false\n                    });\n                  }\n                } catch (err) {\n                  _iterator107.e(err);\n                } finally {\n                  _iterator107.f();\n                }\n                storage.setValue(id, {\n                  value: checked\n                });\n              });\n              element.addEventListener(\"resetform\", function (event) {\n                var defaultValue = data.defaultFieldValue;\n                event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n              });\n              if (this.enableScripting && this.hasJSActions) {\n                var pdfButtonValue = data.buttonValue;\n                element.addEventListener(\"updatefromsandbox\", function (jsEvent) {\n                  var actions = {\n                    value: function value(event) {\n                      var checked = pdfButtonValue === event.detail.value;\n                      var _iterator108 = _createForOfIteratorHelper(_this73._getElementsByName(event.target.name)),\n                        _step108;\n                      try {\n                        for (_iterator108.s(); !(_step108 = _iterator108.n()).done;) {\n                          var radio = _step108.value;\n                          var curChecked = checked && radio.id === id;\n                          if (radio.domElement) {\n                            radio.domElement.checked = curChecked;\n                          }\n                          storage.setValue(radio.id, {\n                            value: curChecked\n                          });\n                        }\n                      } catch (err) {\n                        _iterator108.e(err);\n                      } finally {\n                        _iterator108.f();\n                      }\n                    }\n                  };\n                  _this73._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], function (event) {\n                  return event.target.checked;\n                });\n              }\n              this._setBackgroundColor(element);\n              this._setDefaultPropertiesFromJS(element);\n              this.container.append(element);\n              return this.container;\n            }\n          }]);\n          return RadioButtonWidgetAnnotationElement;\n        }(WidgetAnnotationElement);\n        var PushButtonWidgetAnnotationElement = /*#__PURE__*/function (_LinkAnnotationElemen) {\n          _inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen);\n          var _super34 = _createSuper(PushButtonWidgetAnnotationElement);\n          function PushButtonWidgetAnnotationElement(parameters) {\n            _classCallCheck(this, PushButtonWidgetAnnotationElement);\n            return _super34.call(this, parameters, {\n              ignoreBorder: parameters.data.hasAppearance\n            });\n          }\n          _createClass(PushButtonWidgetAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              var _this74 = this;\n              var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement.prototype), \"render\", this).call(this);\n              container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n              if (this.data.alternativeText) {\n                container.title = this.data.alternativeText;\n              }\n              var linkElement = container.lastChild;\n              if (this.enableScripting && this.hasJSActions && linkElement) {\n                this._setDefaultPropertiesFromJS(linkElement);\n                linkElement.addEventListener(\"updatefromsandbox\", function (jsEvent) {\n                  _this74._dispatchEventFromSandbox({}, jsEvent);\n                });\n              }\n              return container;\n            }\n          }]);\n          return PushButtonWidgetAnnotationElement;\n        }(LinkAnnotationElement);\n        var ChoiceWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem4) {\n          _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4);\n          var _super35 = _createSuper(ChoiceWidgetAnnotationElement);\n          function ChoiceWidgetAnnotationElement(parameters) {\n            _classCallCheck(this, ChoiceWidgetAnnotationElement);\n            return _super35.call(this, parameters, {\n              isRenderable: parameters.renderForms\n            });\n          }\n          _createClass(ChoiceWidgetAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              var _this75 = this;\n              this.container.classList.add(\"choiceWidgetAnnotation\");\n              var storage = this.annotationStorage;\n              var id = this.data.id;\n              var storedData = storage.getValue(id, {\n                value: this.data.fieldValue\n              });\n              var selectElement = document.createElement(\"select\");\n              GetElementsByNameSet.add(selectElement);\n              selectElement.setAttribute(\"data-element-id\", id);\n              selectElement.disabled = this.data.readOnly;\n              this._setRequired(selectElement, this.data.required);\n              selectElement.name = this.data.fieldName;\n              selectElement.tabIndex = DEFAULT_TAB_INDEX;\n              var addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n              if (!this.data.combo) {\n                selectElement.size = this.data.options.length;\n                if (this.data.multiSelect) {\n                  selectElement.multiple = true;\n                }\n              }\n              selectElement.addEventListener(\"resetform\", function (event) {\n                var defaultValue = _this75.data.defaultFieldValue;\n                var _iterator109 = _createForOfIteratorHelper(selectElement.options),\n                  _step109;\n                try {\n                  for (_iterator109.s(); !(_step109 = _iterator109.n()).done;) {\n                    var option = _step109.value;\n                    option.selected = option.value === defaultValue;\n                  }\n                } catch (err) {\n                  _iterator109.e(err);\n                } finally {\n                  _iterator109.f();\n                }\n              });\n              var _iterator110 = _createForOfIteratorHelper(this.data.options),\n                _step110;\n              try {\n                for (_iterator110.s(); !(_step110 = _iterator110.n()).done;) {\n                  var option = _step110.value;\n                  var optionElement = document.createElement(\"option\");\n                  optionElement.textContent = option.displayValue;\n                  optionElement.value = option.exportValue;\n                  if (storedData.value.includes(option.exportValue)) {\n                    optionElement.setAttribute(\"selected\", true);\n                    addAnEmptyEntry = false;\n                  }\n                  selectElement.append(optionElement);\n                }\n              } catch (err) {\n                _iterator110.e(err);\n              } finally {\n                _iterator110.f();\n              }\n              var _removeEmptyEntry = null;\n              if (addAnEmptyEntry) {\n                var noneOptionElement = document.createElement(\"option\");\n                noneOptionElement.value = \" \";\n                noneOptionElement.setAttribute(\"hidden\", true);\n                noneOptionElement.setAttribute(\"selected\", true);\n                selectElement.prepend(noneOptionElement);\n                _removeEmptyEntry = function removeEmptyEntry() {\n                  noneOptionElement.remove();\n                  selectElement.removeEventListener(\"input\", _removeEmptyEntry);\n                  _removeEmptyEntry = null;\n                };\n                selectElement.addEventListener(\"input\", _removeEmptyEntry);\n              }\n              var getValue = function getValue(isExport) {\n                var name = isExport ? \"value\" : \"textContent\";\n                var options = selectElement.options,\n                  multiple = selectElement.multiple;\n                if (!multiple) {\n                  return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n                }\n                return Array.prototype.filter.call(options, function (option) {\n                  return option.selected;\n                }).map(function (option) {\n                  return option[name];\n                });\n              };\n              var selectedValues = getValue(false);\n              var getItems = function getItems(event) {\n                var options = event.target.options;\n                return Array.prototype.map.call(options, function (option) {\n                  return {\n                    displayValue: option.textContent,\n                    exportValue: option.value\n                  };\n                });\n              };\n              if (this.enableScripting && this.hasJSActions) {\n                selectElement.addEventListener(\"updatefromsandbox\", function (jsEvent) {\n                  var actions = {\n                    value: function value(event) {\n                      var _removeEmptyEntry2;\n                      (_removeEmptyEntry2 = _removeEmptyEntry) === null || _removeEmptyEntry2 === void 0 ? void 0 : _removeEmptyEntry2();\n                      var value = event.detail.value;\n                      var values = new Set(Array.isArray(value) ? value : [value]);\n                      var _iterator111 = _createForOfIteratorHelper(selectElement.options),\n                        _step111;\n                      try {\n                        for (_iterator111.s(); !(_step111 = _iterator111.n()).done;) {\n                          var option = _step111.value;\n                          option.selected = values.has(option.value);\n                        }\n                      } catch (err) {\n                        _iterator111.e(err);\n                      } finally {\n                        _iterator111.f();\n                      }\n                      storage.setValue(id, {\n                        value: getValue(true)\n                      });\n                      selectedValues = getValue(false);\n                    },\n                    multipleSelection: function multipleSelection(event) {\n                      selectElement.multiple = true;\n                    },\n                    remove: function remove(event) {\n                      var options = selectElement.options;\n                      var index = event.detail.remove;\n                      options[index].selected = false;\n                      selectElement.remove(index);\n                      if (options.length > 0) {\n                        var i = Array.prototype.findIndex.call(options, function (option) {\n                          return option.selected;\n                        });\n                        if (i === -1) {\n                          options[0].selected = true;\n                        }\n                      }\n                      storage.setValue(id, {\n                        value: getValue(true),\n                        items: getItems(event)\n                      });\n                      selectedValues = getValue(false);\n                    },\n                    clear: function clear(event) {\n                      while (selectElement.length !== 0) {\n                        selectElement.remove(0);\n                      }\n                      storage.setValue(id, {\n                        value: null,\n                        items: []\n                      });\n                      selectedValues = getValue(false);\n                    },\n                    insert: function insert(event) {\n                      var _event$detail$insert = event.detail.insert,\n                        index = _event$detail$insert.index,\n                        displayValue = _event$detail$insert.displayValue,\n                        exportValue = _event$detail$insert.exportValue;\n                      var selectChild = selectElement.children[index];\n                      var optionElement = document.createElement(\"option\");\n                      optionElement.textContent = displayValue;\n                      optionElement.value = exportValue;\n                      if (selectChild) {\n                        selectChild.before(optionElement);\n                      } else {\n                        selectElement.append(optionElement);\n                      }\n                      storage.setValue(id, {\n                        value: getValue(true),\n                        items: getItems(event)\n                      });\n                      selectedValues = getValue(false);\n                    },\n                    items: function items(event) {\n                      var items = event.detail.items;\n                      while (selectElement.length !== 0) {\n                        selectElement.remove(0);\n                      }\n                      var _iterator112 = _createForOfIteratorHelper(items),\n                        _step112;\n                      try {\n                        for (_iterator112.s(); !(_step112 = _iterator112.n()).done;) {\n                          var item = _step112.value;\n                          var displayValue = item.displayValue,\n                            exportValue = item.exportValue;\n                          var optionElement = document.createElement(\"option\");\n                          optionElement.textContent = displayValue;\n                          optionElement.value = exportValue;\n                          selectElement.append(optionElement);\n                        }\n                      } catch (err) {\n                        _iterator112.e(err);\n                      } finally {\n                        _iterator112.f();\n                      }\n                      if (selectElement.options.length > 0) {\n                        selectElement.options[0].selected = true;\n                      }\n                      storage.setValue(id, {\n                        value: getValue(true),\n                        items: getItems(event)\n                      });\n                      selectedValues = getValue(false);\n                    },\n                    indices: function indices(event) {\n                      var indices = new Set(event.detail.indices);\n                      var _iterator113 = _createForOfIteratorHelper(event.target.options),\n                        _step113;\n                      try {\n                        for (_iterator113.s(); !(_step113 = _iterator113.n()).done;) {\n                          var option = _step113.value;\n                          option.selected = indices.has(option.index);\n                        }\n                      } catch (err) {\n                        _iterator113.e(err);\n                      } finally {\n                        _iterator113.f();\n                      }\n                      storage.setValue(id, {\n                        value: getValue(true)\n                      });\n                      selectedValues = getValue(false);\n                    },\n                    editable: function editable(event) {\n                      event.target.disabled = !event.detail.editable;\n                    }\n                  };\n                  _this75._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                selectElement.addEventListener(\"input\", function (event) {\n                  var _this75$linkService$e;\n                  var exportValue = getValue(true);\n                  storage.setValue(id, {\n                    value: exportValue\n                  });\n                  event.preventDefault();\n                  (_this75$linkService$e = _this75.linkService.eventBus) === null || _this75$linkService$e === void 0 ? void 0 : _this75$linkService$e.dispatch(\"dispatcheventinsandbox\", {\n                    source: _this75,\n                    detail: {\n                      id: id,\n                      name: \"Keystroke\",\n                      value: selectedValues,\n                      changeEx: exportValue,\n                      willCommit: false,\n                      commitKey: 1,\n                      keyDown: false\n                    }\n                  });\n                });\n                this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"], [\"input\", \"Validate\"]], function (event) {\n                  return event.target.value;\n                });\n              } else {\n                selectElement.addEventListener(\"input\", function (event) {\n                  storage.setValue(id, {\n                    value: getValue(true)\n                  });\n                });\n              }\n              if (this.data.combo) {\n                this._setTextStyle(selectElement);\n              } else {}\n              this._setBackgroundColor(selectElement);\n              this._setDefaultPropertiesFromJS(selectElement);\n              this.container.append(selectElement);\n              return this.container;\n            }\n          }]);\n          return ChoiceWidgetAnnotationElement;\n        }(WidgetAnnotationElement);\n        var PopupAnnotationElement = /*#__PURE__*/function (_AnnotationElement4) {\n          _inherits(PopupAnnotationElement, _AnnotationElement4);\n          var _super36 = _createSuper(PopupAnnotationElement);\n          function PopupAnnotationElement(parameters) {\n            var _data$titleObj, _data$contentsObj, _data$richText;\n            _classCallCheck(this, PopupAnnotationElement);\n            var data = parameters.data;\n            var isRenderable = !PopupAnnotationElement.IGNORE_TYPES.has(data.parentType) && !!((_data$titleObj = data.titleObj) !== null && _data$titleObj !== void 0 && _data$titleObj.str || (_data$contentsObj = data.contentsObj) !== null && _data$contentsObj !== void 0 && _data$contentsObj.str || (_data$richText = data.richText) !== null && _data$richText !== void 0 && _data$richText.str);\n            return _super36.call(this, parameters, {\n              isRenderable: isRenderable\n            });\n          }\n          _createClass(PopupAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(\"popupAnnotation\");\n              var parentElements = this.layer.querySelectorAll(\"[data-annotation-id=\\\"\".concat(this.data.parentId, \"\\\"]\"));\n              if (parentElements.length === 0) {\n                return this.container;\n              }\n              var popup = new PopupElement({\n                container: this.container,\n                trigger: Array.from(parentElements),\n                color: this.data.color,\n                titleObj: this.data.titleObj,\n                modificationDate: this.data.modificationDate,\n                contentsObj: this.data.contentsObj,\n                richText: this.data.richText\n              });\n              var page = this.page;\n              var rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);\n              var popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\n              var popupTop = rect[1];\n              var _this$viewport$rawDim3 = this.viewport.rawDims,\n                pageWidth = _this$viewport$rawDim3.pageWidth,\n                pageHeight = _this$viewport$rawDim3.pageHeight,\n                pageX = _this$viewport$rawDim3.pageX,\n                pageY = _this$viewport$rawDim3.pageY;\n              this.container.style.left = \"\".concat(100 * (popupLeft - pageX) / pageWidth, \"%\");\n              this.container.style.top = \"\".concat(100 * (popupTop - pageY) / pageHeight, \"%\");\n              this.container.append(popup.render());\n              return this.container;\n            }\n          }]);\n          return PopupAnnotationElement;\n        }(AnnotationElement);\n        _defineProperty(PopupAnnotationElement, \"IGNORE_TYPES\", new Set([\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"]));\n        var PopupElement = /*#__PURE__*/function () {\n          function PopupElement(parameters) {\n            _classCallCheck(this, PopupElement);\n            this.container = parameters.container;\n            this.trigger = parameters.trigger;\n            this.color = parameters.color;\n            this.titleObj = parameters.titleObj;\n            this.modificationDate = parameters.modificationDate;\n            this.contentsObj = parameters.contentsObj;\n            this.richText = parameters.richText;\n            this.hideWrapper = parameters.hideWrapper || false;\n            this.pinned = false;\n          }\n          _createClass(PopupElement, [{\n            key: \"render\",\n            value: function render() {\n              var _this$richText, _this$contentsObj;\n              var BACKGROUND_ENLIGHT = 0.7;\n              var wrapper = document.createElement(\"div\");\n              wrapper.classList.add(\"popupWrapper\");\n              this.hideElement = this.hideWrapper ? wrapper : this.container;\n              this.hideElement.hidden = true;\n              var popup = document.createElement(\"div\");\n              popup.classList.add(\"popup\");\n              var color = this.color;\n              if (color) {\n                var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n                var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n                var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n                popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);\n              }\n              var title = document.createElement(\"h1\");\n              title.dir = this.titleObj.dir;\n              title.textContent = this.titleObj.str;\n              popup.append(title);\n              var dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n              if (dateObject) {\n                var modificationDate = document.createElement(\"span\");\n                modificationDate.classList.add(\"popupDate\");\n                modificationDate.textContent = \"{{date}}, {{time}}\";\n                modificationDate.dataset.l10nId = \"annotation_date_string\";\n                modificationDate.dataset.l10nArgs = JSON.stringify({\n                  date: dateObject.toLocaleDateString(),\n                  time: dateObject.toLocaleTimeString()\n                });\n                popup.append(modificationDate);\n              }\n              if ((_this$richText = this.richText) !== null && _this$richText !== void 0 && _this$richText.str && (!((_this$contentsObj = this.contentsObj) !== null && _this$contentsObj !== void 0 && _this$contentsObj.str) || this.contentsObj.str === this.richText.str)) {\n                _xfa_layer.XfaLayer.render({\n                  xfaHtml: this.richText.html,\n                  intent: \"richText\",\n                  div: popup\n                });\n                popup.lastChild.classList.add(\"richText\", \"popupContent\");\n              } else {\n                var contents = this._formatContents(this.contentsObj);\n                popup.append(contents);\n              }\n              if (!Array.isArray(this.trigger)) {\n                this.trigger = [this.trigger];\n              }\n              var _iterator114 = _createForOfIteratorHelper(this.trigger),\n                _step114;\n              try {\n                for (_iterator114.s(); !(_step114 = _iterator114.n()).done;) {\n                  var element = _step114.value;\n                  element.addEventListener(\"click\", this._toggle.bind(this));\n                  element.addEventListener(\"mouseover\", this._show.bind(this, false));\n                  element.addEventListener(\"mouseout\", this._hide.bind(this, false));\n                }\n              } catch (err) {\n                _iterator114.e(err);\n              } finally {\n                _iterator114.f();\n              }\n              popup.addEventListener(\"click\", this._hide.bind(this, true));\n              wrapper.append(popup);\n              return wrapper;\n            }\n          }, {\n            key: \"_formatContents\",\n            value: function _formatContents(_ref66) {\n              var str = _ref66.str,\n                dir = _ref66.dir;\n              var p = document.createElement(\"p\");\n              p.classList.add(\"popupContent\");\n              p.dir = dir;\n              var lines = str.split(/(?:\\r\\n?|\\n)/);\n              for (var i = 0, ii = lines.length; i < ii; ++i) {\n                var line = lines[i];\n                p.append(document.createTextNode(line));\n                if (i < ii - 1) {\n                  p.append(document.createElement(\"br\"));\n                }\n              }\n              return p;\n            }\n          }, {\n            key: \"_toggle\",\n            value: function _toggle() {\n              if (this.pinned) {\n                this._hide(true);\n              } else {\n                this._show(true);\n              }\n            }\n          }, {\n            key: \"_show\",\n            value: function _show() {\n              var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n              if (pin) {\n                this.pinned = true;\n              }\n              if (this.hideElement.hidden) {\n                this.hideElement.hidden = false;\n                this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1000;\n              }\n            }\n          }, {\n            key: \"_hide\",\n            value: function _hide() {\n              var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n              if (unpin) {\n                this.pinned = false;\n              }\n              if (!this.hideElement.hidden && !this.pinned) {\n                this.hideElement.hidden = true;\n                this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1000;\n              }\n            }\n          }]);\n          return PopupElement;\n        }();\n        var FreeTextAnnotationElement = /*#__PURE__*/function (_AnnotationElement5) {\n          _inherits(FreeTextAnnotationElement, _AnnotationElement5);\n          var _super37 = _createSuper(FreeTextAnnotationElement);\n          function FreeTextAnnotationElement(parameters) {\n            var _parameters$data$titl2, _parameters$data$cont2, _parameters$data$rich2;\n            var _this76;\n            _classCallCheck(this, FreeTextAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl2 = parameters.data.titleObj) !== null && _parameters$data$titl2 !== void 0 && _parameters$data$titl2.str || (_parameters$data$cont2 = parameters.data.contentsObj) !== null && _parameters$data$cont2 !== void 0 && _parameters$data$cont2.str || (_parameters$data$rich2 = parameters.data.richText) !== null && _parameters$data$rich2 !== void 0 && _parameters$data$rich2.str);\n            _this76 = _super37.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true\n            });\n            _this76.textContent = parameters.data.textContent;\n            return _this76;\n          }\n          _createClass(FreeTextAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(\"freeTextAnnotation\");\n              if (this.textContent) {\n                var content = document.createElement(\"div\");\n                content.classList.add(\"annotationTextContent\");\n                content.setAttribute(\"role\", \"comment\");\n                var _iterator115 = _createForOfIteratorHelper(this.textContent),\n                  _step115;\n                try {\n                  for (_iterator115.s(); !(_step115 = _iterator115.n()).done;) {\n                    var line = _step115.value;\n                    var lineSpan = document.createElement(\"span\");\n                    lineSpan.textContent = line;\n                    content.append(lineSpan);\n                  }\n                } catch (err) {\n                  _iterator115.e(err);\n                } finally {\n                  _iterator115.f();\n                }\n                this.container.append(content);\n              }\n              if (!this.data.hasPopup) {\n                this._createPopup(null, this.data);\n              }\n              return this.container;\n            }\n          }]);\n          return FreeTextAnnotationElement;\n        }(AnnotationElement);\n        var LineAnnotationElement = /*#__PURE__*/function (_AnnotationElement6) {\n          _inherits(LineAnnotationElement, _AnnotationElement6);\n          var _super38 = _createSuper(LineAnnotationElement);\n          function LineAnnotationElement(parameters) {\n            var _parameters$data$titl3, _parameters$data$cont3, _parameters$data$rich3;\n            _classCallCheck(this, LineAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl3 = parameters.data.titleObj) !== null && _parameters$data$titl3 !== void 0 && _parameters$data$titl3.str || (_parameters$data$cont3 = parameters.data.contentsObj) !== null && _parameters$data$cont3 !== void 0 && _parameters$data$cont3.str || (_parameters$data$rich3 = parameters.data.richText) !== null && _parameters$data$rich3 !== void 0 && _parameters$data$rich3.str);\n            return _super38.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true\n            });\n          }\n          _createClass(LineAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(\"lineAnnotation\");\n              var data = this.data;\n              var _getRectDims3 = getRectDims(data.rect),\n                width = _getRectDims3.width,\n                height = _getRectDims3.height;\n              var svg = this.svgFactory.create(width, height, true);\n              var line = this.svgFactory.createElement(\"svg:line\");\n              line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n              line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n              line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n              line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n              line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n              line.setAttribute(\"stroke\", \"transparent\");\n              line.setAttribute(\"fill\", \"transparent\");\n              svg.append(line);\n              this.container.append(svg);\n              this._createPopup(line, data);\n              return this.container;\n            }\n          }]);\n          return LineAnnotationElement;\n        }(AnnotationElement);\n        var SquareAnnotationElement = /*#__PURE__*/function (_AnnotationElement7) {\n          _inherits(SquareAnnotationElement, _AnnotationElement7);\n          var _super39 = _createSuper(SquareAnnotationElement);\n          function SquareAnnotationElement(parameters) {\n            var _parameters$data$titl4, _parameters$data$cont4, _parameters$data$rich4;\n            _classCallCheck(this, SquareAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl4 = parameters.data.titleObj) !== null && _parameters$data$titl4 !== void 0 && _parameters$data$titl4.str || (_parameters$data$cont4 = parameters.data.contentsObj) !== null && _parameters$data$cont4 !== void 0 && _parameters$data$cont4.str || (_parameters$data$rich4 = parameters.data.richText) !== null && _parameters$data$rich4 !== void 0 && _parameters$data$rich4.str);\n            return _super39.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true\n            });\n          }\n          _createClass(SquareAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(\"squareAnnotation\");\n              var data = this.data;\n              var _getRectDims4 = getRectDims(data.rect),\n                width = _getRectDims4.width,\n                height = _getRectDims4.height;\n              var svg = this.svgFactory.create(width, height, true);\n              var borderWidth = data.borderStyle.width;\n              var square = this.svgFactory.createElement(\"svg:rect\");\n              square.setAttribute(\"x\", borderWidth / 2);\n              square.setAttribute(\"y\", borderWidth / 2);\n              square.setAttribute(\"width\", width - borderWidth);\n              square.setAttribute(\"height\", height - borderWidth);\n              square.setAttribute(\"stroke-width\", borderWidth || 1);\n              square.setAttribute(\"stroke\", \"transparent\");\n              square.setAttribute(\"fill\", \"transparent\");\n              svg.append(square);\n              this.container.append(svg);\n              this._createPopup(square, data);\n              return this.container;\n            }\n          }]);\n          return SquareAnnotationElement;\n        }(AnnotationElement);\n        var CircleAnnotationElement = /*#__PURE__*/function (_AnnotationElement8) {\n          _inherits(CircleAnnotationElement, _AnnotationElement8);\n          var _super40 = _createSuper(CircleAnnotationElement);\n          function CircleAnnotationElement(parameters) {\n            var _parameters$data$titl5, _parameters$data$cont5, _parameters$data$rich5;\n            _classCallCheck(this, CircleAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl5 = parameters.data.titleObj) !== null && _parameters$data$titl5 !== void 0 && _parameters$data$titl5.str || (_parameters$data$cont5 = parameters.data.contentsObj) !== null && _parameters$data$cont5 !== void 0 && _parameters$data$cont5.str || (_parameters$data$rich5 = parameters.data.richText) !== null && _parameters$data$rich5 !== void 0 && _parameters$data$rich5.str);\n            return _super40.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true\n            });\n          }\n          _createClass(CircleAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(\"circleAnnotation\");\n              var data = this.data;\n              var _getRectDims5 = getRectDims(data.rect),\n                width = _getRectDims5.width,\n                height = _getRectDims5.height;\n              var svg = this.svgFactory.create(width, height, true);\n              var borderWidth = data.borderStyle.width;\n              var circle = this.svgFactory.createElement(\"svg:ellipse\");\n              circle.setAttribute(\"cx\", width / 2);\n              circle.setAttribute(\"cy\", height / 2);\n              circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n              circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n              circle.setAttribute(\"stroke-width\", borderWidth || 1);\n              circle.setAttribute(\"stroke\", \"transparent\");\n              circle.setAttribute(\"fill\", \"transparent\");\n              svg.append(circle);\n              this.container.append(svg);\n              this._createPopup(circle, data);\n              return this.container;\n            }\n          }]);\n          return CircleAnnotationElement;\n        }(AnnotationElement);\n        var PolylineAnnotationElement = /*#__PURE__*/function (_AnnotationElement9) {\n          _inherits(PolylineAnnotationElement, _AnnotationElement9);\n          var _super41 = _createSuper(PolylineAnnotationElement);\n          function PolylineAnnotationElement(parameters) {\n            var _parameters$data$titl6, _parameters$data$cont6, _parameters$data$rich6;\n            var _this77;\n            _classCallCheck(this, PolylineAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl6 = parameters.data.titleObj) !== null && _parameters$data$titl6 !== void 0 && _parameters$data$titl6.str || (_parameters$data$cont6 = parameters.data.contentsObj) !== null && _parameters$data$cont6 !== void 0 && _parameters$data$cont6.str || (_parameters$data$rich6 = parameters.data.richText) !== null && _parameters$data$rich6 !== void 0 && _parameters$data$rich6.str);\n            _this77 = _super41.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true\n            });\n            _this77.containerClassName = \"polylineAnnotation\";\n            _this77.svgElementName = \"svg:polyline\";\n            return _this77;\n          }\n          _createClass(PolylineAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(this.containerClassName);\n              var data = this.data;\n              var _getRectDims6 = getRectDims(data.rect),\n                width = _getRectDims6.width,\n                height = _getRectDims6.height;\n              var svg = this.svgFactory.create(width, height, true);\n              var points = [];\n              var _iterator116 = _createForOfIteratorHelper(data.vertices),\n                _step116;\n              try {\n                for (_iterator116.s(); !(_step116 = _iterator116.n()).done;) {\n                  var coordinate = _step116.value;\n                  var x = coordinate.x - data.rect[0];\n                  var y = data.rect[3] - coordinate.y;\n                  points.push(x + \",\" + y);\n                }\n              } catch (err) {\n                _iterator116.e(err);\n              } finally {\n                _iterator116.f();\n              }\n              points = points.join(\" \");\n              var polyline = this.svgFactory.createElement(this.svgElementName);\n              polyline.setAttribute(\"points\", points);\n              polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n              polyline.setAttribute(\"stroke\", \"transparent\");\n              polyline.setAttribute(\"fill\", \"transparent\");\n              svg.append(polyline);\n              this.container.append(svg);\n              this._createPopup(polyline, data);\n              return this.container;\n            }\n          }]);\n          return PolylineAnnotationElement;\n        }(AnnotationElement);\n        var PolygonAnnotationElement = /*#__PURE__*/function (_PolylineAnnotationEl) {\n          _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);\n          var _super42 = _createSuper(PolygonAnnotationElement);\n          function PolygonAnnotationElement(parameters) {\n            var _this78;\n            _classCallCheck(this, PolygonAnnotationElement);\n            _this78 = _super42.call(this, parameters);\n            _this78.containerClassName = \"polygonAnnotation\";\n            _this78.svgElementName = \"svg:polygon\";\n            return _this78;\n          }\n          return _createClass(PolygonAnnotationElement);\n        }(PolylineAnnotationElement);\n        var CaretAnnotationElement = /*#__PURE__*/function (_AnnotationElement10) {\n          _inherits(CaretAnnotationElement, _AnnotationElement10);\n          var _super43 = _createSuper(CaretAnnotationElement);\n          function CaretAnnotationElement(parameters) {\n            var _parameters$data$titl7, _parameters$data$cont7, _parameters$data$rich7;\n            _classCallCheck(this, CaretAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl7 = parameters.data.titleObj) !== null && _parameters$data$titl7 !== void 0 && _parameters$data$titl7.str || (_parameters$data$cont7 = parameters.data.contentsObj) !== null && _parameters$data$cont7 !== void 0 && _parameters$data$cont7.str || (_parameters$data$rich7 = parameters.data.richText) !== null && _parameters$data$rich7 !== void 0 && _parameters$data$rich7.str);\n            return _super43.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true\n            });\n          }\n          _createClass(CaretAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(\"caretAnnotation\");\n              if (!this.data.hasPopup) {\n                this._createPopup(null, this.data);\n              }\n              return this.container;\n            }\n          }]);\n          return CaretAnnotationElement;\n        }(AnnotationElement);\n        var InkAnnotationElement = /*#__PURE__*/function (_AnnotationElement11) {\n          _inherits(InkAnnotationElement, _AnnotationElement11);\n          var _super44 = _createSuper(InkAnnotationElement);\n          function InkAnnotationElement(parameters) {\n            var _parameters$data$titl8, _parameters$data$cont8, _parameters$data$rich8;\n            var _this79;\n            _classCallCheck(this, InkAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl8 = parameters.data.titleObj) !== null && _parameters$data$titl8 !== void 0 && _parameters$data$titl8.str || (_parameters$data$cont8 = parameters.data.contentsObj) !== null && _parameters$data$cont8 !== void 0 && _parameters$data$cont8.str || (_parameters$data$rich8 = parameters.data.richText) !== null && _parameters$data$rich8 !== void 0 && _parameters$data$rich8.str);\n            _this79 = _super44.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true\n            });\n            _this79.containerClassName = \"inkAnnotation\";\n            _this79.svgElementName = \"svg:polyline\";\n            return _this79;\n          }\n          _createClass(InkAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(this.containerClassName);\n              var data = this.data;\n              var _getRectDims7 = getRectDims(data.rect),\n                width = _getRectDims7.width,\n                height = _getRectDims7.height;\n              var svg = this.svgFactory.create(width, height, true);\n              var _iterator117 = _createForOfIteratorHelper(data.inkLists),\n                _step117;\n              try {\n                for (_iterator117.s(); !(_step117 = _iterator117.n()).done;) {\n                  var inkList = _step117.value;\n                  var points = [];\n                  var _iterator118 = _createForOfIteratorHelper(inkList),\n                    _step118;\n                  try {\n                    for (_iterator118.s(); !(_step118 = _iterator118.n()).done;) {\n                      var coordinate = _step118.value;\n                      var x = coordinate.x - data.rect[0];\n                      var y = data.rect[3] - coordinate.y;\n                      points.push(\"\".concat(x, \",\").concat(y));\n                    }\n                  } catch (err) {\n                    _iterator118.e(err);\n                  } finally {\n                    _iterator118.f();\n                  }\n                  points = points.join(\" \");\n                  var polyline = this.svgFactory.createElement(this.svgElementName);\n                  polyline.setAttribute(\"points\", points);\n                  polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                  polyline.setAttribute(\"stroke\", \"transparent\");\n                  polyline.setAttribute(\"fill\", \"transparent\");\n                  this._createPopup(polyline, data);\n                  svg.append(polyline);\n                }\n              } catch (err) {\n                _iterator117.e(err);\n              } finally {\n                _iterator117.f();\n              }\n              this.container.append(svg);\n              return this.container;\n            }\n          }]);\n          return InkAnnotationElement;\n        }(AnnotationElement);\n        var HighlightAnnotationElement = /*#__PURE__*/function (_AnnotationElement12) {\n          _inherits(HighlightAnnotationElement, _AnnotationElement12);\n          var _super45 = _createSuper(HighlightAnnotationElement);\n          function HighlightAnnotationElement(parameters) {\n            var _parameters$data$titl9, _parameters$data$cont9, _parameters$data$rich9;\n            _classCallCheck(this, HighlightAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl9 = parameters.data.titleObj) !== null && _parameters$data$titl9 !== void 0 && _parameters$data$titl9.str || (_parameters$data$cont9 = parameters.data.contentsObj) !== null && _parameters$data$cont9 !== void 0 && _parameters$data$cont9.str || (_parameters$data$rich9 = parameters.data.richText) !== null && _parameters$data$rich9 !== void 0 && _parameters$data$rich9.str);\n            return _super45.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true,\n              createQuadrilaterals: true\n            });\n          }\n          _createClass(HighlightAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              if (!this.data.hasPopup) {\n                this._createPopup(null, this.data);\n              }\n              if (this.quadrilaterals) {\n                return this._renderQuadrilaterals(\"highlightAnnotation\");\n              }\n              this.container.classList.add(\"highlightAnnotation\");\n              return this.container;\n            }\n          }]);\n          return HighlightAnnotationElement;\n        }(AnnotationElement);\n        var UnderlineAnnotationElement = /*#__PURE__*/function (_AnnotationElement13) {\n          _inherits(UnderlineAnnotationElement, _AnnotationElement13);\n          var _super46 = _createSuper(UnderlineAnnotationElement);\n          function UnderlineAnnotationElement(parameters) {\n            var _parameters$data$titl10, _parameters$data$cont10, _parameters$data$rich10;\n            _classCallCheck(this, UnderlineAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl10 = parameters.data.titleObj) !== null && _parameters$data$titl10 !== void 0 && _parameters$data$titl10.str || (_parameters$data$cont10 = parameters.data.contentsObj) !== null && _parameters$data$cont10 !== void 0 && _parameters$data$cont10.str || (_parameters$data$rich10 = parameters.data.richText) !== null && _parameters$data$rich10 !== void 0 && _parameters$data$rich10.str);\n            return _super46.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true,\n              createQuadrilaterals: true\n            });\n          }\n          _createClass(UnderlineAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              if (!this.data.hasPopup) {\n                this._createPopup(null, this.data);\n              }\n              if (this.quadrilaterals) {\n                return this._renderQuadrilaterals(\"underlineAnnotation\");\n              }\n              this.container.classList.add(\"underlineAnnotation\");\n              return this.container;\n            }\n          }]);\n          return UnderlineAnnotationElement;\n        }(AnnotationElement);\n        var SquigglyAnnotationElement = /*#__PURE__*/function (_AnnotationElement14) {\n          _inherits(SquigglyAnnotationElement, _AnnotationElement14);\n          var _super47 = _createSuper(SquigglyAnnotationElement);\n          function SquigglyAnnotationElement(parameters) {\n            var _parameters$data$titl11, _parameters$data$cont11, _parameters$data$rich11;\n            _classCallCheck(this, SquigglyAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl11 = parameters.data.titleObj) !== null && _parameters$data$titl11 !== void 0 && _parameters$data$titl11.str || (_parameters$data$cont11 = parameters.data.contentsObj) !== null && _parameters$data$cont11 !== void 0 && _parameters$data$cont11.str || (_parameters$data$rich11 = parameters.data.richText) !== null && _parameters$data$rich11 !== void 0 && _parameters$data$rich11.str);\n            return _super47.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true,\n              createQuadrilaterals: true\n            });\n          }\n          _createClass(SquigglyAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              if (!this.data.hasPopup) {\n                this._createPopup(null, this.data);\n              }\n              if (this.quadrilaterals) {\n                return this._renderQuadrilaterals(\"squigglyAnnotation\");\n              }\n              this.container.classList.add(\"squigglyAnnotation\");\n              return this.container;\n            }\n          }]);\n          return SquigglyAnnotationElement;\n        }(AnnotationElement);\n        var StrikeOutAnnotationElement = /*#__PURE__*/function (_AnnotationElement15) {\n          _inherits(StrikeOutAnnotationElement, _AnnotationElement15);\n          var _super48 = _createSuper(StrikeOutAnnotationElement);\n          function StrikeOutAnnotationElement(parameters) {\n            var _parameters$data$titl12, _parameters$data$cont12, _parameters$data$rich12;\n            _classCallCheck(this, StrikeOutAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl12 = parameters.data.titleObj) !== null && _parameters$data$titl12 !== void 0 && _parameters$data$titl12.str || (_parameters$data$cont12 = parameters.data.contentsObj) !== null && _parameters$data$cont12 !== void 0 && _parameters$data$cont12.str || (_parameters$data$rich12 = parameters.data.richText) !== null && _parameters$data$rich12 !== void 0 && _parameters$data$rich12.str);\n            return _super48.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true,\n              createQuadrilaterals: true\n            });\n          }\n          _createClass(StrikeOutAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              if (!this.data.hasPopup) {\n                this._createPopup(null, this.data);\n              }\n              if (this.quadrilaterals) {\n                return this._renderQuadrilaterals(\"strikeoutAnnotation\");\n              }\n              this.container.classList.add(\"strikeoutAnnotation\");\n              return this.container;\n            }\n          }]);\n          return StrikeOutAnnotationElement;\n        }(AnnotationElement);\n        var StampAnnotationElement = /*#__PURE__*/function (_AnnotationElement16) {\n          _inherits(StampAnnotationElement, _AnnotationElement16);\n          var _super49 = _createSuper(StampAnnotationElement);\n          function StampAnnotationElement(parameters) {\n            var _parameters$data$titl13, _parameters$data$cont13, _parameters$data$rich13;\n            _classCallCheck(this, StampAnnotationElement);\n            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl13 = parameters.data.titleObj) !== null && _parameters$data$titl13 !== void 0 && _parameters$data$titl13.str || (_parameters$data$cont13 = parameters.data.contentsObj) !== null && _parameters$data$cont13 !== void 0 && _parameters$data$cont13.str || (_parameters$data$rich13 = parameters.data.richText) !== null && _parameters$data$rich13 !== void 0 && _parameters$data$rich13.str);\n            return _super49.call(this, parameters, {\n              isRenderable: isRenderable,\n              ignoreBorder: true\n            });\n          }\n          _createClass(StampAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              this.container.classList.add(\"stampAnnotation\");\n              if (!this.data.hasPopup) {\n                this._createPopup(null, this.data);\n              }\n              return this.container;\n            }\n          }]);\n          return StampAnnotationElement;\n        }(AnnotationElement);\n        var FileAttachmentAnnotationElement = /*#__PURE__*/function (_AnnotationElement17) {\n          _inherits(FileAttachmentAnnotationElement, _AnnotationElement17);\n          var _super50 = _createSuper(FileAttachmentAnnotationElement);\n          function FileAttachmentAnnotationElement(parameters) {\n            var _this80$linkService$e;\n            var _this80;\n            _classCallCheck(this, FileAttachmentAnnotationElement);\n            _this80 = _super50.call(this, parameters, {\n              isRenderable: true\n            });\n            var _this80$data$file = _this80.data.file,\n              filename = _this80$data$file.filename,\n              content = _this80$data$file.content;\n            _this80.filename = (0, _display_utils.getFilenameFromUrl)(filename, true);\n            _this80.content = content;\n            (_this80$linkService$e = _this80.linkService.eventBus) === null || _this80$linkService$e === void 0 ? void 0 : _this80$linkService$e.dispatch(\"fileattachmentannotation\", {\n              source: _assertThisInitialized(_this80),\n              filename: filename,\n              content: content\n            });\n            return _this80;\n          }\n          _createClass(FileAttachmentAnnotationElement, [{\n            key: \"render\",\n            value: function render() {\n              var _this$data$titleObj, _this$data$contentsOb;\n              this.container.classList.add(\"fileAttachmentAnnotation\");\n              var trigger;\n              if (this.data.hasAppearance) {\n                trigger = document.createElement(\"div\");\n              } else {\n                trigger = document.createElement(\"img\");\n                trigger.src = \"\".concat(this.imageResourcesPath, \"annotation-\").concat(/paperclip/i.test(this.data.name) ? \"paperclip\" : \"pushpin\", \".svg\");\n              }\n              trigger.classList.add(\"popupTriggerArea\");\n              trigger.addEventListener(\"dblclick\", this._download.bind(this));\n              if (!this.data.hasPopup && ((_this$data$titleObj = this.data.titleObj) !== null && _this$data$titleObj !== void 0 && _this$data$titleObj.str || (_this$data$contentsOb = this.data.contentsObj) !== null && _this$data$contentsOb !== void 0 && _this$data$contentsOb.str || this.data.richText)) {\n                this._createPopup(trigger, this.data);\n              }\n              this.container.append(trigger);\n              return this.container;\n            }\n          }, {\n            key: \"_download\",\n            value: function _download() {\n              var _this$downloadManager;\n              (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 ? void 0 : _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);\n            }\n          }]);\n          return FileAttachmentAnnotationElement;\n        }(AnnotationElement);\n        var AnnotationLayer = /*#__PURE__*/function () {\n          function AnnotationLayer() {\n            _classCallCheck(this, AnnotationLayer);\n          }\n          _createClass(AnnotationLayer, null, [{\n            key: \"render\",\n            value: function render(params) {\n              var annotations = params.annotations,\n                div = params.div,\n                viewport = params.viewport,\n                accessibilityManager = params.accessibilityManager;\n              (0, _display_utils.setLayerDimensions)(div, viewport);\n              var elementParams = {\n                data: null,\n                layer: div,\n                page: params.page,\n                viewport: viewport,\n                linkService: params.linkService,\n                downloadManager: params.downloadManager,\n                imageResourcesPath: params.imageResourcesPath || \"\",\n                renderForms: params.renderForms !== false,\n                svgFactory: new _display_utils.DOMSVGFactory(),\n                annotationStorage: params.annotationStorage || new _annotation_storage.AnnotationStorage(),\n                enableScripting: params.enableScripting === true,\n                hasJSActions: params.hasJSActions,\n                fieldObjects: params.fieldObjects\n              };\n              var zIndex = 0;\n              var _iterator119 = _createForOfIteratorHelper(annotations),\n                _step119;\n              try {\n                for (_iterator119.s(); !(_step119 = _iterator119.n()).done;) {\n                  var data = _step119.value;\n                  if (data.noHTML) {\n                    continue;\n                  }\n                  if (data.annotationType !== _util.AnnotationType.POPUP) {\n                    var _getRectDims8 = getRectDims(data.rect),\n                      width = _getRectDims8.width,\n                      height = _getRectDims8.height;\n                    if (width <= 0 || height <= 0) {\n                      continue;\n                    }\n                  }\n                  elementParams.data = data;\n                  var element = AnnotationElementFactory.create(elementParams);\n                  if (!element.isRenderable) {\n                    continue;\n                  }\n                  var rendered = element.render();\n                  if (data.hidden) {\n                    rendered.style.visibility = \"hidden\";\n                  }\n                  if (Array.isArray(rendered)) {\n                    var _iterator120 = _createForOfIteratorHelper(rendered),\n                      _step120;\n                    try {\n                      for (_iterator120.s(); !(_step120 = _iterator120.n()).done;) {\n                        var renderedElement = _step120.value;\n                        renderedElement.style.zIndex = zIndex++;\n                        _classStaticPrivateMethodGet(AnnotationLayer, AnnotationLayer, _appendElement).call(AnnotationLayer, renderedElement, data.id, div, accessibilityManager);\n                      }\n                    } catch (err) {\n                      _iterator120.e(err);\n                    } finally {\n                      _iterator120.f();\n                    }\n                  } else {\n                    rendered.style.zIndex = zIndex++;\n                    if (element instanceof PopupAnnotationElement) {\n                      div.prepend(rendered);\n                    } else {\n                      _classStaticPrivateMethodGet(AnnotationLayer, AnnotationLayer, _appendElement).call(AnnotationLayer, rendered, data.id, div, accessibilityManager);\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator119.e(err);\n              } finally {\n                _iterator119.f();\n              }\n              _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, params.annotationCanvasMap);\n            }\n          }, {\n            key: \"update\",\n            value: function update(params) {\n              var annotationCanvasMap = params.annotationCanvasMap,\n                div = params.div,\n                viewport = params.viewport;\n              (0, _display_utils.setLayerDimensions)(div, {\n                rotation: viewport.rotation\n              });\n              _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, annotationCanvasMap);\n              div.hidden = false;\n            }\n          }]);\n          return AnnotationLayer;\n        }();\n        function _appendElement(element, id, div, accessibilityManager) {\n          var contentElement = element.firstChild || element;\n          contentElement.id = \"\".concat(_display_utils.AnnotationPrefix).concat(id);\n          div.append(element);\n          accessibilityManager === null || accessibilityManager === void 0 ? void 0 : accessibilityManager.moveElementInDOM(div, element, contentElement, false);\n        }\n        function _setAnnotationCanvasMap(div, annotationCanvasMap) {\n          if (!annotationCanvasMap) {\n            return;\n          }\n          var _iterator121 = _createForOfIteratorHelper(annotationCanvasMap),\n            _step121;\n          try {\n            for (_iterator121.s(); !(_step121 = _iterator121.n()).done;) {\n              var _step121$value = _slicedToArray(_step121.value, 2),\n                id = _step121$value[0],\n                canvas = _step121$value[1];\n              var element = div.querySelector(\"[data-annotation-id=\\\"\".concat(id, \"\\\"]\"));\n              if (!element) {\n                continue;\n              }\n              var firstChild = element.firstChild;\n              if (!firstChild) {\n                element.append(canvas);\n              } else if (firstChild.nodeName === \"CANVAS\") {\n                firstChild.replaceWith(canvas);\n              } else {\n                firstChild.before(canvas);\n              }\n            }\n          } catch (err) {\n            _iterator121.e(err);\n          } finally {\n            _iterator121.f();\n          }\n          annotationCanvasMap.clear();\n        }\n        exports.AnnotationLayer = AnnotationLayer;\n\n        /***/\n      }, /* 33 */\n      /***/function (__unused_webpack_module, exports) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.ColorConverters = void 0;\n        function makeColorComp(n) {\n          return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n        }\n        var ColorConverters = /*#__PURE__*/function () {\n          function ColorConverters() {\n            _classCallCheck(this, ColorConverters);\n          }\n          _createClass(ColorConverters, null, [{\n            key: \"CMYK_G\",\n            value: function CMYK_G(_ref67) {\n              var _ref68 = _slicedToArray(_ref67, 4),\n                c = _ref68[0],\n                y = _ref68[1],\n                m = _ref68[2],\n                k = _ref68[3];\n              return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n            }\n          }, {\n            key: \"G_CMYK\",\n            value: function G_CMYK(_ref69) {\n              var _ref70 = _slicedToArray(_ref69, 1),\n                g = _ref70[0];\n              return [\"CMYK\", 0, 0, 0, 1 - g];\n            }\n          }, {\n            key: \"G_RGB\",\n            value: function G_RGB(_ref71) {\n              var _ref72 = _slicedToArray(_ref71, 1),\n                g = _ref72[0];\n              return [\"RGB\", g, g, g];\n            }\n          }, {\n            key: \"G_HTML\",\n            value: function G_HTML(_ref73) {\n              var _ref74 = _slicedToArray(_ref73, 1),\n                g = _ref74[0];\n              var G = makeColorComp(g);\n              return \"#\".concat(G).concat(G).concat(G);\n            }\n          }, {\n            key: \"RGB_G\",\n            value: function RGB_G(_ref75) {\n              var _ref76 = _slicedToArray(_ref75, 3),\n                r = _ref76[0],\n                g = _ref76[1],\n                b = _ref76[2];\n              return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n            }\n          }, {\n            key: \"RGB_HTML\",\n            value: function RGB_HTML(_ref77) {\n              var _ref78 = _slicedToArray(_ref77, 3),\n                r = _ref78[0],\n                g = _ref78[1],\n                b = _ref78[2];\n              var R = makeColorComp(r);\n              var G = makeColorComp(g);\n              var B = makeColorComp(b);\n              return \"#\".concat(R).concat(G).concat(B);\n            }\n          }, {\n            key: \"T_HTML\",\n            value: function T_HTML() {\n              return \"#00000000\";\n            }\n          }, {\n            key: \"CMYK_RGB\",\n            value: function CMYK_RGB(_ref79) {\n              var _ref80 = _slicedToArray(_ref79, 4),\n                c = _ref80[0],\n                y = _ref80[1],\n                m = _ref80[2],\n                k = _ref80[3];\n              return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n            }\n          }, {\n            key: \"CMYK_HTML\",\n            value: function CMYK_HTML(components) {\n              var rgb = this.CMYK_RGB(components).slice(1);\n              return this.RGB_HTML(rgb);\n            }\n          }, {\n            key: \"RGB_CMYK\",\n            value: function RGB_CMYK(_ref81) {\n              var _ref82 = _slicedToArray(_ref81, 3),\n                r = _ref82[0],\n                g = _ref82[1],\n                b = _ref82[2];\n              var c = 1 - r;\n              var m = 1 - g;\n              var y = 1 - b;\n              var k = Math.min(c, m, y);\n              return [\"CMYK\", c, m, y, k];\n            }\n          }]);\n          return ColorConverters;\n        }();\n        exports.ColorConverters = ColorConverters;\n\n        /***/\n      }, /* 34 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.XfaLayer = void 0;\n        var _xfa_text = __w_pdfjs_require__(19);\n        var XfaLayer = /*#__PURE__*/function () {\n          function XfaLayer() {\n            _classCallCheck(this, XfaLayer);\n          }\n          _createClass(XfaLayer, null, [{\n            key: \"setupStorage\",\n            value: function setupStorage(html, id, element, storage, intent) {\n              var storedData = storage.getValue(id, {\n                value: null\n              });\n              switch (element.name) {\n                case \"textarea\":\n                  if (storedData.value !== null) {\n                    html.textContent = storedData.value;\n                  }\n                  if (intent === \"print\") {\n                    break;\n                  }\n                  html.addEventListener(\"input\", function (event) {\n                    storage.setValue(id, {\n                      value: event.target.value\n                    });\n                  });\n                  break;\n                case \"input\":\n                  if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                    if (storedData.value === element.attributes.xfaOn) {\n                      html.setAttribute(\"checked\", true);\n                    } else if (storedData.value === element.attributes.xfaOff) {\n                      html.removeAttribute(\"checked\");\n                    }\n                    if (intent === \"print\") {\n                      break;\n                    }\n                    html.addEventListener(\"change\", function (event) {\n                      storage.setValue(id, {\n                        value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                      });\n                    });\n                  } else {\n                    if (storedData.value !== null) {\n                      html.setAttribute(\"value\", storedData.value);\n                    }\n                    if (intent === \"print\") {\n                      break;\n                    }\n                    html.addEventListener(\"input\", function (event) {\n                      storage.setValue(id, {\n                        value: event.target.value\n                      });\n                    });\n                  }\n                  break;\n                case \"select\":\n                  if (storedData.value !== null) {\n                    var _iterator122 = _createForOfIteratorHelper(element.children),\n                      _step122;\n                    try {\n                      for (_iterator122.s(); !(_step122 = _iterator122.n()).done;) {\n                        var option = _step122.value;\n                        if (option.attributes.value === storedData.value) {\n                          option.attributes.selected = true;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator122.e(err);\n                    } finally {\n                      _iterator122.f();\n                    }\n                  }\n                  html.addEventListener(\"input\", function (event) {\n                    var options = event.target.options;\n                    var value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                    storage.setValue(id, {\n                      value: value\n                    });\n                  });\n                  break;\n              }\n            }\n          }, {\n            key: \"setAttributes\",\n            value: function setAttributes(_ref83) {\n              var html = _ref83.html,\n                element = _ref83.element,\n                _ref83$storage = _ref83.storage,\n                storage = _ref83$storage === void 0 ? null : _ref83$storage,\n                intent = _ref83.intent,\n                linkService = _ref83.linkService;\n              var attributes = element.attributes;\n              var isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n              if (attributes.type === \"radio\") {\n                attributes.name = \"\".concat(attributes.name, \"-\").concat(intent);\n              }\n              for (var _i18 = 0, _Object$entries4 = Object.entries(attributes); _i18 < _Object$entries4.length; _i18++) {\n                var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i18], 2),\n                  key = _Object$entries4$_i[0],\n                  value = _Object$entries4$_i[1];\n                if (value === null || value === undefined) {\n                  continue;\n                }\n                switch (key) {\n                  case \"class\":\n                    if (value.length) {\n                      html.setAttribute(key, value.join(\" \"));\n                    }\n                    break;\n                  case \"dataId\":\n                    break;\n                  case \"id\":\n                    html.setAttribute(\"data-element-id\", value);\n                    break;\n                  case \"style\":\n                    Object.assign(html.style, value);\n                    break;\n                  case \"textContent\":\n                    html.textContent = value;\n                    break;\n                  default:\n                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                      html.setAttribute(key, value);\n                    }\n                }\n              }\n              if (isHTMLAnchorElement) {\n                linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n              }\n              if (storage && attributes.dataId) {\n                this.setupStorage(html, attributes.dataId, element, storage);\n              }\n            }\n          }, {\n            key: \"render\",\n            value: function render(parameters) {\n              var storage = parameters.annotationStorage;\n              var linkService = parameters.linkService;\n              var root = parameters.xfaHtml;\n              var intent = parameters.intent || \"display\";\n              var rootHtml = document.createElement(root.name);\n              if (root.attributes) {\n                this.setAttributes({\n                  html: rootHtml,\n                  element: root,\n                  intent: intent,\n                  linkService: linkService\n                });\n              }\n              var stack = [[root, -1, rootHtml]];\n              var rootDiv = parameters.div;\n              rootDiv.append(rootHtml);\n              if (parameters.viewport) {\n                var transform = \"matrix(\".concat(parameters.viewport.transform.join(\",\"), \")\");\n                rootDiv.style.transform = transform;\n              }\n              if (intent !== \"richText\") {\n                rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n              }\n              var textDivs = [];\n              while (stack.length > 0) {\n                var _child$attributes;\n                var _stack$at = stack.at(-1),\n                  _stack$at2 = _slicedToArray(_stack$at, 3),\n                  parent = _stack$at2[0],\n                  i = _stack$at2[1],\n                  html = _stack$at2[2];\n                if (i + 1 === parent.children.length) {\n                  stack.pop();\n                  continue;\n                }\n                var child = parent.children[++stack.at(-1)[1]];\n                if (child === null) {\n                  continue;\n                }\n                var name = child.name;\n                if (name === \"#text\") {\n                  var node = document.createTextNode(child.value);\n                  textDivs.push(node);\n                  html.append(node);\n                  continue;\n                }\n                var childHtml = void 0;\n                if (child !== null && child !== void 0 && (_child$attributes = child.attributes) !== null && _child$attributes !== void 0 && _child$attributes.xmlns) {\n                  childHtml = document.createElementNS(child.attributes.xmlns, name);\n                } else {\n                  childHtml = document.createElement(name);\n                }\n                html.append(childHtml);\n                if (child.attributes) {\n                  this.setAttributes({\n                    html: childHtml,\n                    element: child,\n                    storage: storage,\n                    intent: intent,\n                    linkService: linkService\n                  });\n                }\n                if (child.children && child.children.length > 0) {\n                  stack.push([child, -1, childHtml]);\n                } else if (child.value) {\n                  var _node = document.createTextNode(child.value);\n                  if (_xfa_text.XfaText.shouldBuildText(name)) {\n                    textDivs.push(_node);\n                  }\n                  childHtml.append(_node);\n                }\n              }\n              var _iterator123 = _createForOfIteratorHelper(rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")),\n                _step123;\n              try {\n                for (_iterator123.s(); !(_step123 = _iterator123.n()).done;) {\n                  var el = _step123.value;\n                  el.setAttribute(\"readOnly\", true);\n                }\n              } catch (err) {\n                _iterator123.e(err);\n              } finally {\n                _iterator123.f();\n              }\n              return {\n                textDivs: textDivs\n              };\n            }\n          }, {\n            key: \"update\",\n            value: function update(parameters) {\n              var transform = \"matrix(\".concat(parameters.viewport.transform.join(\",\"), \")\");\n              parameters.div.style.transform = transform;\n              parameters.div.hidden = false;\n            }\n          }]);\n          return XfaLayer;\n        }();\n        exports.XfaLayer = XfaLayer;\n\n        /***/\n      }, /* 35 */\n      /***/function (__unused_webpack_module, exports, __w_pdfjs_require__) {\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.SVGGraphics = void 0;\n        var _display_utils = __w_pdfjs_require__(6);\n        var _util = __w_pdfjs_require__(1);\n        var _is_node = __w_pdfjs_require__(10);\n        var SVGGraphics = /*#__PURE__*/_createClass(function SVGGraphics() {\n          _classCallCheck(this, SVGGraphics);\n          (0, _util.unreachable)(\"Not implemented: SVGGraphics\");\n        });\n        exports.SVGGraphics = SVGGraphics;\n        {\n          var opListToTree = function opListToTree(opList) {\n            var opTree = [];\n            var tmp = [];\n            var _iterator124 = _createForOfIteratorHelper(opList),\n              _step124;\n            try {\n              for (_iterator124.s(); !(_step124 = _iterator124.n()).done;) {\n                var opListElement = _step124.value;\n                if (opListElement.fn === \"save\") {\n                  opTree.push({\n                    fnId: 92,\n                    fn: \"group\",\n                    items: []\n                  });\n                  tmp.push(opTree);\n                  opTree = opTree.at(-1).items;\n                  continue;\n                }\n                if (opListElement.fn === \"restore\") {\n                  opTree = tmp.pop();\n                } else {\n                  opTree.push(opListElement);\n                }\n              }\n            } catch (err) {\n              _iterator124.e(err);\n            } finally {\n              _iterator124.f();\n            }\n            return opTree;\n          };\n          var pf = function pf(value) {\n            if (Number.isInteger(value)) {\n              return value.toString();\n            }\n            var s = value.toFixed(10);\n            var i = s.length - 1;\n            if (s[i] !== \"0\") {\n              return s;\n            }\n            do {\n              i--;\n            } while (s[i] === \"0\");\n            return s.substring(0, s[i] === \".\" ? i : i + 1);\n          };\n          var pm = function pm(m) {\n            if (m[4] === 0 && m[5] === 0) {\n              if (m[1] === 0 && m[2] === 0) {\n                if (m[0] === 1 && m[3] === 1) {\n                  return \"\";\n                }\n                return \"scale(\".concat(pf(m[0]), \" \").concat(pf(m[3]), \")\");\n              }\n              if (m[0] === m[3] && m[1] === -m[2]) {\n                var a = Math.acos(m[0]) * 180 / Math.PI;\n                return \"rotate(\".concat(pf(a), \")\");\n              }\n            } else {\n              if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n                return \"translate(\".concat(pf(m[4]), \" \").concat(pf(m[5]), \")\");\n              }\n            }\n            return \"matrix(\".concat(pf(m[0]), \" \").concat(pf(m[1]), \" \").concat(pf(m[2]), \" \").concat(pf(m[3]), \" \").concat(pf(m[4]), \" \") + \"\".concat(pf(m[5]), \")\");\n          };\n          var SVG_DEFAULTS = {\n            fontStyle: \"normal\",\n            fontWeight: \"normal\",\n            fillColor: \"#000000\"\n          };\n          var XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n          var XLINK_NS = \"http://www.w3.org/1999/xlink\";\n          var LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n          var LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n          var createObjectURL = function createObjectURL(data) {\n            var contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n            var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n              return URL.createObjectURL(new Blob([data], {\n                type: contentType\n              }));\n            }\n            var digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n            var buffer = \"data:\".concat(contentType, \";base64,\");\n            for (var i = 0, ii = data.length; i < ii; i += 3) {\n              var b1 = data[i] & 0xff;\n              var b2 = data[i + 1] & 0xff;\n              var b3 = data[i + 2] & 0xff;\n              var d1 = b1 >> 2,\n                d2 = (b1 & 3) << 4 | b2 >> 4;\n              var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n              var d4 = i + 2 < ii ? b3 & 0x3f : 64;\n              buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n            }\n            return buffer;\n          };\n          var convertImgDataToPng = function () {\n            var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n            var CHUNK_WRAPPER_SIZE = 12;\n            var crcTable = new Int32Array(256);\n            for (var i = 0; i < 256; i++) {\n              var c = i;\n              for (var h = 0; h < 8; h++) {\n                if (c & 1) {\n                  c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n                } else {\n                  c = c >> 1 & 0x7fffffff;\n                }\n              }\n              crcTable[i] = c;\n            }\n            function crc32(data, start, end) {\n              var crc = -1;\n              for (var _i19 = start; _i19 < end; _i19++) {\n                var a = (crc ^ data[_i19]) & 0xff;\n                var b = crcTable[a];\n                crc = crc >>> 8 ^ b;\n              }\n              return crc ^ -1;\n            }\n            function writePngChunk(type, body, data, offset) {\n              var p = offset;\n              var len = body.length;\n              data[p] = len >> 24 & 0xff;\n              data[p + 1] = len >> 16 & 0xff;\n              data[p + 2] = len >> 8 & 0xff;\n              data[p + 3] = len & 0xff;\n              p += 4;\n              data[p] = type.charCodeAt(0) & 0xff;\n              data[p + 1] = type.charCodeAt(1) & 0xff;\n              data[p + 2] = type.charCodeAt(2) & 0xff;\n              data[p + 3] = type.charCodeAt(3) & 0xff;\n              p += 4;\n              data.set(body, p);\n              p += body.length;\n              var crc = crc32(data, offset + 4, p);\n              data[p] = crc >> 24 & 0xff;\n              data[p + 1] = crc >> 16 & 0xff;\n              data[p + 2] = crc >> 8 & 0xff;\n              data[p + 3] = crc & 0xff;\n            }\n            function adler32(data, start, end) {\n              var a = 1;\n              var b = 0;\n              for (var _i20 = start; _i20 < end; ++_i20) {\n                a = (a + (data[_i20] & 0xff)) % 65521;\n                b = (b + a) % 65521;\n              }\n              return b << 16 | a;\n            }\n            function deflateSync(literals) {\n              if (!_is_node.isNodeJS) {\n                return deflateSyncUncompressed(literals);\n              }\n              try {\n                var input;\n                if (parseInt(process.versions.node) >= 8) {\n                  input = literals;\n                } else {\n                  input = Buffer.from(literals);\n                }\n                var output = require(\"zlib\").deflateSync(input, {\n                  level: 9\n                });\n                return output instanceof Uint8Array ? output : new Uint8Array(output);\n              } catch (e) {\n                (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n              }\n              return deflateSyncUncompressed(literals);\n            }\n            function deflateSyncUncompressed(literals) {\n              var len = literals.length;\n              var maxBlockLength = 0xffff;\n              var deflateBlocks = Math.ceil(len / maxBlockLength);\n              var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n              var pi = 0;\n              idat[pi++] = 0x78;\n              idat[pi++] = 0x9c;\n              var pos = 0;\n              while (len > maxBlockLength) {\n                idat[pi++] = 0x00;\n                idat[pi++] = 0xff;\n                idat[pi++] = 0xff;\n                idat[pi++] = 0x00;\n                idat[pi++] = 0x00;\n                idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n                pi += maxBlockLength;\n                pos += maxBlockLength;\n                len -= maxBlockLength;\n              }\n              idat[pi++] = 0x01;\n              idat[pi++] = len & 0xff;\n              idat[pi++] = len >> 8 & 0xff;\n              idat[pi++] = ~len & 0xffff & 0xff;\n              idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n              idat.set(literals.subarray(pos), pi);\n              pi += literals.length - pos;\n              var adler = adler32(literals, 0, literals.length);\n              idat[pi++] = adler >> 24 & 0xff;\n              idat[pi++] = adler >> 16 & 0xff;\n              idat[pi++] = adler >> 8 & 0xff;\n              idat[pi++] = adler & 0xff;\n              return idat;\n            }\n            function encode(imgData, kind, forceDataSchema, isMask) {\n              var width = imgData.width;\n              var height = imgData.height;\n              var bitDepth, colorType, lineSize;\n              var bytes = imgData.data;\n              switch (kind) {\n                case _util.ImageKind.GRAYSCALE_1BPP:\n                  colorType = 0;\n                  bitDepth = 1;\n                  lineSize = width + 7 >> 3;\n                  break;\n                case _util.ImageKind.RGB_24BPP:\n                  colorType = 2;\n                  bitDepth = 8;\n                  lineSize = width * 3;\n                  break;\n                case _util.ImageKind.RGBA_32BPP:\n                  colorType = 6;\n                  bitDepth = 8;\n                  lineSize = width * 4;\n                  break;\n                default:\n                  throw new Error(\"invalid format\");\n              }\n              var literals = new Uint8Array((1 + lineSize) * height);\n              var offsetLiterals = 0,\n                offsetBytes = 0;\n              for (var y = 0; y < height; ++y) {\n                literals[offsetLiterals++] = 0;\n                literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n                offsetBytes += lineSize;\n                offsetLiterals += lineSize;\n              }\n              if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n                offsetLiterals = 0;\n                for (var _y = 0; _y < height; _y++) {\n                  offsetLiterals++;\n                  for (var _i21 = 0; _i21 < lineSize; _i21++) {\n                    literals[offsetLiterals++] ^= 0xff;\n                  }\n                }\n              }\n              var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n              var idat = deflateSync(literals);\n              var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n              var data = new Uint8Array(pngLength);\n              var offset = 0;\n              data.set(PNG_HEADER, offset);\n              offset += PNG_HEADER.length;\n              writePngChunk(\"IHDR\", ihdr, data, offset);\n              offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n              writePngChunk(\"IDATA\", idat, data, offset);\n              offset += CHUNK_WRAPPER_SIZE + idat.length;\n              writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n              return createObjectURL(data, \"image/png\", forceDataSchema);\n            }\n            return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n              var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n              return encode(imgData, kind, forceDataSchema, isMask);\n            };\n          }();\n          var SVGExtraState = /*#__PURE__*/function () {\n            function SVGExtraState() {\n              _classCallCheck(this, SVGExtraState);\n              this.fontSizeScale = 1;\n              this.fontWeight = SVG_DEFAULTS.fontWeight;\n              this.fontSize = 0;\n              this.textMatrix = _util.IDENTITY_MATRIX;\n              this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n              this.leading = 0;\n              this.textRenderingMode = _util.TextRenderingMode.FILL;\n              this.textMatrixScale = 1;\n              this.x = 0;\n              this.y = 0;\n              this.lineX = 0;\n              this.lineY = 0;\n              this.charSpacing = 0;\n              this.wordSpacing = 0;\n              this.textHScale = 1;\n              this.textRise = 0;\n              this.fillColor = SVG_DEFAULTS.fillColor;\n              this.strokeColor = \"#000000\";\n              this.fillAlpha = 1;\n              this.strokeAlpha = 1;\n              this.lineWidth = 1;\n              this.lineJoin = \"\";\n              this.lineCap = \"\";\n              this.miterLimit = 0;\n              this.dashArray = [];\n              this.dashPhase = 0;\n              this.dependencies = [];\n              this.activeClipUrl = null;\n              this.clipGroup = null;\n              this.maskId = \"\";\n            }\n            _createClass(SVGExtraState, [{\n              key: \"clone\",\n              value: function clone() {\n                return Object.create(this);\n              }\n            }, {\n              key: \"setCurrentPoint\",\n              value: function setCurrentPoint(x, y) {\n                this.x = x;\n                this.y = y;\n              }\n            }]);\n            return SVGExtraState;\n          }();\n          var clipCount = 0;\n          var maskCount = 0;\n          var shadingCount = 0;\n          exports.SVGGraphics = SVGGraphics = /*#__PURE__*/function () {\n            function SVGGraphics(commonObjs, objs) {\n              var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n              _classCallCheck(this, SVGGraphics);\n              (0, _display_utils.deprecated)(\"The SVG back-end is no longer maintained and *may* be removed in the future.\");\n              this.svgFactory = new _display_utils.DOMSVGFactory();\n              this.current = new SVGExtraState();\n              this.transformMatrix = _util.IDENTITY_MATRIX;\n              this.transformStack = [];\n              this.extraStack = [];\n              this.commonObjs = commonObjs;\n              this.objs = objs;\n              this.pendingClip = null;\n              this.pendingEOFill = false;\n              this.embedFonts = false;\n              this.embeddedFonts = Object.create(null);\n              this.cssStyle = null;\n              this.forceDataSchema = !!forceDataSchema;\n              this._operatorIdMapping = [];\n              for (var op in _util.OPS) {\n                this._operatorIdMapping[_util.OPS[op]] = op;\n              }\n            }\n            _createClass(SVGGraphics, [{\n              key: \"getObject\",\n              value: function getObject(data) {\n                var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n                if (typeof data === \"string\") {\n                  return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n                }\n                return fallback;\n              }\n            }, {\n              key: \"save\",\n              value: function save() {\n                this.transformStack.push(this.transformMatrix);\n                var old = this.current;\n                this.extraStack.push(old);\n                this.current = old.clone();\n              }\n            }, {\n              key: \"restore\",\n              value: function restore() {\n                this.transformMatrix = this.transformStack.pop();\n                this.current = this.extraStack.pop();\n                this.pendingClip = null;\n                this.tgrp = null;\n              }\n            }, {\n              key: \"group\",\n              value: function group(items) {\n                this.save();\n                this.executeOpTree(items);\n                this.restore();\n              }\n            }, {\n              key: \"loadDependencies\",\n              value: function loadDependencies(operatorList) {\n                var _this82 = this;\n                var fnArray = operatorList.fnArray;\n                var argsArray = operatorList.argsArray;\n                for (var i = 0, ii = fnArray.length; i < ii; i++) {\n                  if (fnArray[i] !== _util.OPS.dependency) {\n                    continue;\n                  }\n                  var _iterator125 = _createForOfIteratorHelper(argsArray[i]),\n                    _step125;\n                  try {\n                    var _loop2 = function _loop2() {\n                      var obj = _step125.value;\n                      var objsPool = obj.startsWith(\"g_\") ? _this82.commonObjs : _this82.objs;\n                      var promise = new Promise(function (resolve) {\n                        objsPool.get(obj, resolve);\n                      });\n                      _this82.current.dependencies.push(promise);\n                    };\n                    for (_iterator125.s(); !(_step125 = _iterator125.n()).done;) {\n                      _loop2();\n                    }\n                  } catch (err) {\n                    _iterator125.e(err);\n                  } finally {\n                    _iterator125.f();\n                  }\n                }\n                return Promise.all(this.current.dependencies);\n              }\n            }, {\n              key: \"transform\",\n              value: function transform(a, b, c, d, e, f) {\n                var transformMatrix = [a, b, c, d, e, f];\n                this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n                this.tgrp = null;\n              }\n            }, {\n              key: \"getSVG\",\n              value: function getSVG(operatorList, viewport) {\n                var _this83 = this;\n                this.viewport = viewport;\n                var svgElement = this._initialize(viewport);\n                return this.loadDependencies(operatorList).then(function () {\n                  _this83.transformMatrix = _util.IDENTITY_MATRIX;\n                  _this83.executeOpTree(_this83.convertOpList(operatorList));\n                  return svgElement;\n                });\n              }\n            }, {\n              key: \"convertOpList\",\n              value: function convertOpList(operatorList) {\n                var operatorIdMapping = this._operatorIdMapping;\n                var argsArray = operatorList.argsArray;\n                var fnArray = operatorList.fnArray;\n                var opList = [];\n                for (var i = 0, ii = fnArray.length; i < ii; i++) {\n                  var fnId = fnArray[i];\n                  opList.push({\n                    fnId: fnId,\n                    fn: operatorIdMapping[fnId],\n                    args: argsArray[i]\n                  });\n                }\n                return opListToTree(opList);\n              }\n            }, {\n              key: \"executeOpTree\",\n              value: function executeOpTree(opTree) {\n                var _iterator126 = _createForOfIteratorHelper(opTree),\n                  _step126;\n                try {\n                  for (_iterator126.s(); !(_step126 = _iterator126.n()).done;) {\n                    var opTreeElement = _step126.value;\n                    var fn = opTreeElement.fn;\n                    var fnId = opTreeElement.fnId;\n                    var args = opTreeElement.args;\n                    switch (fnId | 0) {\n                      case _util.OPS.beginText:\n                        this.beginText();\n                        break;\n                      case _util.OPS.dependency:\n                        break;\n                      case _util.OPS.setLeading:\n                        this.setLeading(args);\n                        break;\n                      case _util.OPS.setLeadingMoveText:\n                        this.setLeadingMoveText(args[0], args[1]);\n                        break;\n                      case _util.OPS.setFont:\n                        this.setFont(args);\n                        break;\n                      case _util.OPS.showText:\n                        this.showText(args[0]);\n                        break;\n                      case _util.OPS.showSpacedText:\n                        this.showText(args[0]);\n                        break;\n                      case _util.OPS.endText:\n                        this.endText();\n                        break;\n                      case _util.OPS.moveText:\n                        this.moveText(args[0], args[1]);\n                        break;\n                      case _util.OPS.setCharSpacing:\n                        this.setCharSpacing(args[0]);\n                        break;\n                      case _util.OPS.setWordSpacing:\n                        this.setWordSpacing(args[0]);\n                        break;\n                      case _util.OPS.setHScale:\n                        this.setHScale(args[0]);\n                        break;\n                      case _util.OPS.setTextMatrix:\n                        this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n                        break;\n                      case _util.OPS.setTextRise:\n                        this.setTextRise(args[0]);\n                        break;\n                      case _util.OPS.setTextRenderingMode:\n                        this.setTextRenderingMode(args[0]);\n                        break;\n                      case _util.OPS.setLineWidth:\n                        this.setLineWidth(args[0]);\n                        break;\n                      case _util.OPS.setLineJoin:\n                        this.setLineJoin(args[0]);\n                        break;\n                      case _util.OPS.setLineCap:\n                        this.setLineCap(args[0]);\n                        break;\n                      case _util.OPS.setMiterLimit:\n                        this.setMiterLimit(args[0]);\n                        break;\n                      case _util.OPS.setFillRGBColor:\n                        this.setFillRGBColor(args[0], args[1], args[2]);\n                        break;\n                      case _util.OPS.setStrokeRGBColor:\n                        this.setStrokeRGBColor(args[0], args[1], args[2]);\n                        break;\n                      case _util.OPS.setStrokeColorN:\n                        this.setStrokeColorN(args);\n                        break;\n                      case _util.OPS.setFillColorN:\n                        this.setFillColorN(args);\n                        break;\n                      case _util.OPS.shadingFill:\n                        this.shadingFill(args[0]);\n                        break;\n                      case _util.OPS.setDash:\n                        this.setDash(args[0], args[1]);\n                        break;\n                      case _util.OPS.setRenderingIntent:\n                        this.setRenderingIntent(args[0]);\n                        break;\n                      case _util.OPS.setFlatness:\n                        this.setFlatness(args[0]);\n                        break;\n                      case _util.OPS.setGState:\n                        this.setGState(args[0]);\n                        break;\n                      case _util.OPS.fill:\n                        this.fill();\n                        break;\n                      case _util.OPS.eoFill:\n                        this.eoFill();\n                        break;\n                      case _util.OPS.stroke:\n                        this.stroke();\n                        break;\n                      case _util.OPS.fillStroke:\n                        this.fillStroke();\n                        break;\n                      case _util.OPS.eoFillStroke:\n                        this.eoFillStroke();\n                        break;\n                      case _util.OPS.clip:\n                        this.clip(\"nonzero\");\n                        break;\n                      case _util.OPS.eoClip:\n                        this.clip(\"evenodd\");\n                        break;\n                      case _util.OPS.paintSolidColorImageMask:\n                        this.paintSolidColorImageMask();\n                        break;\n                      case _util.OPS.paintImageXObject:\n                        this.paintImageXObject(args[0]);\n                        break;\n                      case _util.OPS.paintInlineImageXObject:\n                        this.paintInlineImageXObject(args[0]);\n                        break;\n                      case _util.OPS.paintImageMaskXObject:\n                        this.paintImageMaskXObject(args[0]);\n                        break;\n                      case _util.OPS.paintFormXObjectBegin:\n                        this.paintFormXObjectBegin(args[0], args[1]);\n                        break;\n                      case _util.OPS.paintFormXObjectEnd:\n                        this.paintFormXObjectEnd();\n                        break;\n                      case _util.OPS.closePath:\n                        this.closePath();\n                        break;\n                      case _util.OPS.closeStroke:\n                        this.closeStroke();\n                        break;\n                      case _util.OPS.closeFillStroke:\n                        this.closeFillStroke();\n                        break;\n                      case _util.OPS.closeEOFillStroke:\n                        this.closeEOFillStroke();\n                        break;\n                      case _util.OPS.nextLine:\n                        this.nextLine();\n                        break;\n                      case _util.OPS.transform:\n                        this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n                        break;\n                      case _util.OPS.constructPath:\n                        this.constructPath(args[0], args[1]);\n                        break;\n                      case _util.OPS.endPath:\n                        this.endPath();\n                        break;\n                      case 92:\n                        this.group(opTreeElement.items);\n                        break;\n                      default:\n                        (0, _util.warn)(\"Unimplemented operator \".concat(fn));\n                        break;\n                    }\n                  }\n                } catch (err) {\n                  _iterator126.e(err);\n                } finally {\n                  _iterator126.f();\n                }\n              }\n            }, {\n              key: \"setWordSpacing\",\n              value: function setWordSpacing(wordSpacing) {\n                this.current.wordSpacing = wordSpacing;\n              }\n            }, {\n              key: \"setCharSpacing\",\n              value: function setCharSpacing(charSpacing) {\n                this.current.charSpacing = charSpacing;\n              }\n            }, {\n              key: \"nextLine\",\n              value: function nextLine() {\n                this.moveText(0, this.current.leading);\n              }\n            }, {\n              key: \"setTextMatrix\",\n              value: function setTextMatrix(a, b, c, d, e, f) {\n                var current = this.current;\n                current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n                current.textMatrixScale = Math.hypot(a, b);\n                current.x = current.lineX = 0;\n                current.y = current.lineY = 0;\n                current.xcoords = [];\n                current.ycoords = [];\n                current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n                current.tspan.setAttributeNS(null, \"font-size\", \"\".concat(pf(current.fontSize), \"px\"));\n                current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                current.txtElement = this.svgFactory.createElement(\"svg:text\");\n                current.txtElement.append(current.tspan);\n              }\n            }, {\n              key: \"beginText\",\n              value: function beginText() {\n                var current = this.current;\n                current.x = current.lineX = 0;\n                current.y = current.lineY = 0;\n                current.textMatrix = _util.IDENTITY_MATRIX;\n                current.lineMatrix = _util.IDENTITY_MATRIX;\n                current.textMatrixScale = 1;\n                current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                current.txtElement = this.svgFactory.createElement(\"svg:text\");\n                current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n                current.xcoords = [];\n                current.ycoords = [];\n              }\n            }, {\n              key: \"moveText\",\n              value: function moveText(x, y) {\n                var current = this.current;\n                current.x = current.lineX += x;\n                current.y = current.lineY += y;\n                current.xcoords = [];\n                current.ycoords = [];\n                current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n                current.tspan.setAttributeNS(null, \"font-size\", \"\".concat(pf(current.fontSize), \"px\"));\n                current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n              }\n            }, {\n              key: \"showText\",\n              value: function showText(glyphs) {\n                var current = this.current;\n                var font = current.font;\n                var fontSize = current.fontSize;\n                if (fontSize === 0) {\n                  return;\n                }\n                var fontSizeScale = current.fontSizeScale;\n                var charSpacing = current.charSpacing;\n                var wordSpacing = current.wordSpacing;\n                var fontDirection = current.fontDirection;\n                var textHScale = current.textHScale * fontDirection;\n                var vertical = font.vertical;\n                var spacingDir = vertical ? 1 : -1;\n                var defaultVMetrics = font.defaultVMetrics;\n                var widthAdvanceScale = fontSize * current.fontMatrix[0];\n                var x = 0;\n                var _iterator127 = _createForOfIteratorHelper(glyphs),\n                  _step127;\n                try {\n                  for (_iterator127.s(); !(_step127 = _iterator127.n()).done;) {\n                    var glyph = _step127.value;\n                    if (glyph === null) {\n                      x += fontDirection * wordSpacing;\n                      continue;\n                    } else if (typeof glyph === \"number\") {\n                      x += spacingDir * glyph * fontSize / 1000;\n                      continue;\n                    }\n                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                    var character = glyph.fontChar;\n                    var scaledX = void 0,\n                      scaledY = void 0;\n                    var width = glyph.width;\n                    if (vertical) {\n                      var vx = void 0;\n                      var vmetric = glyph.vmetric || defaultVMetrics;\n                      vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n                      vx = -vx * widthAdvanceScale;\n                      var vy = vmetric[2] * widthAdvanceScale;\n                      width = vmetric ? -vmetric[0] : width;\n                      scaledX = vx / fontSizeScale;\n                      scaledY = (x + vy) / fontSizeScale;\n                    } else {\n                      scaledX = x / fontSizeScale;\n                      scaledY = 0;\n                    }\n                    if (glyph.isInFont || font.missingFile) {\n                      current.xcoords.push(current.x + scaledX);\n                      if (vertical) {\n                        current.ycoords.push(-current.y + scaledY);\n                      }\n                      current.tspan.textContent += character;\n                    } else {}\n                    var charWidth = void 0;\n                    if (vertical) {\n                      charWidth = width * widthAdvanceScale - spacing * fontDirection;\n                    } else {\n                      charWidth = width * widthAdvanceScale + spacing * fontDirection;\n                    }\n                    x += charWidth;\n                  }\n                } catch (err) {\n                  _iterator127.e(err);\n                } finally {\n                  _iterator127.f();\n                }\n                current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n                if (vertical) {\n                  current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n                } else {\n                  current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                }\n                if (vertical) {\n                  current.y -= x;\n                } else {\n                  current.x += x * textHScale;\n                }\n                current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n                current.tspan.setAttributeNS(null, \"font-size\", \"\".concat(pf(current.fontSize), \"px\"));\n                if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n                  current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n                }\n                if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n                  current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n                }\n                var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n                if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                  if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n                    current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n                  }\n                  if (current.fillAlpha < 1) {\n                    current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n                  }\n                } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n                  current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n                } else {\n                  current.tspan.setAttributeNS(null, \"fill\", \"none\");\n                }\n                if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                  var lineWidthScale = 1 / (current.textMatrixScale || 1);\n                  this._setStrokeAttributes(current.tspan, lineWidthScale);\n                }\n                var textMatrix = current.textMatrix;\n                if (current.textRise !== 0) {\n                  textMatrix = textMatrix.slice();\n                  textMatrix[5] += current.textRise;\n                }\n                current.txtElement.setAttributeNS(null, \"transform\", \"\".concat(pm(textMatrix), \" scale(\").concat(pf(textHScale), \", -1)\"));\n                current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n                current.txtElement.append(current.tspan);\n                current.txtgrp.append(current.txtElement);\n                this._ensureTransformGroup().append(current.txtElement);\n              }\n            }, {\n              key: \"setLeadingMoveText\",\n              value: function setLeadingMoveText(x, y) {\n                this.setLeading(-y);\n                this.moveText(x, y);\n              }\n            }, {\n              key: \"addFontStyle\",\n              value: function addFontStyle(fontObj) {\n                if (!fontObj.data) {\n                  throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n                }\n                if (!this.cssStyle) {\n                  this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n                  this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n                  this.defs.append(this.cssStyle);\n                }\n                var url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n                this.cssStyle.textContent += \"@font-face { font-family: \\\"\".concat(fontObj.loadedName, \"\\\";\") + \" src: url(\".concat(url, \"); }\\n\");\n              }\n            }, {\n              key: \"setFont\",\n              value: function setFont(details) {\n                var current = this.current;\n                var fontObj = this.commonObjs.get(details[0]);\n                var size = details[1];\n                current.font = fontObj;\n                if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n                  this.addFontStyle(fontObj);\n                  this.embeddedFonts[fontObj.loadedName] = fontObj;\n                }\n                current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n                var bold = \"normal\";\n                if (fontObj.black) {\n                  bold = \"900\";\n                } else if (fontObj.bold) {\n                  bold = \"bold\";\n                }\n                var italic = fontObj.italic ? \"italic\" : \"normal\";\n                if (size < 0) {\n                  size = -size;\n                  current.fontDirection = -1;\n                } else {\n                  current.fontDirection = 1;\n                }\n                current.fontSize = size;\n                current.fontFamily = fontObj.loadedName;\n                current.fontWeight = bold;\n                current.fontStyle = italic;\n                current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                current.xcoords = [];\n                current.ycoords = [];\n              }\n            }, {\n              key: \"endText\",\n              value: function endText() {\n                var _current$txtElement;\n                var current = this.current;\n                if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {\n                  current.element = current.txtElement;\n                  this.clip(\"nonzero\");\n                  this.endPath();\n                }\n              }\n            }, {\n              key: \"setLineWidth\",\n              value: function setLineWidth(width) {\n                if (width > 0) {\n                  this.current.lineWidth = width;\n                }\n              }\n            }, {\n              key: \"setLineCap\",\n              value: function setLineCap(style) {\n                this.current.lineCap = LINE_CAP_STYLES[style];\n              }\n            }, {\n              key: \"setLineJoin\",\n              value: function setLineJoin(style) {\n                this.current.lineJoin = LINE_JOIN_STYLES[style];\n              }\n            }, {\n              key: \"setMiterLimit\",\n              value: function setMiterLimit(limit) {\n                this.current.miterLimit = limit;\n              }\n            }, {\n              key: \"setStrokeAlpha\",\n              value: function setStrokeAlpha(strokeAlpha) {\n                this.current.strokeAlpha = strokeAlpha;\n              }\n            }, {\n              key: \"setStrokeRGBColor\",\n              value: function setStrokeRGBColor(r, g, b) {\n                this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n              }\n            }, {\n              key: \"setFillAlpha\",\n              value: function setFillAlpha(fillAlpha) {\n                this.current.fillAlpha = fillAlpha;\n              }\n            }, {\n              key: \"setFillRGBColor\",\n              value: function setFillRGBColor(r, g, b) {\n                this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n                this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                this.current.xcoords = [];\n                this.current.ycoords = [];\n              }\n            }, {\n              key: \"setStrokeColorN\",\n              value: function setStrokeColorN(args) {\n                this.current.strokeColor = this._makeColorN_Pattern(args);\n              }\n            }, {\n              key: \"setFillColorN\",\n              value: function setFillColorN(args) {\n                this.current.fillColor = this._makeColorN_Pattern(args);\n              }\n            }, {\n              key: \"shadingFill\",\n              value: function shadingFill(args) {\n                var width = this.viewport.width;\n                var height = this.viewport.height;\n                var inv = _util.Util.inverseTransform(this.transformMatrix);\n                var bl = _util.Util.applyTransform([0, 0], inv);\n                var br = _util.Util.applyTransform([0, height], inv);\n                var ul = _util.Util.applyTransform([width, 0], inv);\n                var ur = _util.Util.applyTransform([width, height], inv);\n                var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n                var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n                var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n                var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n                var rect = this.svgFactory.createElement(\"svg:rect\");\n                rect.setAttributeNS(null, \"x\", x0);\n                rect.setAttributeNS(null, \"y\", y0);\n                rect.setAttributeNS(null, \"width\", x1 - x0);\n                rect.setAttributeNS(null, \"height\", y1 - y0);\n                rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n                if (this.current.fillAlpha < 1) {\n                  rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n                }\n                this._ensureTransformGroup().append(rect);\n              }\n            }, {\n              key: \"_makeColorN_Pattern\",\n              value: function _makeColorN_Pattern(args) {\n                if (args[0] === \"TilingPattern\") {\n                  return this._makeTilingPattern(args);\n                }\n                return this._makeShadingPattern(args);\n              }\n            }, {\n              key: \"_makeTilingPattern\",\n              value: function _makeTilingPattern(args) {\n                var color = args[1];\n                var operatorList = args[2];\n                var matrix = args[3] || _util.IDENTITY_MATRIX;\n                var _args$ = _slicedToArray(args[4], 4),\n                  x0 = _args$[0],\n                  y0 = _args$[1],\n                  x1 = _args$[2],\n                  y1 = _args$[3];\n                var xstep = args[5];\n                var ystep = args[6];\n                var paintType = args[7];\n                var tilingId = \"shading\".concat(shadingCount++);\n                var _util$Util$normalizeR = _util.Util.normalizeRect([].concat(_toConsumableArray(_util.Util.applyTransform([x0, y0], matrix)), _toConsumableArray(_util.Util.applyTransform([x1, y1], matrix)))),\n                  _util$Util$normalizeR2 = _slicedToArray(_util$Util$normalizeR, 4),\n                  tx0 = _util$Util$normalizeR2[0],\n                  ty0 = _util$Util$normalizeR2[1],\n                  tx1 = _util$Util$normalizeR2[2],\n                  ty1 = _util$Util$normalizeR2[3];\n                var _util$Util$singularVa3 = _util.Util.singularValueDecompose2dScale(matrix),\n                  _util$Util$singularVa4 = _slicedToArray(_util$Util$singularVa3, 2),\n                  xscale = _util$Util$singularVa4[0],\n                  yscale = _util$Util$singularVa4[1];\n                var txstep = xstep * xscale;\n                var tystep = ystep * yscale;\n                var tiling = this.svgFactory.createElement(\"svg:pattern\");\n                tiling.setAttributeNS(null, \"id\", tilingId);\n                tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n                tiling.setAttributeNS(null, \"width\", txstep);\n                tiling.setAttributeNS(null, \"height\", tystep);\n                tiling.setAttributeNS(null, \"x\", \"\".concat(tx0));\n                tiling.setAttributeNS(null, \"y\", \"\".concat(ty0));\n                var svg = this.svg;\n                var transformMatrix = this.transformMatrix;\n                var fillColor = this.current.fillColor;\n                var strokeColor = this.current.strokeColor;\n                var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n                this.svg = bbox;\n                this.transformMatrix = matrix;\n                if (paintType === 2) {\n                  var _util$Util7;\n                  var cssColor = (_util$Util7 = _util.Util).makeHexColor.apply(_util$Util7, _toConsumableArray(color));\n                  this.current.fillColor = cssColor;\n                  this.current.strokeColor = cssColor;\n                }\n                this.executeOpTree(this.convertOpList(operatorList));\n                this.svg = svg;\n                this.transformMatrix = transformMatrix;\n                this.current.fillColor = fillColor;\n                this.current.strokeColor = strokeColor;\n                tiling.append(bbox.childNodes[0]);\n                this.defs.append(tiling);\n                return \"url(#\".concat(tilingId, \")\");\n              }\n            }, {\n              key: \"_makeShadingPattern\",\n              value: function _makeShadingPattern(args) {\n                if (typeof args === \"string\") {\n                  args = this.objs.get(args);\n                }\n                switch (args[0]) {\n                  case \"RadialAxial\":\n                    var shadingId = \"shading\".concat(shadingCount++);\n                    var colorStops = args[3];\n                    var gradient;\n                    switch (args[1]) {\n                      case \"axial\":\n                        var point0 = args[4];\n                        var point1 = args[5];\n                        gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n                        gradient.setAttributeNS(null, \"id\", shadingId);\n                        gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                        gradient.setAttributeNS(null, \"x1\", point0[0]);\n                        gradient.setAttributeNS(null, \"y1\", point0[1]);\n                        gradient.setAttributeNS(null, \"x2\", point1[0]);\n                        gradient.setAttributeNS(null, \"y2\", point1[1]);\n                        break;\n                      case \"radial\":\n                        var focalPoint = args[4];\n                        var circlePoint = args[5];\n                        var focalRadius = args[6];\n                        var circleRadius = args[7];\n                        gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n                        gradient.setAttributeNS(null, \"id\", shadingId);\n                        gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                        gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n                        gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n                        gradient.setAttributeNS(null, \"r\", circleRadius);\n                        gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n                        gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n                        gradient.setAttributeNS(null, \"fr\", focalRadius);\n                        break;\n                      default:\n                        throw new Error(\"Unknown RadialAxial type: \".concat(args[1]));\n                    }\n                    var _iterator128 = _createForOfIteratorHelper(colorStops),\n                      _step128;\n                    try {\n                      for (_iterator128.s(); !(_step128 = _iterator128.n()).done;) {\n                        var colorStop = _step128.value;\n                        var stop = this.svgFactory.createElement(\"svg:stop\");\n                        stop.setAttributeNS(null, \"offset\", colorStop[0]);\n                        stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n                        gradient.append(stop);\n                      }\n                    } catch (err) {\n                      _iterator128.e(err);\n                    } finally {\n                      _iterator128.f();\n                    }\n                    this.defs.append(gradient);\n                    return \"url(#\".concat(shadingId, \")\");\n                  case \"Mesh\":\n                    (0, _util.warn)(\"Unimplemented pattern Mesh\");\n                    return null;\n                  case \"Dummy\":\n                    return \"hotpink\";\n                  default:\n                    throw new Error(\"Unknown IR type: \".concat(args[0]));\n                }\n              }\n            }, {\n              key: \"setDash\",\n              value: function setDash(dashArray, dashPhase) {\n                this.current.dashArray = dashArray;\n                this.current.dashPhase = dashPhase;\n              }\n            }, {\n              key: \"constructPath\",\n              value: function constructPath(ops, args) {\n                var current = this.current;\n                var x = current.x,\n                  y = current.y;\n                var d = [];\n                var j = 0;\n                var _iterator129 = _createForOfIteratorHelper(ops),\n                  _step129;\n                try {\n                  for (_iterator129.s(); !(_step129 = _iterator129.n()).done;) {\n                    var op = _step129.value;\n                    switch (op | 0) {\n                      case _util.OPS.rectangle:\n                        x = args[j++];\n                        y = args[j++];\n                        var width = args[j++];\n                        var height = args[j++];\n                        var xw = x + width;\n                        var yh = y + height;\n                        d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n                        break;\n                      case _util.OPS.moveTo:\n                        x = args[j++];\n                        y = args[j++];\n                        d.push(\"M\", pf(x), pf(y));\n                        break;\n                      case _util.OPS.lineTo:\n                        x = args[j++];\n                        y = args[j++];\n                        d.push(\"L\", pf(x), pf(y));\n                        break;\n                      case _util.OPS.curveTo:\n                        x = args[j + 4];\n                        y = args[j + 5];\n                        d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n                        j += 6;\n                        break;\n                      case _util.OPS.curveTo2:\n                        d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n                        x = args[j + 2];\n                        y = args[j + 3];\n                        j += 4;\n                        break;\n                      case _util.OPS.curveTo3:\n                        x = args[j + 2];\n                        y = args[j + 3];\n                        d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n                        j += 4;\n                        break;\n                      case _util.OPS.closePath:\n                        d.push(\"Z\");\n                        break;\n                    }\n                  }\n                } catch (err) {\n                  _iterator129.e(err);\n                } finally {\n                  _iterator129.f();\n                }\n                d = d.join(\" \");\n                if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n                  d = current.path.getAttributeNS(null, \"d\") + d;\n                } else {\n                  current.path = this.svgFactory.createElement(\"svg:path\");\n                  this._ensureTransformGroup().append(current.path);\n                }\n                current.path.setAttributeNS(null, \"d\", d);\n                current.path.setAttributeNS(null, \"fill\", \"none\");\n                current.element = current.path;\n                current.setCurrentPoint(x, y);\n              }\n            }, {\n              key: \"endPath\",\n              value: function endPath() {\n                var current = this.current;\n                current.path = null;\n                if (!this.pendingClip) {\n                  return;\n                }\n                if (!current.element) {\n                  this.pendingClip = null;\n                  return;\n                }\n                var clipId = \"clippath\".concat(clipCount++);\n                var clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n                clipPath.setAttributeNS(null, \"id\", clipId);\n                clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n                var clipElement = current.element.cloneNode(true);\n                if (this.pendingClip === \"evenodd\") {\n                  clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n                } else {\n                  clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n                }\n                this.pendingClip = null;\n                clipPath.append(clipElement);\n                this.defs.append(clipPath);\n                if (current.activeClipUrl) {\n                  current.clipGroup = null;\n                  var _iterator130 = _createForOfIteratorHelper(this.extraStack),\n                    _step130;\n                  try {\n                    for (_iterator130.s(); !(_step130 = _iterator130.n()).done;) {\n                      var prev = _step130.value;\n                      prev.clipGroup = null;\n                    }\n                  } catch (err) {\n                    _iterator130.e(err);\n                  } finally {\n                    _iterator130.f();\n                  }\n                  clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n                }\n                current.activeClipUrl = \"url(#\".concat(clipId, \")\");\n                this.tgrp = null;\n              }\n            }, {\n              key: \"clip\",\n              value: function clip(type) {\n                this.pendingClip = type;\n              }\n            }, {\n              key: \"closePath\",\n              value: function closePath() {\n                var current = this.current;\n                if (current.path) {\n                  var d = \"\".concat(current.path.getAttributeNS(null, \"d\"), \"Z\");\n                  current.path.setAttributeNS(null, \"d\", d);\n                }\n              }\n            }, {\n              key: \"setLeading\",\n              value: function setLeading(leading) {\n                this.current.leading = -leading;\n              }\n            }, {\n              key: \"setTextRise\",\n              value: function setTextRise(textRise) {\n                this.current.textRise = textRise;\n              }\n            }, {\n              key: \"setTextRenderingMode\",\n              value: function setTextRenderingMode(textRenderingMode) {\n                this.current.textRenderingMode = textRenderingMode;\n              }\n            }, {\n              key: \"setHScale\",\n              value: function setHScale(scale) {\n                this.current.textHScale = scale / 100;\n              }\n            }, {\n              key: \"setRenderingIntent\",\n              value: function setRenderingIntent(intent) {}\n            }, {\n              key: \"setFlatness\",\n              value: function setFlatness(flatness) {}\n            }, {\n              key: \"setGState\",\n              value: function setGState(states) {\n                var _iterator131 = _createForOfIteratorHelper(states),\n                  _step131;\n                try {\n                  for (_iterator131.s(); !(_step131 = _iterator131.n()).done;) {\n                    var _step131$value = _slicedToArray(_step131.value, 2),\n                      key = _step131$value[0],\n                      value = _step131$value[1];\n                    switch (key) {\n                      case \"LW\":\n                        this.setLineWidth(value);\n                        break;\n                      case \"LC\":\n                        this.setLineCap(value);\n                        break;\n                      case \"LJ\":\n                        this.setLineJoin(value);\n                        break;\n                      case \"ML\":\n                        this.setMiterLimit(value);\n                        break;\n                      case \"D\":\n                        this.setDash(value[0], value[1]);\n                        break;\n                      case \"RI\":\n                        this.setRenderingIntent(value);\n                        break;\n                      case \"FL\":\n                        this.setFlatness(value);\n                        break;\n                      case \"Font\":\n                        this.setFont(value);\n                        break;\n                      case \"CA\":\n                        this.setStrokeAlpha(value);\n                        break;\n                      case \"ca\":\n                        this.setFillAlpha(value);\n                        break;\n                      default:\n                        (0, _util.warn)(\"Unimplemented graphic state operator \".concat(key));\n                        break;\n                    }\n                  }\n                } catch (err) {\n                  _iterator131.e(err);\n                } finally {\n                  _iterator131.f();\n                }\n              }\n            }, {\n              key: \"fill\",\n              value: function fill() {\n                var current = this.current;\n                if (current.element) {\n                  current.element.setAttributeNS(null, \"fill\", current.fillColor);\n                  current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n                  this.endPath();\n                }\n              }\n            }, {\n              key: \"stroke\",\n              value: function stroke() {\n                var current = this.current;\n                if (current.element) {\n                  this._setStrokeAttributes(current.element);\n                  current.element.setAttributeNS(null, \"fill\", \"none\");\n                  this.endPath();\n                }\n              }\n            }, {\n              key: \"_setStrokeAttributes\",\n              value: function _setStrokeAttributes(element) {\n                var lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n                var current = this.current;\n                var dashArray = current.dashArray;\n                if (lineWidthScale !== 1 && dashArray.length > 0) {\n                  dashArray = dashArray.map(function (value) {\n                    return lineWidthScale * value;\n                  });\n                }\n                element.setAttributeNS(null, \"stroke\", current.strokeColor);\n                element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n                element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n                element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n                element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n                element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n                element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n                element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n              }\n            }, {\n              key: \"eoFill\",\n              value: function eoFill() {\n                var _this$current$element;\n                (_this$current$element = this.current.element) === null || _this$current$element === void 0 ? void 0 : _this$current$element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n                this.fill();\n              }\n            }, {\n              key: \"fillStroke\",\n              value: function fillStroke() {\n                this.stroke();\n                this.fill();\n              }\n            }, {\n              key: \"eoFillStroke\",\n              value: function eoFillStroke() {\n                var _this$current$element2;\n                (_this$current$element2 = this.current.element) === null || _this$current$element2 === void 0 ? void 0 : _this$current$element2.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n                this.fillStroke();\n              }\n            }, {\n              key: \"closeStroke\",\n              value: function closeStroke() {\n                this.closePath();\n                this.stroke();\n              }\n            }, {\n              key: \"closeFillStroke\",\n              value: function closeFillStroke() {\n                this.closePath();\n                this.fillStroke();\n              }\n            }, {\n              key: \"closeEOFillStroke\",\n              value: function closeEOFillStroke() {\n                this.closePath();\n                this.eoFillStroke();\n              }\n            }, {\n              key: \"paintSolidColorImageMask\",\n              value: function paintSolidColorImageMask() {\n                var rect = this.svgFactory.createElement(\"svg:rect\");\n                rect.setAttributeNS(null, \"x\", \"0\");\n                rect.setAttributeNS(null, \"y\", \"0\");\n                rect.setAttributeNS(null, \"width\", \"1px\");\n                rect.setAttributeNS(null, \"height\", \"1px\");\n                rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n                this._ensureTransformGroup().append(rect);\n              }\n            }, {\n              key: \"paintImageXObject\",\n              value: function paintImageXObject(objId) {\n                var imgData = this.getObject(objId);\n                if (!imgData) {\n                  (0, _util.warn)(\"Dependent image with object ID \".concat(objId, \" is not ready yet\"));\n                  return;\n                }\n                this.paintInlineImageXObject(imgData);\n              }\n            }, {\n              key: \"paintInlineImageXObject\",\n              value: function paintInlineImageXObject(imgData, mask) {\n                var width = imgData.width;\n                var height = imgData.height;\n                var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n                var cliprect = this.svgFactory.createElement(\"svg:rect\");\n                cliprect.setAttributeNS(null, \"x\", \"0\");\n                cliprect.setAttributeNS(null, \"y\", \"0\");\n                cliprect.setAttributeNS(null, \"width\", pf(width));\n                cliprect.setAttributeNS(null, \"height\", pf(height));\n                this.current.element = cliprect;\n                this.clip(\"nonzero\");\n                var imgEl = this.svgFactory.createElement(\"svg:image\");\n                imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n                imgEl.setAttributeNS(null, \"x\", \"0\");\n                imgEl.setAttributeNS(null, \"y\", pf(-height));\n                imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n                imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n                imgEl.setAttributeNS(null, \"transform\", \"scale(\".concat(pf(1 / width), \" \").concat(pf(-1 / height), \")\"));\n                if (mask) {\n                  mask.append(imgEl);\n                } else {\n                  this._ensureTransformGroup().append(imgEl);\n                }\n              }\n            }, {\n              key: \"paintImageMaskXObject\",\n              value: function paintImageMaskXObject(img) {\n                var imgData = this.getObject(img.data, img);\n                if (imgData.bitmap) {\n                  (0, _util.warn)(\"paintImageMaskXObject: ImageBitmap support is not implemented, \" + \"ensure that the `isOffscreenCanvasSupported` API parameter is disabled.\");\n                  return;\n                }\n                var current = this.current;\n                var width = imgData.width;\n                var height = imgData.height;\n                var fillColor = current.fillColor;\n                current.maskId = \"mask\".concat(maskCount++);\n                var mask = this.svgFactory.createElement(\"svg:mask\");\n                mask.setAttributeNS(null, \"id\", current.maskId);\n                var rect = this.svgFactory.createElement(\"svg:rect\");\n                rect.setAttributeNS(null, \"x\", \"0\");\n                rect.setAttributeNS(null, \"y\", \"0\");\n                rect.setAttributeNS(null, \"width\", pf(width));\n                rect.setAttributeNS(null, \"height\", pf(height));\n                rect.setAttributeNS(null, \"fill\", fillColor);\n                rect.setAttributeNS(null, \"mask\", \"url(#\".concat(current.maskId, \")\"));\n                this.defs.append(mask);\n                this._ensureTransformGroup().append(rect);\n                this.paintInlineImageXObject(imgData, mask);\n              }\n            }, {\n              key: \"paintFormXObjectBegin\",\n              value: function paintFormXObjectBegin(matrix, bbox) {\n                if (Array.isArray(matrix) && matrix.length === 6) {\n                  this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n                }\n                if (bbox) {\n                  var width = bbox[2] - bbox[0];\n                  var height = bbox[3] - bbox[1];\n                  var cliprect = this.svgFactory.createElement(\"svg:rect\");\n                  cliprect.setAttributeNS(null, \"x\", bbox[0]);\n                  cliprect.setAttributeNS(null, \"y\", bbox[1]);\n                  cliprect.setAttributeNS(null, \"width\", pf(width));\n                  cliprect.setAttributeNS(null, \"height\", pf(height));\n                  this.current.element = cliprect;\n                  this.clip(\"nonzero\");\n                  this.endPath();\n                }\n              }\n            }, {\n              key: \"paintFormXObjectEnd\",\n              value: function paintFormXObjectEnd() {}\n            }, {\n              key: \"_initialize\",\n              value: function _initialize(viewport) {\n                var svg = this.svgFactory.create(viewport.width, viewport.height);\n                var definitions = this.svgFactory.createElement(\"svg:defs\");\n                svg.append(definitions);\n                this.defs = definitions;\n                var rootGroup = this.svgFactory.createElement(\"svg:g\");\n                rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n                svg.append(rootGroup);\n                this.svg = rootGroup;\n                return svg;\n              }\n            }, {\n              key: \"_ensureClipGroup\",\n              value: function _ensureClipGroup() {\n                if (!this.current.clipGroup) {\n                  var clipGroup = this.svgFactory.createElement(\"svg:g\");\n                  clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n                  this.svg.append(clipGroup);\n                  this.current.clipGroup = clipGroup;\n                }\n                return this.current.clipGroup;\n              }\n            }, {\n              key: \"_ensureTransformGroup\",\n              value: function _ensureTransformGroup() {\n                if (!this.tgrp) {\n                  this.tgrp = this.svgFactory.createElement(\"svg:g\");\n                  this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n                  if (this.current.activeClipUrl) {\n                    this._ensureClipGroup().append(this.tgrp);\n                  } else {\n                    this.svg.append(this.tgrp);\n                  }\n                }\n                return this.tgrp;\n              }\n            }]);\n            return SVGGraphics;\n          }();\n        }\n\n        /***/\n      }\n      /******/];\n      /************************************************************************/\n      /******/ // The module cache\n      /******/\n      var __webpack_module_cache__ = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __w_pdfjs_require__(moduleId) {\n        /******/ // Check if module is in cache\n        /******/var cachedModule = __webpack_module_cache__[moduleId];\n        /******/\n        if (cachedModule !== undefined) {\n          /******/return cachedModule.exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/ // no module.id needed\n          /******/ // no module.loaded needed\n          /******/exports: {}\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /************************************************************************/\n      var __webpack_exports__ = {};\n      // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n      (function () {\n        var exports = __webpack_exports__;\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        Object.defineProperty(exports, \"AbortException\", {\n          enumerable: true,\n          get: function get() {\n            return _util.AbortException;\n          }\n        });\n        Object.defineProperty(exports, \"AnnotationEditorLayer\", {\n          enumerable: true,\n          get: function get() {\n            return _annotation_editor_layer.AnnotationEditorLayer;\n          }\n        });\n        Object.defineProperty(exports, \"AnnotationEditorParamsType\", {\n          enumerable: true,\n          get: function get() {\n            return _util.AnnotationEditorParamsType;\n          }\n        });\n        Object.defineProperty(exports, \"AnnotationEditorType\", {\n          enumerable: true,\n          get: function get() {\n            return _util.AnnotationEditorType;\n          }\n        });\n        Object.defineProperty(exports, \"AnnotationEditorUIManager\", {\n          enumerable: true,\n          get: function get() {\n            return _tools.AnnotationEditorUIManager;\n          }\n        });\n        Object.defineProperty(exports, \"AnnotationLayer\", {\n          enumerable: true,\n          get: function get() {\n            return _annotation_layer.AnnotationLayer;\n          }\n        });\n        Object.defineProperty(exports, \"AnnotationMode\", {\n          enumerable: true,\n          get: function get() {\n            return _util.AnnotationMode;\n          }\n        });\n        Object.defineProperty(exports, \"CMapCompressionType\", {\n          enumerable: true,\n          get: function get() {\n            return _util.CMapCompressionType;\n          }\n        });\n        Object.defineProperty(exports, \"FeatureTest\", {\n          enumerable: true,\n          get: function get() {\n            return _util.FeatureTest;\n          }\n        });\n        Object.defineProperty(exports, \"GlobalWorkerOptions\", {\n          enumerable: true,\n          get: function get() {\n            return _worker_options.GlobalWorkerOptions;\n          }\n        });\n        Object.defineProperty(exports, \"InvalidPDFException\", {\n          enumerable: true,\n          get: function get() {\n            return _util.InvalidPDFException;\n          }\n        });\n        Object.defineProperty(exports, \"MissingPDFException\", {\n          enumerable: true,\n          get: function get() {\n            return _util.MissingPDFException;\n          }\n        });\n        Object.defineProperty(exports, \"OPS\", {\n          enumerable: true,\n          get: function get() {\n            return _util.OPS;\n          }\n        });\n        Object.defineProperty(exports, \"PDFDataRangeTransport\", {\n          enumerable: true,\n          get: function get() {\n            return _api.PDFDataRangeTransport;\n          }\n        });\n        Object.defineProperty(exports, \"PDFDateString\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.PDFDateString;\n          }\n        });\n        Object.defineProperty(exports, \"PDFWorker\", {\n          enumerable: true,\n          get: function get() {\n            return _api.PDFWorker;\n          }\n        });\n        Object.defineProperty(exports, \"PasswordResponses\", {\n          enumerable: true,\n          get: function get() {\n            return _util.PasswordResponses;\n          }\n        });\n        Object.defineProperty(exports, \"PermissionFlag\", {\n          enumerable: true,\n          get: function get() {\n            return _util.PermissionFlag;\n          }\n        });\n        Object.defineProperty(exports, \"PixelsPerInch\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.PixelsPerInch;\n          }\n        });\n        Object.defineProperty(exports, \"PromiseCapability\", {\n          enumerable: true,\n          get: function get() {\n            return _util.PromiseCapability;\n          }\n        });\n        Object.defineProperty(exports, \"RenderingCancelledException\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.RenderingCancelledException;\n          }\n        });\n        Object.defineProperty(exports, \"SVGGraphics\", {\n          enumerable: true,\n          get: function get() {\n            return _svg.SVGGraphics;\n          }\n        });\n        Object.defineProperty(exports, \"UnexpectedResponseException\", {\n          enumerable: true,\n          get: function get() {\n            return _util.UnexpectedResponseException;\n          }\n        });\n        Object.defineProperty(exports, \"Util\", {\n          enumerable: true,\n          get: function get() {\n            return _util.Util;\n          }\n        });\n        Object.defineProperty(exports, \"VerbosityLevel\", {\n          enumerable: true,\n          get: function get() {\n            return _util.VerbosityLevel;\n          }\n        });\n        Object.defineProperty(exports, \"XfaLayer\", {\n          enumerable: true,\n          get: function get() {\n            return _xfa_layer.XfaLayer;\n          }\n        });\n        Object.defineProperty(exports, \"build\", {\n          enumerable: true,\n          get: function get() {\n            return _api.build;\n          }\n        });\n        Object.defineProperty(exports, \"createValidAbsoluteUrl\", {\n          enumerable: true,\n          get: function get() {\n            return _util.createValidAbsoluteUrl;\n          }\n        });\n        Object.defineProperty(exports, \"getDocument\", {\n          enumerable: true,\n          get: function get() {\n            return _api.getDocument;\n          }\n        });\n        Object.defineProperty(exports, \"getFilenameFromUrl\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.getFilenameFromUrl;\n          }\n        });\n        Object.defineProperty(exports, \"getPdfFilenameFromUrl\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.getPdfFilenameFromUrl;\n          }\n        });\n        Object.defineProperty(exports, \"getXfaPageViewport\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.getXfaPageViewport;\n          }\n        });\n        Object.defineProperty(exports, \"isDataScheme\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.isDataScheme;\n          }\n        });\n        Object.defineProperty(exports, \"isPdfFile\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.isPdfFile;\n          }\n        });\n        Object.defineProperty(exports, \"loadScript\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.loadScript;\n          }\n        });\n        Object.defineProperty(exports, \"normalizeUnicode\", {\n          enumerable: true,\n          get: function get() {\n            return _util.normalizeUnicode;\n          }\n        });\n        Object.defineProperty(exports, \"renderTextLayer\", {\n          enumerable: true,\n          get: function get() {\n            return _text_layer.renderTextLayer;\n          }\n        });\n        Object.defineProperty(exports, \"setLayerDimensions\", {\n          enumerable: true,\n          get: function get() {\n            return _display_utils.setLayerDimensions;\n          }\n        });\n        Object.defineProperty(exports, \"shadow\", {\n          enumerable: true,\n          get: function get() {\n            return _util.shadow;\n          }\n        });\n        Object.defineProperty(exports, \"updateTextLayer\", {\n          enumerable: true,\n          get: function get() {\n            return _text_layer.updateTextLayer;\n          }\n        });\n        Object.defineProperty(exports, \"version\", {\n          enumerable: true,\n          get: function get() {\n            return _api.version;\n          }\n        });\n        var _util = __w_pdfjs_require__(1);\n        var _api = __w_pdfjs_require__(2);\n        var _display_utils = __w_pdfjs_require__(6);\n        var _text_layer = __w_pdfjs_require__(26);\n        var _annotation_editor_layer = __w_pdfjs_require__(27);\n        var _tools = __w_pdfjs_require__(5);\n        var _annotation_layer = __w_pdfjs_require__(32);\n        var _worker_options = __w_pdfjs_require__(14);\n        var _svg = __w_pdfjs_require__(35);\n        var _xfa_layer = __w_pdfjs_require__(34);\n        var pdfjsVersion = '3.6.172';\n        var pdfjsBuild = '4d3dfe254';\n      })();\n\n      /******/\n      return __webpack_exports__;\n      /******/\n    }()\n  );\n});\n//# sourceMappingURL=pdf.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}